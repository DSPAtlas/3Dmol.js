/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ThreeDmol"] = factory();
	else
		root["ThreeDmol"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/iobuffer/lib-esm/IOBuffer.js":
/*!***************************************************!*\
  !*** ./node_modules/iobuffer/lib-esm/IOBuffer.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IOBuffer: () => (/* binding */ IOBuffer)\n/* harmony export */ });\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text */ \"./node_modules/iobuffer/lib-esm/text.browser.js\");\n\nconst defaultByteLength = 1024 * 8;\nconst hostBigEndian = (() => {\n    const array = new Uint8Array(4);\n    const view = new Uint32Array(array.buffer);\n    return !((view[0] = 1) & array[0]);\n})();\nconst typedArrays = {\n    int8: globalThis.Int8Array,\n    uint8: globalThis.Uint8Array,\n    int16: globalThis.Int16Array,\n    uint16: globalThis.Uint16Array,\n    int32: globalThis.Int32Array,\n    uint32: globalThis.Uint32Array,\n    uint64: globalThis.BigUint64Array,\n    int64: globalThis.BigInt64Array,\n    float32: globalThis.Float32Array,\n    float64: globalThis.Float64Array,\n};\nclass IOBuffer {\n    /**\n     * @param data - The data to construct the IOBuffer with.\n     * If data is a number, it will be the new buffer's length<br>\n     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n     * @param options\n     */\n    constructor(data = defaultByteLength, options = {}) {\n        let dataIsGiven = false;\n        if (typeof data === 'number') {\n            data = new ArrayBuffer(data);\n        }\n        else {\n            dataIsGiven = true;\n            this.lastWrittenByte = data.byteLength;\n        }\n        const offset = options.offset ? options.offset >>> 0 : 0;\n        const byteLength = data.byteLength - offset;\n        let dvOffset = offset;\n        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n            if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n            }\n            data = data.buffer;\n        }\n        if (dataIsGiven) {\n            this.lastWrittenByte = byteLength;\n        }\n        else {\n            this.lastWrittenByte = 0;\n        }\n        this.buffer = data;\n        this.length = byteLength;\n        this.byteLength = byteLength;\n        this.byteOffset = dvOffset;\n        this.offset = 0;\n        this.littleEndian = true;\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\n        this._mark = 0;\n        this._marks = [];\n    }\n    /**\n     * Checks if the memory allocated to the buffer is sufficient to store more\n     * bytes after the offset.\n     * @param byteLength - The needed memory in bytes.\n     * @returns `true` if there is sufficient space and `false` otherwise.\n     */\n    available(byteLength = 1) {\n        return this.offset + byteLength <= this.length;\n    }\n    /**\n     * Check if little-endian mode is used for reading and writing multi-byte\n     * values.\n     * @returns `true` if little-endian mode is used, `false` otherwise.\n     */\n    isLittleEndian() {\n        return this.littleEndian;\n    }\n    /**\n     * Set little-endian mode for reading and writing multi-byte values.\n     */\n    setLittleEndian() {\n        this.littleEndian = true;\n        return this;\n    }\n    /**\n     * Check if big-endian mode is used for reading and writing multi-byte values.\n     * @returns `true` if big-endian mode is used, `false` otherwise.\n     */\n    isBigEndian() {\n        return !this.littleEndian;\n    }\n    /**\n     * Switches to big-endian mode for reading and writing multi-byte values.\n     */\n    setBigEndian() {\n        this.littleEndian = false;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes forward.\n     * @param n - Number of bytes to skip.\n     */\n    skip(n = 1) {\n        this.offset += n;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes backward.\n     * @param n - Number of bytes to move back.\n     */\n    back(n = 1) {\n        this.offset -= n;\n        return this;\n    }\n    /**\n     * Move the pointer to the given offset.\n     * @param offset\n     */\n    seek(offset) {\n        this.offset = offset;\n        return this;\n    }\n    /**\n     * Store the current pointer offset.\n     * @see {@link IOBuffer#reset}\n     */\n    mark() {\n        this._mark = this.offset;\n        return this;\n    }\n    /**\n     * Move the pointer back to the last pointer offset set by mark.\n     * @see {@link IOBuffer#mark}\n     */\n    reset() {\n        this.offset = this._mark;\n        return this;\n    }\n    /**\n     * Push the current pointer offset to the mark stack.\n     * @see {@link IOBuffer#popMark}\n     */\n    pushMark() {\n        this._marks.push(this.offset);\n        return this;\n    }\n    /**\n     * Pop the last pointer offset from the mark stack, and set the current\n     * pointer offset to the popped value.\n     * @see {@link IOBuffer#pushMark}\n     */\n    popMark() {\n        const offset = this._marks.pop();\n        if (offset === undefined) {\n            throw new Error('Mark stack empty');\n        }\n        this.seek(offset);\n        return this;\n    }\n    /**\n     * Move the pointer offset back to 0.\n     */\n    rewind() {\n        this.offset = 0;\n        return this;\n    }\n    /**\n     * Make sure the buffer has sufficient memory to write a given byteLength at\n     * the current pointer offset.\n     * If the buffer's memory is insufficient, this method will create a new\n     * buffer (a copy) with a length that is twice (byteLength + current offset).\n     * @param byteLength\n     */\n    ensureAvailable(byteLength = 1) {\n        if (!this.available(byteLength)) {\n            const lengthNeeded = this.offset + byteLength;\n            const newLength = lengthNeeded * 2;\n            const newArray = new Uint8Array(newLength);\n            newArray.set(new Uint8Array(this.buffer));\n            this.buffer = newArray.buffer;\n            this.length = this.byteLength = newLength;\n            this._data = new DataView(this.buffer);\n        }\n        return this;\n    }\n    /**\n     * Read a byte and return false if the byte's value is 0, or true otherwise.\n     * Moves pointer forward by one byte.\n     */\n    readBoolean() {\n        return this.readUint8() !== 0;\n    }\n    /**\n     * Read a signed 8-bit integer and move pointer forward by 1 byte.\n     */\n    readInt8() {\n        return this._data.getInt8(this.offset++);\n    }\n    /**\n     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n     */\n    readUint8() {\n        return this._data.getUint8(this.offset++);\n    }\n    /**\n     * Alias for {@link IOBuffer#readUint8}.\n     */\n    readByte() {\n        return this.readUint8();\n    }\n    /**\n     * Read `n` bytes and move pointer forward by `n` bytes.\n     */\n    readBytes(n = 1) {\n        return this.readArray(n, 'uint8');\n    }\n    /**\n     * Creates an array of corresponding to the type `type` and size `size`.\n     * For example type `uint8` will create a `Uint8Array`.\n     * @param size - size of the resulting array\n     * @param type - number type of elements to read\n     */\n    readArray(size, type) {\n        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;\n        const offset = this.byteOffset + this.offset;\n        const slice = this.buffer.slice(offset, offset + bytes);\n        if (this.littleEndian === hostBigEndian &&\n            type !== 'uint8' &&\n            type !== 'int8') {\n            const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));\n            slice.reverse();\n            const returnArray = new typedArrays[type](slice.buffer);\n            this.offset += bytes;\n            returnArray.reverse();\n            return returnArray;\n        }\n        const returnArray = new typedArrays[type](slice);\n        this.offset += bytes;\n        return returnArray;\n    }\n    /**\n     * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n     */\n    readInt16() {\n        const value = this._data.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n     */\n    readUint16() {\n        const value = this._data.getUint16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n     */\n    readInt32() {\n        const value = this._data.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n     */\n    readUint32() {\n        const value = this._data.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit floating number and move pointer forward by 4 bytes.\n     */\n    readFloat32() {\n        const value = this._data.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 64-bit floating number and move pointer forward by 8 bytes.\n     */\n    readFloat64() {\n        const value = this._data.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\n     */\n    readBigInt64() {\n        const value = this._data.getBigInt64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\n     */\n    readBigUint64() {\n        const value = this._data.getBigUint64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n     */\n    readChar() {\n        return String.fromCharCode(this.readInt8());\n    }\n    /**\n     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n     */\n    readChars(n = 1) {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += this.readChar();\n        }\n        return result;\n    }\n    /**\n     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n     * forward by `n` bytes.\n     */\n    readUtf8(n = 1) {\n        return (0,_text__WEBPACK_IMPORTED_MODULE_0__.decode)(this.readBytes(n));\n    }\n    /**\n     * Read the next `n` bytes, return a string decoded with `encoding` and move pointer\n     * forward by `n` bytes.\n     * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}\n     */\n    decodeText(n = 1, encoding = 'utf-8') {\n        return (0,_text__WEBPACK_IMPORTED_MODULE_0__.decode)(this.readBytes(n), encoding);\n    }\n    /**\n     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n     * forward by 1 byte.\n     */\n    writeBoolean(value) {\n        this.writeUint8(value ? 0xff : 0x00);\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n     */\n    writeInt8(value) {\n        this.ensureAvailable(1);\n        this._data.setInt8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n     * byte.\n     */\n    writeUint8(value) {\n        this.ensureAvailable(1);\n        this._data.setUint8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * An alias for {@link IOBuffer#writeUint8}.\n     */\n    writeByte(value) {\n        return this.writeUint8(value);\n    }\n    /**\n     * Write all elements of `bytes` as uint8 values and move pointer forward by\n     * `bytes.length` bytes.\n     */\n    writeBytes(bytes) {\n        this.ensureAvailable(bytes.length);\n        for (let i = 0; i < bytes.length; i++) {\n            this._data.setUint8(this.offset++, bytes[i]);\n        }\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit signed integer and move pointer forward by 2\n     * bytes.\n     */\n    writeInt16(value) {\n        this.ensureAvailable(2);\n        this._data.setInt16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n     * bytes.\n     */\n    writeUint16(value) {\n        this.ensureAvailable(2);\n        this._data.setUint16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit signed integer and move pointer forward by 4\n     * bytes.\n     */\n    writeInt32(value) {\n        this.ensureAvailable(4);\n        this._data.setInt32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n     * bytes.\n     */\n    writeUint32(value) {\n        this.ensureAvailable(4);\n        this._data.setUint32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit floating number and move pointer forward by 4\n     * bytes.\n     */\n    writeFloat32(value) {\n        this.ensureAvailable(4);\n        this._data.setFloat32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit floating number and move pointer forward by 8\n     * bytes.\n     */\n    writeFloat64(value) {\n        this.ensureAvailable(8);\n        this._data.setFloat64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit signed bigint and move pointer forward by 8\n     * bytes.\n     */\n    writeBigInt64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigInt64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\n     * bytes.\n     */\n    writeBigUint64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigUint64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n     * and move pointer forward by 1 byte.\n     */\n    writeChar(str) {\n        return this.writeUint8(str.charCodeAt(0));\n    }\n    /**\n     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n     * and move pointer forward by `str.length` bytes.\n     */\n    writeChars(str) {\n        for (let i = 0; i < str.length; i++) {\n            this.writeUint8(str.charCodeAt(i));\n        }\n        return this;\n    }\n    /**\n     * UTF-8 encode and write `str` to the current pointer offset and move pointer\n     * forward according to the encoded length.\n     */\n    writeUtf8(str) {\n        return this.writeBytes((0,_text__WEBPACK_IMPORTED_MODULE_0__.encode)(str));\n    }\n    /**\n     * Export a Uint8Array view of the internal buffer.\n     * The view starts at the byte offset and its length\n     * is calculated to stop at the last written byte or the original length.\n     */\n    toArray() {\n        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n    }\n    /**\n     * Update the last written byte offset\n     * @private\n     */\n    _updateLastWrittenByte() {\n        if (this.offset > this.lastWrittenByte) {\n            this.lastWrittenByte = this.offset;\n        }\n    }\n}\n//# sourceMappingURL=IOBuffer.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/iobuffer/lib-esm/IOBuffer.js?");

/***/ }),

/***/ "./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js":
/*!*****************************************************************!*\
  !*** ./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js ***!
  \*****************************************************************/
/***/ (function() {

"use strict";
eval("\n/*\n * Copyright 2017 Sam Thorogood. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n(function (scope) {\n    'use strict';\n    // fail early\n    if (scope['TextEncoder'] && scope['TextDecoder']) {\n        return false;\n    }\n    /**\n     * @constructor\n     * @param {string=} utfLabel\n     */\n    function FastTextEncoder(utfLabel = 'utf-8') {\n        if (utfLabel !== 'utf-8') {\n            throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);\n        }\n    }\n    Object.defineProperty(FastTextEncoder.prototype, 'encoding', {\n        value: 'utf-8',\n    });\n    /**\n     * @param {string} string\n     * @param {{stream: boolean}=} options\n     * @return {!Uint8Array}\n     */\n    FastTextEncoder.prototype.encode = function (string, options = { stream: false }) {\n        if (options.stream) {\n            throw new Error(`Failed to encode: the 'stream' option is unsupported.`);\n        }\n        let pos = 0;\n        const len = string.length;\n        const out = [];\n        let at = 0; // output position\n        let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n        let target = new Uint8Array((tlen >> 3) << 3); // ... but at 8 byte offset\n        while (pos < len) {\n            let value = string.charCodeAt(pos++);\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < len) {\n                    const extra = string.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n                if (value >= 0xd800 && value <= 0xdbff) {\n                    continue; // drop lone surrogate\n                }\n            }\n            // expand the buffer if we couldn't write 4 bytes\n            if (at + 4 > target.length) {\n                tlen += 8; // minimum extra\n                tlen *= 1.0 + (pos / string.length) * 2; // take 2x the remaining\n                tlen = (tlen >> 3) << 3; // 8 byte offset\n                const update = new Uint8Array(tlen);\n                update.set(target);\n                target = update;\n            }\n            if ((value & 0xffffff80) === 0) {\n                // 1-byte\n                target[at++] = value; // ASCII\n                continue;\n            }\n            else if ((value & 0xfffff800) === 0) {\n                // 2-byte\n                target[at++] = ((value >> 6) & 0x1f) | 0xc0;\n            }\n            else if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                target[at++] = ((value >> 12) & 0x0f) | 0xe0;\n                target[at++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else if ((value & 0xffe00000) === 0) {\n                // 4-byte\n                target[at++] = ((value >> 18) & 0x07) | 0xf0;\n                target[at++] = ((value >> 12) & 0x3f) | 0x80;\n                target[at++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // FIXME: do we care\n                continue;\n            }\n            target[at++] = (value & 0x3f) | 0x80;\n        }\n        return target.slice(0, at);\n    };\n    /**\n     * @constructor\n     * @param {string=} utfLabel\n     * @param {{fatal: boolean}=} options\n     */\n    function FastTextDecoder(utfLabel = 'utf-8', options = { fatal: false }) {\n        if (utfLabel !== 'utf-8') {\n            throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);\n        }\n        if (options.fatal) {\n            throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);\n        }\n    }\n    Object.defineProperty(FastTextDecoder.prototype, 'encoding', {\n        value: 'utf-8',\n    });\n    Object.defineProperty(FastTextDecoder.prototype, 'fatal', { value: false });\n    Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {\n        value: false,\n    });\n    /**\n     * @param {(!ArrayBuffer|!ArrayBufferView)} buffer\n     * @param {{stream: boolean}=} options\n     */\n    FastTextDecoder.prototype.decode = function (buffer, options = { stream: false }) {\n        if (options['stream']) {\n            throw new Error(`Failed to decode: the 'stream' option is unsupported.`);\n        }\n        const bytes = new Uint8Array(buffer);\n        let pos = 0;\n        const len = bytes.length;\n        const out = [];\n        while (pos < len) {\n            const byte1 = bytes[pos++];\n            if (byte1 === 0) {\n                break; // NULL\n            }\n            if ((byte1 & 0x80) === 0) {\n                // 1-byte\n                out.push(byte1);\n            }\n            else if ((byte1 & 0xe0) === 0xc0) {\n                // 2-byte\n                const byte2 = bytes[pos++] & 0x3f;\n                out.push(((byte1 & 0x1f) << 6) | byte2);\n            }\n            else if ((byte1 & 0xf0) === 0xe0) {\n                const byte2 = bytes[pos++] & 0x3f;\n                const byte3 = bytes[pos++] & 0x3f;\n                out.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n            }\n            else if ((byte1 & 0xf8) === 0xf0) {\n                const byte2 = bytes[pos++] & 0x3f;\n                const byte3 = bytes[pos++] & 0x3f;\n                const byte4 = bytes[pos++] & 0x3f;\n                // this can be > 0xffff, so possibly generate surrogates\n                let codepoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n                if (codepoint > 0xffff) {\n                    // codepoint &= ~0x10000;\n                    codepoint -= 0x10000;\n                    out.push(((codepoint >>> 10) & 0x3ff) | 0xd800);\n                    codepoint = 0xdc00 | (codepoint & 0x3ff);\n                }\n                out.push(codepoint);\n            }\n            else {\n                // FIXME: we're ignoring this\n            }\n        }\n        return String.fromCharCode.apply(null, out);\n    };\n    scope['TextEncoder'] = FastTextEncoder;\n    scope['TextDecoder'] = FastTextDecoder;\n})(typeof window !== 'undefined'\n    ? window\n    : typeof self !== 'undefined'\n        ? self\n        : this);\n//# sourceMappingURL=text-encoding-polyfill.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js?");

/***/ }),

/***/ "./node_modules/iobuffer/lib-esm/text.browser.js":
/*!*******************************************************!*\
  !*** ./node_modules/iobuffer/lib-esm/text.browser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _text_encoding_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text-encoding-polyfill */ \"./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js\");\n/* harmony import */ var _text_encoding_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_text_encoding_polyfill__WEBPACK_IMPORTED_MODULE_0__);\n// eslint-disable-next-line import/no-unassigned-import\n\nfunction decode(bytes, encoding = 'utf8') {\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(bytes);\n}\nconst encoder = new TextEncoder();\nfunction encode(str) {\n    return encoder.encode(str);\n}\n//# sourceMappingURL=text.browser.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/iobuffer/lib-esm/text.browser.js?");

/***/ }),

/***/ "./node_modules/netcdfjs/lib-esm/data.js":
/*!***********************************************!*\
  !*** ./node_modules/netcdfjs/lib-esm/data.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   nonRecord: () => (/* binding */ nonRecord),\n/* harmony export */   record: () => (/* binding */ record)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/netcdfjs/lib-esm/types.js\");\n\n// const STREAMING = 4294967295;\n/**\n * Read data for the given non-record variable\n * @param buffer - Buffer for the file data\n * @param variable - Variable metadata\n * @return - Data of the element\n */\nfunction nonRecord(buffer, variable) {\n    // variable type\n    const type = (0,_types__WEBPACK_IMPORTED_MODULE_0__.str2num)(variable.type);\n    // size of the data\n    const size = variable.size / (0,_types__WEBPACK_IMPORTED_MODULE_0__.num2bytes)(type);\n    // iterates over the data\n    const data = new Array(size);\n    for (let i = 0; i < size; i++) {\n        data[i] = (0,_types__WEBPACK_IMPORTED_MODULE_0__.readType)(buffer, type, 1);\n    }\n    return data;\n}\n/**\n * Read data for the given record variable\n * @param buffer - Buffer for the file data\n * @param variable - Variable metadata\n * @param recordDimension - Record dimension metadata\n * @return - Data of the element\n */\nfunction record(buffer, variable, recordDimension) {\n    // variable type\n    const type = (0,_types__WEBPACK_IMPORTED_MODULE_0__.str2num)(variable.type);\n    const width = variable.size ? variable.size / (0,_types__WEBPACK_IMPORTED_MODULE_0__.num2bytes)(type) : 1;\n    // size of the data\n    // TODO streaming data\n    const size = recordDimension.length;\n    // iterates over the data\n    const data = new Array(size);\n    const step = recordDimension.recordStep;\n    if (step) {\n        for (let i = 0; i < size; i++) {\n            const currentOffset = buffer.offset;\n            data[i] = (0,_types__WEBPACK_IMPORTED_MODULE_0__.readType)(buffer, type, width);\n            buffer.seek(currentOffset + step);\n        }\n    }\n    else {\n        throw new Error('recordDimension.recordStep is undefined');\n    }\n    return data;\n}\n//# sourceMappingURL=data.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/netcdfjs/lib-esm/data.js?");

/***/ }),

/***/ "./node_modules/netcdfjs/lib-esm/header.js":
/*!*************************************************!*\
  !*** ./node_modules/netcdfjs/lib-esm/header.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   header: () => (/* binding */ header)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/netcdfjs/lib-esm/types.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/netcdfjs/lib-esm/utils.js\");\n\n\n// Grammar constants\nconst ZERO = 0;\nconst NC_DIMENSION = 10;\nconst NC_VARIABLE = 11;\nconst NC_ATTRIBUTE = 12;\nconst NC_UNLIMITED = 0;\n/**\n * Reads the file header as @see {@link Header}\n * @param buffer - Buffer for the file data\n * @param version - Version of the file\n * @returns\n */\nfunction header(buffer, version) {\n    const header = { version };\n    const recordDimension = {\n        length: buffer.readUint32(),\n    };\n    const dimList = dimensionsList(buffer);\n    if (!Array.isArray(dimList)) {\n        recordDimension.id = dimList.recordId;\n        recordDimension.name = dimList.recordName;\n        header.dimensions = dimList.dimensions;\n    }\n    header.globalAttributes = attributesList(buffer);\n    const variables = variablesList(buffer, recordDimension?.id, version);\n    if (!Array.isArray(variables)) {\n        header.variables = variables.variables;\n        recordDimension.recordStep = variables.recordStep;\n    }\n    header.recordDimension = recordDimension;\n    return header;\n}\n/**\n * List of dimensions\n * @param buffer - Buffer for the file data\n * @return List of dimensions\n */\nfunction dimensionsList(buffer) {\n    const result = {};\n    let recordId, recordName;\n    const dimList = buffer.readUint32();\n    let dimensions;\n    if (dimList === ZERO) {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(buffer.readUint32() !== ZERO, 'wrong empty tag for list of dimensions');\n        return [];\n    }\n    else {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(dimList !== NC_DIMENSION, 'wrong tag for list of dimensions');\n        // Length of dimensions\n        const dimensionSize = buffer.readUint32();\n        dimensions = new Array(dimensionSize);\n        //populate `name` and `size` for each dimension\n        for (let dim = 0; dim < dimensionSize; dim++) {\n            // Read name\n            const name = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.readName)(buffer);\n            // Read dimension size\n            const size = buffer.readUint32();\n            if (size === NC_UNLIMITED) {\n                // in netcdf 3 one field can be of size unlimited\n                recordId = dim;\n                recordName = name;\n            }\n            dimensions[dim] = {\n                name,\n                size,\n            };\n        }\n    }\n    if (recordId !== undefined) {\n        result.recordId = recordId;\n    }\n    if (recordName !== undefined) {\n        result.recordName = recordName;\n    }\n    result.dimensions = dimensions;\n    return result;\n}\n/**\n * List of attributes\n * @param buffer - Buffer for the file data\n * @return - List of attributes with:\n */\nfunction attributesList(buffer) {\n    const gAttList = buffer.readUint32();\n    let attributes;\n    if (gAttList === ZERO) {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(buffer.readUint32() !== ZERO, 'wrong empty tag for list of attributes');\n        return [];\n    }\n    else {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(gAttList !== NC_ATTRIBUTE, 'wrong tag for list of attributes');\n        // Length of attributes\n        const attributeSize = buffer.readUint32();\n        attributes = new Array(attributeSize);\n        // Populate `name`, `type` and `value` for each attribute\n        for (let gAtt = 0; gAtt < attributeSize; gAtt++) {\n            // Read name\n            const name = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.readName)(buffer);\n            // Read type\n            const type = buffer.readUint32();\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(type < 1 || type > 6, `non valid type ${type}`);\n            // Read attribute\n            const size = buffer.readUint32();\n            const value = (0,_types__WEBPACK_IMPORTED_MODULE_0__.readType)(buffer, type, size);\n            // Apply padding\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.padding)(buffer);\n            attributes[gAtt] = {\n                name,\n                type: (0,_types__WEBPACK_IMPORTED_MODULE_0__.num2str)(type),\n                value,\n            };\n        }\n    }\n    return attributes;\n}\n/**\n * @param buffer - Buffer for the file data\n * @param recordId - Id of the unlimited dimension (also called record dimension)\n * This value may be undefined if there is no unlimited dimension\n * @param version - Version of the file\n * @return - Number of recordStep and list of variables @see {@link Variables}\n */\nfunction variablesList(buffer, recordId, version) {\n    const varList = buffer.readUint32();\n    let recordStep = 0;\n    let variables;\n    if (varList === ZERO) {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(buffer.readUint32() !== ZERO, 'wrong empty tag for list of variables');\n        return [];\n    }\n    else {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(varList !== NC_VARIABLE, 'wrong tag for list of variables');\n        // Length of variables\n        const variableSize = buffer.readUint32();\n        variables = new Array(variableSize);\n        for (let v = 0; v < variableSize; v++) {\n            // Read name\n            const name = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.readName)(buffer);\n            // Read dimensionality of the variable\n            const dimensionality = buffer.readUint32();\n            // Index into the list of dimensions\n            const dimensionsIds = new Array(dimensionality);\n            for (let dim = 0; dim < dimensionality; dim++) {\n                dimensionsIds[dim] = buffer.readUint32();\n            }\n            // Read variables size\n            const attributes = attributesList(buffer);\n            // Read type\n            const type = buffer.readUint32();\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(type < 1 && type > 6, `non valid type ${type}`);\n            // Read variable size\n            // The 32-bit varSize field is not large enough to contain the size of variables that require\n            // more than 2^32 - 4 bytes, so 2^32 - 1 is used in the varSize field for such variables.\n            const varSize = buffer.readUint32();\n            // Read offset\n            let offset = buffer.readUint32();\n            if (version === 2) {\n                (0,_utils__WEBPACK_IMPORTED_MODULE_1__.notNetcdf)(offset > 0, 'offsets larger than 4GB not supported');\n                offset = buffer.readUint32();\n            }\n            let record = false;\n            // Count amount of record variables\n            if (typeof recordId !== 'undefined' && dimensionsIds[0] === recordId) {\n                recordStep += varSize;\n                record = true;\n            }\n            variables[v] = {\n                name,\n                dimensions: dimensionsIds,\n                attributes,\n                type: (0,_types__WEBPACK_IMPORTED_MODULE_0__.num2str)(type),\n                size: varSize,\n                offset,\n                record,\n            };\n        }\n    }\n    return {\n        variables,\n        recordStep,\n    };\n}\n//# sourceMappingURL=header.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/netcdfjs/lib-esm/header.js?");

/***/ }),

/***/ "./node_modules/netcdfjs/lib-esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/netcdfjs/lib-esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetCDFReader: () => (/* reexport safe */ _parser__WEBPACK_IMPORTED_MODULE_0__.NetCDFReader)\n/* harmony export */ });\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser */ \"./node_modules/netcdfjs/lib-esm/parser.js\");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/netcdfjs/lib-esm/index.js?");

/***/ }),

/***/ "./node_modules/netcdfjs/lib-esm/parser.js":
/*!*************************************************!*\
  !*** ./node_modules/netcdfjs/lib-esm/parser.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NetCDFReader: () => (/* binding */ NetCDFReader)\n/* harmony export */ });\n/* harmony import */ var iobuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! iobuffer */ \"./node_modules/iobuffer/lib-esm/IOBuffer.js\");\n/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data */ \"./node_modules/netcdfjs/lib-esm/data.js\");\n/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./header */ \"./node_modules/netcdfjs/lib-esm/header.js\");\n/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString */ \"./node_modules/netcdfjs/lib-esm/toString.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./node_modules/netcdfjs/lib-esm/utils.js\");\n\n\n\n\n\n/**\n * Reads a NetCDF v3.x file\n * [See specification](https://www.unidata.ucar.edu/software/netcdf/docs/file_format_specifications.html)\n * @param data - ArrayBuffer or any Typed Array (including Node.js' Buffer from v4) with the data\n * @constructor\n */\nclass NetCDFReader {\n    constructor(data) {\n        this.toString = _toString__WEBPACK_IMPORTED_MODULE_3__.toString;\n        const buffer = new iobuffer__WEBPACK_IMPORTED_MODULE_0__.IOBuffer(data);\n        buffer.setBigEndian();\n        // Validate that it's a NetCDF file\n        (0,_utils__WEBPACK_IMPORTED_MODULE_4__.notNetcdf)(buffer.readChars(3) !== 'CDF', 'should start with CDF');\n        // Check the NetCDF format\n        const version = buffer.readByte();\n        (0,_utils__WEBPACK_IMPORTED_MODULE_4__.notNetcdf)(version > 2, 'unknown version');\n        // Read the header\n        this.header = (0,_header__WEBPACK_IMPORTED_MODULE_2__.header)(buffer, version);\n        this.buffer = buffer;\n    }\n    /**\n     * @return - Version for the NetCDF format\n     */\n    get version() {\n        if (this.header.version === 1) {\n            return 'classic format';\n        }\n        else {\n            return '64-bit offset format';\n        }\n    }\n    /**\n     * @return {object} - Metadata for the record dimension\n     *  * `length`: Number of elements in the record dimension\n     *  * `id`: Id number in the list of dimensions for the record dimension\n     *  * `name`: String with the name of the record dimension\n     *  * `recordStep`: Number with the record variables step size\n     */\n    get recordDimension() {\n        return this.header.recordDimension;\n    }\n    /**\n     * @return - Array - List of dimensions with:\n     *  * `name`: String with the name of the dimension\n     *  * `size`: Number with the size of the dimension\n     */\n    get dimensions() {\n        return this.header.dimensions;\n    }\n    /**\n     * @return - Array - List of global attributes with:\n     *  * `name`: String with the name of the attribute\n     *  * `type`: String with the type of the attribute\n     *  * `value`: A number or string with the value of the attribute\n     */\n    get globalAttributes() {\n        return this.header.globalAttributes;\n    }\n    /**\n     * Returns the value of an attribute\n     * @param - AttributeName\n     * @return - Value of the attributeName or null\n     */\n    getAttribute(attributeName) {\n        const attribute = this.globalAttributes.find((val) => val.name === attributeName);\n        if (attribute)\n            return attribute.value;\n        return null;\n    }\n    /**\n     * Returns the value of a variable as a string\n     * @param - variableName\n     * @return - Value of the variable as a string or null\n     */\n    getDataVariableAsString(variableName) {\n        const variable = this.getDataVariable(variableName);\n        if (variable)\n            return variable.join('');\n        return null;\n    }\n    get variables() {\n        return this.header.variables;\n    }\n    /**\n     * Retrieves the data for a given variable\n     * @param variableName - Name of the variable to search or variable object\n     * @return The variable values\n     */\n    getDataVariable(variableName) {\n        let variable;\n        if (typeof variableName === 'string') {\n            // search the variable\n            variable = this.header.variables.find((val) => {\n                return val.name === variableName;\n            });\n        }\n        else {\n            variable = variableName;\n        }\n        // throws if variable not found\n        if (variable === undefined) {\n            throw new Error('Not a valid NetCDF v3.x file: variable not found');\n        }\n        // go to the offset position\n        this.buffer.seek(variable.offset);\n        if (variable.record) {\n            // record variable case\n            return (0,_data__WEBPACK_IMPORTED_MODULE_1__.record)(this.buffer, variable, this.header.recordDimension);\n        }\n        else {\n            // non-record variable case\n            return (0,_data__WEBPACK_IMPORTED_MODULE_1__.nonRecord)(this.buffer, variable);\n        }\n    }\n    /**\n     * Check if a dataVariable exists\n     * @param variableName - Name of the variable to find\n     * @return boolean\n     */\n    dataVariableExists(variableName) {\n        const variable = this.header.variables.find((val) => {\n            return val.name === variableName;\n        });\n        return variable !== undefined;\n    }\n    /**\n     * Check if an attribute exists\n     * @param attributeName - Name of the attribute to find\n     * @return boolean\n     */\n    attributeExists(attributeName) {\n        const attribute = this.globalAttributes.find((val) => val.name === attributeName);\n        return attribute !== undefined;\n    }\n}\n//# sourceMappingURL=parser.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/netcdfjs/lib-esm/parser.js?");

/***/ }),

/***/ "./node_modules/netcdfjs/lib-esm/toString.js":
/*!***************************************************!*\
  !*** ./node_modules/netcdfjs/lib-esm/toString.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\nfunction toString() {\n    const result = [];\n    result.push('DIMENSIONS');\n    for (const dimension of this.dimensions) {\n        result.push(`  ${dimension.name.padEnd(30)} = size: ${dimension.size}`);\n    }\n    result.push('');\n    result.push('GLOBAL ATTRIBUTES');\n    for (const attribute of this.globalAttributes) {\n        result.push(`  ${attribute.name.padEnd(30)} = ${attribute.value}`);\n    }\n    const variables = JSON.parse(JSON.stringify(this.variables));\n    result.push('');\n    result.push('VARIABLES:');\n    for (const variable of variables) {\n        variable.value = this.getDataVariable(variable);\n        let stringify = JSON.stringify(variable.value);\n        if (stringify.length > 50)\n            stringify = stringify.substring(0, 50);\n        if (!isNaN(variable.value.length)) {\n            stringify += ` (length: ${variable.value.length})`;\n        }\n        result.push(`  ${variable.name.padEnd(30)} = ${stringify}`);\n    }\n    return result.join('\\n');\n}\n//# sourceMappingURL=toString.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/netcdfjs/lib-esm/toString.js?");

/***/ }),

/***/ "./node_modules/netcdfjs/lib-esm/types.js":
/*!************************************************!*\
  !*** ./node_modules/netcdfjs/lib-esm/types.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   num2bytes: () => (/* binding */ num2bytes),\n/* harmony export */   num2str: () => (/* binding */ num2str),\n/* harmony export */   readType: () => (/* binding */ readType),\n/* harmony export */   str2num: () => (/* binding */ str2num)\n/* harmony export */ });\nconst types = {\n    BYTE: 1,\n    CHAR: 2,\n    SHORT: 3,\n    INT: 4,\n    FLOAT: 5,\n    DOUBLE: 6,\n};\n/**\n * Parse a number into their respective type\n * @param type - integer that represents the type\n * @return - parsed value of the type\n */\nfunction num2str(type) {\n    switch (Number(type)) {\n        case types.BYTE:\n            return 'byte';\n        case types.CHAR:\n            return 'char';\n        case types.SHORT:\n            return 'short';\n        case types.INT:\n            return 'int';\n        case types.FLOAT:\n            return 'float';\n        case types.DOUBLE:\n            return 'double';\n        default:\n            return 'undefined';\n    }\n}\n/**\n * Parse a number type identifier to his size in bytes\n * @param type - integer that represents the type\n * @return size of the type\n */\nfunction num2bytes(type) {\n    switch (Number(type)) {\n        case types.BYTE:\n            return 1;\n        case types.CHAR:\n            return 1;\n        case types.SHORT:\n            return 2;\n        case types.INT:\n            return 4;\n        case types.FLOAT:\n            return 4;\n        case types.DOUBLE:\n            return 8;\n        default:\n            return -1;\n    }\n}\n/**\n * Reverse search of num2str\n * @param type - string that represents the type\n * @return parsed value of the type\n */\nfunction str2num(type) {\n    switch (String(type)) {\n        case 'byte':\n            return types.BYTE;\n        case 'char':\n            return types.CHAR;\n        case 'short':\n            return types.SHORT;\n        case 'int':\n            return types.INT;\n        case 'float':\n            return types.FLOAT;\n        case 'double':\n            return types.DOUBLE;\n        /* istanbul ignore next */\n        default:\n            return -1;\n    }\n}\n/**\n * Auxiliary function to read numeric data\n * @param size - Size of the element to read\n * @param bufferReader - Function to read next value\n * @return\n */\nfunction readNumber(size, bufferReader) {\n    if (size !== 1) {\n        const numbers = new Array(size);\n        for (let i = 0; i < size; i++) {\n            numbers[i] = bufferReader();\n        }\n        return numbers;\n    }\n    else {\n        return bufferReader();\n    }\n}\n/**\n * Given a type and a size reads the next element\n * @param buffer - Buffer for the file data\n * @param type - Type of the data to read\n * @param size - Size of the element to read\n * @return\n */\nfunction readType(buffer, type, size) {\n    switch (type) {\n        case types.BYTE:\n            return Array.from(buffer.readBytes(size));\n        case types.CHAR:\n            return trimNull(buffer.readChars(size));\n        case types.SHORT:\n            return readNumber(size, buffer.readInt16.bind(buffer));\n        case types.INT:\n            return readNumber(size, buffer.readInt32.bind(buffer));\n        case types.FLOAT:\n            return readNumber(size, buffer.readFloat32.bind(buffer));\n        case types.DOUBLE:\n            return readNumber(size, buffer.readFloat64.bind(buffer));\n        default:\n            throw new Error(`non valid type ${type}`);\n    }\n}\n/**\n * Removes null terminate value\n * @param value - String to trim\n * @return - Trimmed string\n */\nfunction trimNull(value) {\n    if (value.charCodeAt(value.length - 1) === 0) {\n        return value.substring(0, value.length - 1);\n    }\n    return value;\n}\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/netcdfjs/lib-esm/types.js?");

/***/ }),

/***/ "./node_modules/netcdfjs/lib-esm/utils.js":
/*!************************************************!*\
  !*** ./node_modules/netcdfjs/lib-esm/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   notNetcdf: () => (/* binding */ notNetcdf),\n/* harmony export */   padding: () => (/* binding */ padding),\n/* harmony export */   readName: () => (/* binding */ readName)\n/* harmony export */ });\n/**\n * Throws a non-valid NetCDF exception if the statement it's true\n * @ignore\n * @param statement - Throws if true\n * @param reason - Reason to throw\n */\nfunction notNetcdf(statement, reason) {\n    if (statement) {\n        throw new TypeError(`Not a valid NetCDF v3.x file: ${reason}`);\n    }\n}\n/**\n * Moves 1, 2, or 3 bytes to next 4-byte boundary\n * @param buffer - Buffer for the file data\n */\nfunction padding(buffer) {\n    if (buffer.offset % 4 !== 0) {\n        buffer.skip(4 - (buffer.offset % 4));\n    }\n}\n/**\n * Reads the name\n * @param buffer - Buffer for the file data\n * @return Name\n */\nfunction readName(buffer) {\n    // Read name\n    const nameLength = buffer.readUint32();\n    const name = buffer.readChars(nameLength);\n    // validate name\n    // TODO\n    // Apply padding\n    padding(buffer);\n    return name;\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/netcdfjs/lib-esm/utils.js?");

/***/ }),

/***/ "./src/GLDraw.ts":
/*!***********************!*\
  !*** ./src/GLDraw.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CAP: () => (/* binding */ CAP),\n/* harmony export */   GLDraw: () => (/* binding */ GLDraw)\n/* harmony export */ });\n/* harmony import */ var _WebGL_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGL/math */ \"./src/WebGL/math/index.ts\");\n\n//define enum values\n/**\n * Enum for cylinder cap styles.\n * @readonly\n * @enum\n * @property NONE\n * @property FLAT\n * @property ROUND\n */\nvar CAP;\n(function (CAP) {\n    CAP[CAP[\"NONE\"] = 0] = \"NONE\";\n    CAP[CAP[\"FLAT\"] = 1] = \"FLAT\";\n    CAP[CAP[\"ROUND\"] = 2] = \"ROUND\";\n})(CAP || (CAP = {}));\n;\n/**\n * Lower level utilities for creating WebGL shape geometries.\n * These are not intended for general consumption.\n * @namespace\n  */\nvar GLDraw;\n(function (GLDraw) {\n    // Rotation matrix around z and x axis -\n    // according to y basis vector\n    // TODO: Try to optimize this (square roots?)\n    function getRotationMatrix(dx, dy, dz) {\n        var dxy = Math.hypot(dx, dy);\n        var dyz;\n        var sinA, cosA, sinB, cosB;\n        // about z axis - Phi\n        if (dxy < 0.0001) {\n            sinA = 0;\n            cosA = 1;\n        }\n        else {\n            sinA = -dx / dxy;\n            cosA = dy / dxy;\n        }\n        // recast dy in terms of new axes - z is the same\n        dy = -sinA * dx + cosA * dy;\n        dyz = Math.hypot(dy, dz);\n        // about new x axis - Theta\n        if (dyz < 0.0001) {\n            sinB = 0;\n            cosB = 1;\n        }\n        else {\n            sinB = dz / dyz;\n            cosB = dy / dyz;\n        }\n        var rot = new Float32Array(9);\n        rot[0] = cosA;\n        rot[1] = sinA;\n        rot[2] = 0;\n        rot[3] = -sinA * cosB;\n        rot[4] = cosA * cosB;\n        rot[5] = sinB;\n        rot[6] = sinA * sinB;\n        rot[7] = -cosA * sinB;\n        rot[8] = cosB;\n        return rot;\n    }\n    ;\n    // memoize capped cylinder for given radius cylVertexCache\n    class CylVertexCache {\n        constructor() {\n            // memoize both rounded and flat caps (hemisphere and circle)\n            this.cache = {};\n            //initialize basisVectors\n            let nvecs = [];\n            let subdivisions = 4; // including the initial 2, eg. 4 => 16 subintervals\n            let N = Math.pow(2, subdivisions); // eg. 2**4 = 16 subintervals in total\n            let i = 2; // start with 2 subdivisions already done\n            let M = Math.pow(2, i); // 4\n            let spacing = N / M; // 16/4 = 4; if there were 5 subdivs, then 32/4 = 8.\n            let j;\n            nvecs[0] = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0);\n            nvecs[spacing] = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);\n            nvecs[spacing * 2] = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);\n            nvecs[spacing * 3] = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);\n            for (i = 3; i <= subdivisions; i++) {\n                // eg. i=3, we need to add 2**(3-1) = 4 new vecs. Call it M.\n                // their spacing is N/M, eg. N=16, M=4, N/M=4; M=8, N/M=2.\n                // they start off at half this spacing\n                // and are equal to the average of the two vectors on either side\n                M = Math.pow(2, (i - 1));\n                spacing = N / M;\n                for (j = 0; j < (M - 1); j++) {\n                    nvecs[spacing / 2 + j * spacing] = nvecs[j * spacing].clone().add(nvecs[(j + 1) * spacing]).normalize();\n                }\n                // treat the last one specially so it wraps around to zero\n                j = M - 1;\n                nvecs[spacing / 2 + j * spacing] = nvecs[j * spacing].clone().add(nvecs[0]).normalize();\n            }\n            this.basisVectors = nvecs;\n        }\n        ;\n        getVerticesForRadius(radius, cap, capType) {\n            if (typeof (this.cache) !== \"undefined\" && this.cache[radius] !== undefined)\n                if (this.cache[radius][cap + capType] !== undefined)\n                    return this.cache[radius][cap + capType];\n            var w = this.basisVectors.length;\n            var nvecs = [], norms = [];\n            var n;\n            for (var i = 0; i < w; i++) {\n                // bottom\n                nvecs.push(this.basisVectors[i].clone().multiplyScalar(radius));\n                // top\n                nvecs.push(this.basisVectors[i].clone().multiplyScalar(radius));\n                // NOTE: this normal is used for constructing sphere caps -\n                // cylinder normals taken care of in drawCylinder\n                n = this.basisVectors[i].clone().normalize();\n                norms.push(n);\n                norms.push(n);\n            }\n            // norms[0]\n            var verticesRows = [];\n            // Require that heightSegments is even and >= 2\n            // Equator points at h/2 (theta = pi/2)\n            // (repeated) polar points at 0 and h (theta = 0 and pi)\n            var heightSegments = 10, widthSegments = w; // 16 or however many\n            // basis vectors for\n            // cylinder\n            if (heightSegments % 2 !== 0 || !heightSegments) {\n                console.error(\"heightSegments must be even\");\n                return null;\n            }\n            var phiStart = 0;\n            var phiLength = Math.PI * 2;\n            var thetaStart = 0;\n            var thetaLength = Math.PI;\n            var x, y;\n            var polar = false, equator = false;\n            for (y = 0; y <= heightSegments; y++) {\n                polar = (y === 0 || y === heightSegments) ? true : false;\n                equator = (y === heightSegments / 2) ? true : false;\n                var verticesRow = [], toRow = [];\n                for (x = 0; x <= widthSegments; x++) {\n                    // Two vertices rows for equator pointing to previously\n                    // constructed cyl points\n                    if (equator) {\n                        var xi = (x < widthSegments) ? 2 * x : 0;\n                        toRow.push(xi + 1);\n                        verticesRow.push(xi);\n                        continue;\n                    }\n                    var u = x / widthSegments;\n                    var v = y / heightSegments;\n                    // Only push first polar point\n                    if (!polar || x === 0) {\n                        if (x < widthSegments) {\n                            var vertex = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                            vertex.x = -radius *\n                                Math.cos(phiStart + u * phiLength) *\n                                Math.sin(thetaStart + v * thetaLength);\n                            if (cap == 1)\n                                vertex.y = 0;\n                            else\n                                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n                            vertex.z = radius *\n                                Math.sin(phiStart + u * phiLength) *\n                                Math.sin(thetaStart + v * thetaLength);\n                            if (Math.abs(vertex.x) < 1e-5)\n                                vertex.x = 0;\n                            if (Math.abs(vertex.y) < 1e-5)\n                                vertex.y = 0;\n                            if (Math.abs(vertex.z) < 1e-5)\n                                vertex.z = 0;\n                            if (cap == CAP.FLAT) {\n                                n = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, Math.cos(thetaStart + v * thetaLength), 0);\n                                n.normalize();\n                            }\n                            else {\n                                n = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(vertex.x, vertex.y, vertex.z);\n                                n.normalize();\n                            }\n                            nvecs.push(vertex);\n                            norms.push(n);\n                            verticesRow.push(nvecs.length - 1);\n                        }\n                        // last point is just the first point for this row\n                        else {\n                            verticesRow.push(nvecs.length - widthSegments);\n                        }\n                    }\n                    // x > 0; index to already added point\n                    else if (polar)\n                        verticesRow.push(nvecs.length - 1);\n                }\n                // extra equator row\n                if (equator)\n                    verticesRows.push(toRow);\n                verticesRows.push(verticesRow);\n            }\n            var obj = {\n                vertices: nvecs,\n                normals: norms,\n                verticesRows: verticesRows,\n                w: widthSegments,\n                h: heightSegments\n            };\n            if (!(radius in this.cache))\n                this.cache[radius] = {};\n            this.cache[radius][cap + capType] = obj;\n            return obj;\n        }\n    }\n    ;\n    var cylVertexCache = new CylVertexCache();\n    /**\n     * Create a cylinder\n     * @memberof GLDraw\n     * @param {Geometry}\n     *            geo\n     * @param {Point}\n     *            from\n     * @param {Point}\n     *            to\n     * @param {number}\n     *            radius\n     * @param {Color}\n     *            color\n     * @param {CAP} fromCap - 0 for none, 1 for flat, 2 for round\n     * @param {CAP} toCap = 0 for none, 1 for flat, 2 for round\n     *\n     * */\n    function drawCylinder(geo, from, to, radius, color, fromCap = 0, toCap = 0) {\n        if (!from || !to)\n            return;\n        let getcap = function (c) {\n            if (typeof c === \"string\") {\n                let s = c;\n                if (s.toLowerCase() == 'flat') {\n                    return CAP.FLAT;\n                }\n                else if (s.toLowerCase() == 'round') {\n                    return CAP.ROUND;\n                }\n                else {\n                    return CAP.NONE;\n                }\n            }\n            else {\n                return c;\n            }\n        };\n        fromCap = getcap(fromCap);\n        toCap = getcap(toCap);\n        // vertices\n        var drawcaps = toCap || fromCap;\n        color = color || { r: 0, g: 0, b: 0 };\n        var e = getRotationMatrix(to.x - from.x, to.y - from.y, to.z - from.z);\n        // get orthonormal vectors from cache\n        // TODO: Will have orient with model view matrix according to direction\n        var vobj = cylVertexCache.getVerticesForRadius(radius, toCap, \"to\");\n        // w (n) corresponds to the number of orthonormal vectors for cylinder\n        // (default 16)\n        var n = vobj.w, h = vobj.h;\n        // get orthonormal vector\n        var n_verts = (drawcaps) ? h * n + 2 : 2 * n;\n        var geoGroup = geo.updateGeoGroup(n_verts);\n        var vertices = vobj.vertices, normals = vobj.normals, verticesRows = vobj.verticesRows;\n        var toRow = verticesRows[h / 2], fromRow = verticesRows[h / 2 + 1];\n        var start = geoGroup.vertices;\n        var offset, faceoffset;\n        var i, x, y, z;\n        var vertexArray = geoGroup.vertexArray;\n        var normalArray = geoGroup.normalArray;\n        var colorArray = geoGroup.colorArray;\n        var faceArray = geoGroup.faceArray;\n        // add vertices, opposing vertices paired together\n        for (i = 0; i < n; ++i) {\n            var vi = 2 * i;\n            x = e[0] * vertices[vi].x + e[3] * vertices[vi].y + e[6] * vertices[vi].z;\n            y = e[1] * vertices[vi].x + e[4] * vertices[vi].y + e[7] * vertices[vi].z;\n            z = e[5] * vertices[vi].y + e[8] * vertices[vi].z;\n            // var xn = x/radius, yn = y/radius, zn = z/radius;\n            offset = 3 * (start + vi);\n            faceoffset = geoGroup.faceidx;\n            // from\n            vertexArray[offset] = x + from.x;\n            vertexArray[offset + 1] = y + from.y;\n            vertexArray[offset + 2] = z + from.z;\n            // to\n            vertexArray[offset + 3] = x + to.x;\n            vertexArray[offset + 4] = y + to.y;\n            vertexArray[offset + 5] = z + to.z;\n            // normals\n            normalArray[offset] = x;\n            normalArray[offset + 3] = x;\n            normalArray[offset + 1] = y;\n            normalArray[offset + 4] = y;\n            normalArray[offset + 2] = z;\n            normalArray[offset + 5] = z;\n            // colors\n            colorArray[offset] = color.r;\n            colorArray[offset + 3] = color.r;\n            colorArray[offset + 1] = color.g;\n            colorArray[offset + 4] = color.g;\n            colorArray[offset + 2] = color.b;\n            colorArray[offset + 5] = color.b;\n            // faces\n            // 0 - 2 - 1\n            faceArray[faceoffset] = fromRow[i] + start;\n            faceArray[faceoffset + 1] = fromRow[i + 1] + start;\n            faceArray[faceoffset + 2] = toRow[i] + start;\n            // 1 - 2 - 3\n            faceArray[faceoffset + 3] = toRow[i] + start;\n            faceArray[faceoffset + 4] = fromRow[i + 1] + start;\n            faceArray[faceoffset + 5] = toRow[i + 1] + start;\n            geoGroup.faceidx += 6;\n        }\n        // SPHERE CAPS\n        if (drawcaps) {\n            // h - sphere rows, verticesRows.length - 2\n            var ystart = (toCap) ? 0 : h / 2;\n            var yend = (fromCap) ? h + 1 : h / 2 + 1;\n            var v1, v2, v3, v4, x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4, nx1, nx2, nx3, nx4, ny1, ny2, ny3, ny4, nz1, nz2, nz3, nz4, v1offset, v2offset, v3offset, v4offset;\n            for (y = ystart; y < yend; y++) {\n                if (y === h / 2)\n                    continue;\n                // n number of points for each level (verticesRows[i].length -\n                // 1)\n                var cap = (y <= h / 2) ? to : from;\n                var toObj = cylVertexCache.getVerticesForRadius(radius, toCap, \"to\");\n                var fromObj = cylVertexCache.getVerticesForRadius(radius, fromCap, \"from\");\n                if (cap === to) {\n                    vertices = toObj.vertices;\n                    normals = toObj.normals;\n                    verticesRows = toObj.verticesRows;\n                }\n                else if (cap == from) {\n                    vertices = fromObj.vertices;\n                    normals = fromObj.normals;\n                    verticesRows = fromObj.verticesRows;\n                }\n                for (x = 0; x < n; x++) {\n                    faceoffset = geoGroup.faceidx;\n                    v1 = verticesRows[y][x + 1];\n                    v1offset = (v1 + start) * 3;\n                    v2 = verticesRows[y][x];\n                    v2offset = (v2 + start) * 3;\n                    v3 = verticesRows[y + 1][x];\n                    v3offset = (v3 + start) * 3;\n                    v4 = verticesRows[y + 1][x + 1];\n                    v4offset = (v4 + start) * 3;\n                    // rotate sphere vectors\n                    x1 = e[0] * vertices[v1].x + e[3] * vertices[v1].y + e[6] * vertices[v1].z;\n                    x2 = e[0] * vertices[v2].x + e[3] * vertices[v2].y + e[6] * vertices[v2].z;\n                    x3 = e[0] * vertices[v3].x + e[3] * vertices[v3].y + e[6] * vertices[v3].z;\n                    x4 = e[0] * vertices[v4].x + e[3] * vertices[v4].y + e[6] * vertices[v4].z;\n                    y1 = e[1] * vertices[v1].x + e[4] * vertices[v1].y + e[7] * vertices[v1].z;\n                    y2 = e[1] * vertices[v2].x + e[4] * vertices[v2].y + e[7] * vertices[v2].z;\n                    y3 = e[1] * vertices[v3].x + e[4] * vertices[v3].y + e[7] * vertices[v3].z;\n                    y4 = e[1] * vertices[v4].x + e[4] * vertices[v4].y + e[7] * vertices[v4].z;\n                    z1 = e[5] * vertices[v1].y + e[8] * vertices[v1].z;\n                    z2 = e[5] * vertices[v2].y + e[8] * vertices[v2].z;\n                    z3 = e[5] * vertices[v3].y + e[8] * vertices[v3].z;\n                    z4 = e[5] * vertices[v4].y + e[8] * vertices[v4].z;\n                    vertexArray[v1offset] = x1 + cap.x;\n                    vertexArray[v2offset] = x2 + cap.x;\n                    vertexArray[v3offset] = x3 + cap.x;\n                    vertexArray[v4offset] = x4 + cap.x;\n                    vertexArray[v1offset + 1] = y1 + cap.y;\n                    vertexArray[v2offset + 1] = y2 + cap.y;\n                    vertexArray[v3offset + 1] = y3 + cap.y;\n                    vertexArray[v4offset + 1] = y4 + cap.y;\n                    vertexArray[v1offset + 2] = z1 + cap.z;\n                    vertexArray[v2offset + 2] = z2 + cap.z;\n                    vertexArray[v3offset + 2] = z3 + cap.z;\n                    vertexArray[v4offset + 2] = z4 + cap.z;\n                    colorArray[v1offset] = color.r;\n                    colorArray[v2offset] = color.r;\n                    colorArray[v3offset] = color.r;\n                    colorArray[v4offset] = color.r;\n                    colorArray[v1offset + 1] = color.g;\n                    colorArray[v2offset + 1] = color.g;\n                    colorArray[v3offset + 1] = color.g;\n                    colorArray[v4offset + 1] = color.g;\n                    colorArray[v1offset + 2] = color.b;\n                    colorArray[v2offset + 2] = color.b;\n                    colorArray[v3offset + 2] = color.b;\n                    colorArray[v4offset + 2] = color.b;\n                    nx1 = e[0] * normals[v1].x + e[3] * normals[v1].y + e[6] * normals[v1].z;\n                    nx2 = e[0] * normals[v2].x + e[3] * normals[v2].y + e[6] * normals[v2].z;\n                    nx3 = e[0] * normals[v3].x + e[3] * normals[v3].y + e[6] * normals[v3].z;\n                    nx4 = e[0] * normals[v4].x + e[3] * normals[v4].y + e[6] * normals[v4].z;\n                    ny1 = e[1] * normals[v1].x + e[4] * normals[v1].y + e[7] * normals[v1].z;\n                    ny2 = e[1] * normals[v2].x + e[4] * normals[v2].y + e[7] * normals[v2].z;\n                    ny3 = e[1] * normals[v3].x + e[4] * normals[v3].y + e[7] * normals[v3].z;\n                    ny4 = e[1] * normals[v4].x + e[4] * normals[v4].y + e[7] * normals[v4].z;\n                    nz1 = e[5] * normals[v1].y + e[8] * normals[v1].z;\n                    nz2 = e[5] * normals[v2].y + e[8] * normals[v2].z;\n                    nz3 = e[5] * normals[v3].y + e[8] * normals[v3].z;\n                    nz4 = e[5] * normals[v4].y + e[8] * normals[v4].z;\n                    // if (Math.abs(vobj.sphereVertices[v1].y) === radius) {\n                    if (y === 0) { //to center circle\n                        // face = [v1, v3, v4];\n                        // norm = [n1, n3, n4];\n                        normalArray[v1offset] = nx1;\n                        normalArray[v3offset] = nx3;\n                        normalArray[v4offset] = nx4;\n                        normalArray[v1offset + 1] = ny1;\n                        normalArray[v3offset + 1] = ny3;\n                        normalArray[v4offset + 1] = ny4;\n                        normalArray[v1offset + 2] = nz1;\n                        normalArray[v3offset + 2] = nz3;\n                        normalArray[v4offset + 2] = nz4;\n                        faceArray[faceoffset] = v1 + start;\n                        faceArray[faceoffset + 1] = v3 + start;\n                        faceArray[faceoffset + 2] = v4 + start;\n                        geoGroup.faceidx += 3;\n                    }\n                    // else if (Math.abs(vobj.sphereVertices[v3].y) === radius)\n                    // {\n                    else if (y === yend - 1) { //from end center circle\n                        // face = [v1, v2, v3];\n                        // norm = [n1, n2, n3];\n                        normalArray[v1offset] = nx1;\n                        normalArray[v2offset] = nx2;\n                        normalArray[v3offset] = nx3;\n                        normalArray[v1offset + 1] = ny1;\n                        normalArray[v2offset + 1] = ny2;\n                        normalArray[v3offset + 1] = ny3;\n                        normalArray[v1offset + 2] = nz1;\n                        normalArray[v2offset + 2] = nz2;\n                        normalArray[v3offset + 2] = nz3;\n                        faceArray[faceoffset] = v1 + start;\n                        faceArray[faceoffset + 1] = v2 + start;\n                        faceArray[faceoffset + 2] = v3 + start;\n                        geoGroup.faceidx += 3;\n                    }\n                    else { // the rest of the circles\n                        // face = [v1, v2, v3, v4];\n                        // norm = [n1, n2, n3, n4];\n                        normalArray[v1offset] = nx1;\n                        normalArray[v2offset] = nx2;\n                        normalArray[v4offset] = nx4;\n                        normalArray[v1offset + 1] = ny1;\n                        normalArray[v2offset + 1] = ny2;\n                        normalArray[v4offset + 1] = ny4;\n                        normalArray[v1offset + 2] = nz1;\n                        normalArray[v2offset + 2] = nz2;\n                        normalArray[v4offset + 2] = nz4;\n                        normalArray[v2offset] = nx2;\n                        normalArray[v3offset] = nx3;\n                        normalArray[v4offset] = nx4;\n                        normalArray[v2offset + 1] = ny2;\n                        normalArray[v3offset + 1] = ny3;\n                        normalArray[v4offset + 1] = ny4;\n                        normalArray[v2offset + 2] = nz2;\n                        normalArray[v3offset + 2] = nz3;\n                        normalArray[v4offset + 2] = nz4;\n                        faceArray[faceoffset] = v1 + start;\n                        faceArray[faceoffset + 1] = v2 + start;\n                        faceArray[faceoffset + 2] = v4 + start;\n                        faceArray[faceoffset + 3] = v2 + start;\n                        faceArray[faceoffset + 4] = v3 + start;\n                        faceArray[faceoffset + 5] = v4 + start;\n                        geoGroup.faceidx += 6;\n                    }\n                }\n            }\n        }\n        geoGroup.vertices += n_verts;\n    }\n    GLDraw.drawCylinder = drawCylinder;\n    ;\n    /** Create a cone\n     * @memberof GLDraw\n     * @param {Geometry}\n     *            geo\n     * @param {Point}\n     *            from\n     * @param {Point}\n     *            to\n     * @param {number}\n     *            radius\n     * @param {Color}\n     *            color\n     *            */\n    function drawCone(geo, from, to, radius, color) {\n        if (!from || !to)\n            return;\n        // TODO: check if from and to do not contain x,y,z and if  so generate a center based on the passed selections\n        color = color || { r: 0, g: 0, b: 0 };\n        let ndir = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(to.x - from.x, to.y - from.y, to.z - from.z);\n        var e = getRotationMatrix(ndir.x, ndir.y, ndir.z);\n        ndir = ndir.normalize();\n        // n vertices around bottom plust the two points\n        var n = cylVertexCache.basisVectors.length;\n        var basis = cylVertexCache.basisVectors;\n        var n_verts = n + 2;\n        //setup geo structures\n        var geoGroup = geo.updateGeoGroup(n_verts);\n        var start = geoGroup.vertices;\n        var offset, faceoffset;\n        var i, x, y, z;\n        var vertexArray = geoGroup.vertexArray;\n        var normalArray = geoGroup.normalArray;\n        var colorArray = geoGroup.colorArray;\n        var faceArray = geoGroup.faceArray;\n        offset = start * 3;\n        //base point first vertex\n        vertexArray[offset] = from.x;\n        vertexArray[offset + 1] = from.y;\n        vertexArray[offset + 2] = from.z;\n        normalArray[offset] = -ndir.x;\n        normalArray[offset + 1] = -ndir.y;\n        normalArray[offset + 2] = -ndir.z;\n        colorArray[offset] = color.r;\n        colorArray[offset + 1] = color.g;\n        colorArray[offset + 2] = color.b;\n        //second vertex top\n        vertexArray[offset + 3] = to.x;\n        vertexArray[offset + 4] = to.y;\n        vertexArray[offset + 5] = to.z;\n        normalArray[offset + 3] = ndir.x;\n        normalArray[offset + 4] = ndir.y;\n        normalArray[offset + 5] = ndir.z;\n        colorArray[offset + 3] = color.r;\n        colorArray[offset + 4] = color.g;\n        colorArray[offset + 5] = color.b;\n        offset += 6;\n        // add circle vertices\n        for (i = 0; i < n; ++i) {\n            var vec = basis[i].clone();\n            vec.multiplyScalar(radius);\n            x = e[0] * vec.x + e[3] * vec.y + e[6] * vec.z;\n            y = e[1] * vec.x + e[4] * vec.y + e[7] * vec.z;\n            z = e[5] * vec.y + e[8] * vec.z;\n            // from\n            vertexArray[offset] = x + from.x;\n            vertexArray[offset + 1] = y + from.y;\n            vertexArray[offset + 2] = z + from.z;\n            // normals\n            normalArray[offset] = x;\n            normalArray[offset + 1] = y;\n            normalArray[offset + 2] = z;\n            // colors\n            colorArray[offset] = color.r;\n            colorArray[offset + 1] = color.g;\n            colorArray[offset + 2] = color.b;\n            offset += 3;\n        }\n        geoGroup.vertices += (n + 2);\n        //faces\n        faceoffset = geoGroup.faceidx;\n        for (i = 0; i < n; i++) {\n            //two neighboring circle vertices\n            var v1 = start + 2 + i;\n            var v2 = start + 2 + ((i + 1) % n);\n            faceArray[faceoffset] = v1;\n            faceArray[faceoffset + 1] = v2;\n            faceArray[faceoffset + 2] = start;\n            faceoffset += 3;\n            faceArray[faceoffset] = v1;\n            faceArray[faceoffset + 1] = v2;\n            faceArray[faceoffset + 2] = start + 1;\n            faceoffset += 3;\n        }\n        geoGroup.faceidx += 6 * n;\n    }\n    GLDraw.drawCone = drawCone;\n    ;\n    // Sphere component sphereVertexCache\n    class SphereVertexCache {\n        constructor() {\n            this.cache = new Map(); //sphereQuality then radius\n        }\n        getVerticesForRadius(radius, sphereQuality) {\n            sphereQuality = sphereQuality || 2;\n            if (!this.cache.has(sphereQuality)) {\n                this.cache.set(sphereQuality, new Map());\n            }\n            let radiusCache = this.cache.get(sphereQuality);\n            if (radiusCache.has(radius))\n                return radiusCache.get(radius);\n            var obj = {\n                vertices: [],\n                verticesRows: [],\n                normals: []\n            };\n            // scale quality with radius heuristically\n            var widthSegments = 16 * sphereQuality;\n            var heightSegments = 10 * sphereQuality;\n            if (radius < 1) {\n                widthSegments = 10 * sphereQuality;\n                heightSegments = 8 * sphereQuality;\n            }\n            var phiStart = 0;\n            var phiLength = Math.PI * 2;\n            var thetaStart = 0;\n            var thetaLength = Math.PI;\n            var x, y;\n            for (y = 0; y <= heightSegments; y++) {\n                let verticesRow = [];\n                for (x = 0; x <= widthSegments; x++) {\n                    let u = x / widthSegments;\n                    let v = y / heightSegments;\n                    let vx = -radius * Math.cos(phiStart + u * phiLength) *\n                        Math.sin(thetaStart + v * thetaLength);\n                    let vy = radius * Math.cos(thetaStart + v * thetaLength);\n                    let vz = radius * Math.sin(phiStart + u * phiLength) *\n                        Math.sin(thetaStart + v * thetaLength);\n                    var n = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(vx, vy, vz);\n                    n.normalize();\n                    obj.vertices.push({ x: vx, y: vy, z: vz });\n                    obj.normals.push(n);\n                    verticesRow.push(obj.vertices.length - 1);\n                }\n                obj.verticesRows.push(verticesRow);\n            }\n            radiusCache.set(radius, obj);\n            return obj;\n        }\n    }\n    ;\n    var sphereVertexCache = new SphereVertexCache();\n    /** Create a sphere.\n     * @memberof GLDraw\n     * @param {Geometry}\n     *            geo\n     * @param {Point}\n     *            pos\n     * @param {number}\n     *            radius\n     * @param {Color}\n     *            color\n     * @param {number}\n     *            sphereQuality - Quality of sphere (default 2, higher increases number of triangles)\n     */\n    function drawSphere(geo, pos, radius, color, sphereQuality) {\n        var vobj = sphereVertexCache.getVerticesForRadius(radius, sphereQuality);\n        var vertices = vobj.vertices;\n        var normals = vobj.normals;\n        var geoGroup = geo.updateGeoGroup(vertices.length);\n        var start = geoGroup.vertices;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        var faceArray = geoGroup.faceArray;\n        var lineArray = geoGroup.lineArray;\n        var normalArray = geoGroup.normalArray;\n        for (let i = 0, il = vertices.length; i < il; ++i) {\n            let offset = 3 * (start + i);\n            let v = vertices[i];\n            vertexArray[offset] = (v.x + pos.x);\n            vertexArray[offset + 1] = (v.y + pos.y);\n            vertexArray[offset + 2] = (v.z + pos.z);\n            colorArray[offset] = color.r;\n            colorArray[offset + 1] = color.g;\n            colorArray[offset + 2] = color.b;\n        }\n        geoGroup.vertices += vertices.length;\n        let verticesRows = vobj.verticesRows;\n        let h = verticesRows.length - 1;\n        for (let y = 0; y < h; y++) {\n            let w = verticesRows[y].length - 1;\n            for (let x = 0; x < w; x++) {\n                let faceoffset = geoGroup.faceidx, lineoffset = geoGroup.lineidx;\n                let v1 = verticesRows[y][x + 1] + start, v1offset = v1 * 3;\n                let v2 = verticesRows[y][x] + start, v2offset = v2 * 3;\n                let v3 = verticesRows[y + 1][x] + start, v3offset = v3 * 3;\n                let v4 = verticesRows[y + 1][x + 1] + start, v4offset = v4 * 3;\n                let n1 = normals[v1 - start];\n                let n2 = normals[v2 - start];\n                let n3 = normals[v3 - start];\n                let n4 = normals[v4 - start];\n                if (Math.abs(vertices[v1 - start].y) === radius) {\n                    // face = [v1, v3, v4];\n                    // norm = [n1, n3, n4];\n                    normalArray[v1offset] = n1.x;\n                    normalArray[v3offset] = n3.x;\n                    normalArray[v4offset] = n4.x;\n                    normalArray[v1offset + 1] = n1.y;\n                    normalArray[v3offset + 1] = n3.y;\n                    normalArray[v4offset + 1] = n4.y;\n                    normalArray[v1offset + 2] = n1.z;\n                    normalArray[v3offset + 2] = n3.z;\n                    normalArray[v4offset + 2] = n4.z;\n                    faceArray[faceoffset] = v1;\n                    faceArray[faceoffset + 1] = v3;\n                    faceArray[faceoffset + 2] = v4;\n                    lineArray[lineoffset] = v1;\n                    lineArray[lineoffset + 1] = v3;\n                    lineArray[lineoffset + 2] = v1;\n                    lineArray[lineoffset + 3] = v4;\n                    lineArray[lineoffset + 4] = v3;\n                    lineArray[lineoffset + 5] = v4;\n                    geoGroup.faceidx += 3;\n                    geoGroup.lineidx += 6;\n                }\n                else if (Math.abs(vertices[v3 - start].y) === radius) {\n                    // face = [v1, v2, v3];\n                    // norm = [n1, n2, n3];\n                    normalArray[v1offset] = n1.x;\n                    normalArray[v2offset] = n2.x;\n                    normalArray[v3offset] = n3.x;\n                    normalArray[v1offset + 1] = n1.y;\n                    normalArray[v2offset + 1] = n2.y;\n                    normalArray[v3offset + 1] = n3.y;\n                    normalArray[v1offset + 2] = n1.z;\n                    normalArray[v2offset + 2] = n2.z;\n                    normalArray[v3offset + 2] = n3.z;\n                    faceArray[faceoffset] = v1;\n                    faceArray[faceoffset + 1] = v2;\n                    faceArray[faceoffset + 2] = v3;\n                    lineArray[lineoffset] = v1;\n                    lineArray[lineoffset + 1] = v2;\n                    lineArray[lineoffset + 2] = v1;\n                    lineArray[lineoffset + 3] = v3;\n                    lineArray[lineoffset + 4] = v2;\n                    lineArray[lineoffset + 5] = v3;\n                    geoGroup.faceidx += 3;\n                    geoGroup.lineidx += 6;\n                }\n                else {\n                    // face = [v1, v2, v3, v4];\n                    // norm = [n1, n2, n3, n4];\n                    normalArray[v1offset] = n1.x;\n                    normalArray[v2offset] = n2.x;\n                    normalArray[v4offset] = n4.x;\n                    normalArray[v1offset + 1] = n1.y;\n                    normalArray[v2offset + 1] = n2.y;\n                    normalArray[v4offset + 1] = n4.y;\n                    normalArray[v1offset + 2] = n1.z;\n                    normalArray[v2offset + 2] = n2.z;\n                    normalArray[v4offset + 2] = n4.z;\n                    normalArray[v2offset] = n2.x;\n                    normalArray[v3offset] = n3.x;\n                    normalArray[v4offset] = n4.x;\n                    normalArray[v2offset + 1] = n2.y;\n                    normalArray[v3offset + 1] = n3.y;\n                    normalArray[v4offset + 1] = n4.y;\n                    normalArray[v2offset + 2] = n2.z;\n                    normalArray[v3offset + 2] = n3.z;\n                    normalArray[v4offset + 2] = n4.z;\n                    faceArray[faceoffset] = v1;\n                    faceArray[faceoffset + 1] = v2;\n                    faceArray[faceoffset + 2] = v4;\n                    faceArray[faceoffset + 3] = v2;\n                    faceArray[faceoffset + 4] = v3;\n                    faceArray[faceoffset + 5] = v4;\n                    lineArray[lineoffset] = v1;\n                    lineArray[lineoffset + 1] = v2;\n                    lineArray[lineoffset + 2] = v1;\n                    lineArray[lineoffset + 3] = v4;\n                    lineArray[lineoffset + 4] = v2;\n                    lineArray[lineoffset + 5] = v3;\n                    lineArray[lineoffset + 6] = v3;\n                    lineArray[lineoffset + 7] = v4;\n                    geoGroup.faceidx += 6;\n                    geoGroup.lineidx += 8;\n                }\n            }\n        }\n    }\n    GLDraw.drawSphere = drawSphere;\n    ;\n})(GLDraw || (GLDraw = {}));\n\n\n//# sourceURL=webpack://ThreeDmol/./src/GLDraw.ts?");

/***/ }),

/***/ "./src/GLModel.ts":
/*!************************!*\
  !*** ./src/GLModel.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLModel: () => (/* binding */ GLModel)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGL/shapes */ \"./src/WebGL/shapes/index.ts\");\n/* harmony import */ var _WebGL_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGL/math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _GLDraw__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GLDraw */ \"./src/GLDraw.ts\");\n/* harmony import */ var _glcartoon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./glcartoon */ \"./src/glcartoon.ts\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.ts\");\n/* harmony import */ var _Gradient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Gradient */ \"./src/Gradient.ts\");\n/* harmony import */ var _parsers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parsers */ \"./src/parsers/index.ts\");\n/* harmony import */ var netcdfjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! netcdfjs */ \"./node_modules/netcdfjs/lib-esm/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! pako */ \"./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _parsers_utils_assignBonds__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parsers/utils/assignBonds */ \"./src/parsers/utils/assignBonds.ts\");\n// A model is a collection of related atoms.  Bonds are only allowed between\n//atoms in the same model.  An atom is uniquely specified by its model id and\n//its serial number.\n//A glmodel knows how to apply the styles on each atom to create a gl object\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction inflateString(str) {\n    let data;\n    if (typeof str === 'string') {\n        const encoder = new TextEncoder();\n        data = encoder.encode(str);\n    }\n    else {\n        data = new Uint8Array(str);\n    }\n    const inflatedData = (0,pako__WEBPACK_IMPORTED_MODULE_10__.inflate)(data, {\n        to: 'string'\n    });\n    return inflatedData;\n}\n/**\n * GLModel represents a group of related atoms\n * @class\n */\nclass GLModel {\n    // class functions\n    // return true if a and b represent the same style\n    static sameObj(a, b) {\n        if (a && b)\n            return JSON.stringify(a) == JSON.stringify(b);\n        else\n            return a == b;\n    }\n    ;\n    constructor(mid, options) {\n        // private variables\n        this.atoms = [];\n        this.frames = [];\n        this.box = null;\n        this.atomdfs = null; //depth first search over connected components\n        this.id = 0;\n        this.hidden = false;\n        this.molObj = null;\n        this.renderedMolObj = null;\n        this.lastColors = null;\n        this.modelData = {};\n        this.modelDatas = null; //if there is different modelData per frame\n        this.idMatrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\n        this.dontDuplicateAtoms = true;\n        this.defaultColor = _colors__WEBPACK_IMPORTED_MODULE_3__.elementColors.defaultColor;\n        // bonds as cylinders\n        this.defaultStickRadius = 0.25;\n        this.options = options || {};\n        this.ElementColors = (this.options.defaultcolors) ? this.options.defaultcolors : _colors__WEBPACK_IMPORTED_MODULE_3__.elementColors.defaultColors;\n        this.defaultSphereRadius = (this.options.defaultSphereRadius) ? this.options.defaultSphereRadius : 1.5;\n        this.defaultCartoonQuality = (this.options.cartoonQuality) ? this.options.cartoonQuality : 10;\n        this.id = mid;\n    }\n    // return proper radius for atom given style\n    /**\n     *\n     * @param {AtomSpec} atom\n     * @param {atomstyle} style\n     * @return {number}\n     *\n     */\n    getRadiusFromStyle(atom, style) {\n        var r = this.defaultSphereRadius;\n        if (typeof (style.radius) != \"undefined\")\n            r = style.radius;\n        else if (GLModel.vdwRadii[atom.elem])\n            r = GLModel.vdwRadii[atom.elem];\n        else if (atom.elem.length > 1) { //see if adjusting case helps\n            let e = atom.elem;\n            e = e[0].toUpperCase() + e[1].toLowerCase();\n            if (GLModel.vdwRadii[e])\n                r = GLModel.vdwRadii[e];\n        }\n        if (typeof (style.scale) != \"undefined\")\n            r *= style.scale;\n        return r;\n    }\n    ;\n    // cross drawing\n    /**\n     *\n     * @param {AtomSpec} atom\n     * @param {Record<number, Geometry>} geos\n     */\n    drawAtomCross(atom, geos) {\n        if (!atom.style.cross)\n            return;\n        var style = atom.style.cross;\n        if (style.hidden)\n            return;\n        var linewidth = (style.linewidth || GLModel.defaultlineWidth);\n        if (!geos[linewidth])\n            geos[linewidth] = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry();\n        var geoGroup = geos[linewidth].updateGeoGroup(6);\n        var delta = this.getRadiusFromStyle(atom, style);\n        var points = [[delta, 0, 0], [-delta, 0, 0], [0, delta, 0],\n            [0, -delta, 0], [0, 0, delta], [0, 0, -delta]];\n        var clickable = atom.clickable || atom.hoverable;\n        if (clickable && atom.intersectionShape === undefined)\n            atom.intersectionShape = { sphere: [], cylinder: [], line: [] };\n        var c = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        for (var j = 0; j < 6; j++) {\n            var offset = geoGroup.vertices * 3;\n            geoGroup.vertices++;\n            vertexArray[offset] = atom.x + points[j][0];\n            vertexArray[offset + 1] = atom.y + points[j][1];\n            vertexArray[offset + 2] = atom.z + points[j][2];\n            colorArray[offset] = c.r;\n            colorArray[offset + 1] = c.g;\n            colorArray[offset + 2] = c.b;\n            if (clickable) {\n                var point = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(points[j][0], points[j][1], points[j][2]);\n                //decrease cross size for selection to prevent misselection from atom overlap\n                point.multiplyScalar(0.1);\n                point.set(point.x + atom.x, point.y + atom.y, point.z + atom.z);\n                atom.intersectionShape.line.push(point);\n            }\n        }\n    }\n    ;\n    getGoodCross(atom, atom2, p1, dir) {\n        // get vector 2 different neighboring atom\n        //find most divergent neighbor\n        var bestv = null;\n        var bestlen = -1;\n        for (var j = 0, n = atom.bonds.length; j < n; j++) {\n            if (atom.bonds[j] != atom2.index) {\n                let j2 = atom.bonds[j];\n                let atom3 = this.atoms[j2];\n                let p3 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom3.x, atom3.y, atom3.z);\n                let dir2 = p3.clone();\n                dir2.sub(p1);\n                let v = dir2.clone();\n                v.cross(dir);\n                var l = v.lengthSq();\n                if (l > bestlen) {\n                    bestlen = l;\n                    bestv = v;\n                    if (bestlen > 0.1) {\n                        return bestv;\n                    }\n                }\n            }\n        }\n        return bestv;\n    }\n    ;\n    //from atom, return a normalized vector v that is orthogonal and along which\n    //it is appropraite to draw multiple bonds\n    getSideBondV(atom, atom2, i) {\n        var i2, j2, atom3, p3, dir2;\n        var p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);\n        var p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom2.x, atom2.y, atom2.z);\n        var dir = p2.clone();\n        var v = null;\n        dir.sub(p1);\n        if (atom.bonds.length === 1) {\n            if (atom2.bonds.length === 1) {\n                v = dir.clone();\n                if (Math.abs(v.x) > 0.0001)\n                    v.y += 1;\n                else\n                    v.x += 1;\n            }\n            else {\n                i2 = (i + 1) % atom2.bonds.length;\n                j2 = atom2.bonds[i2];\n                atom3 = this.atoms[j2];\n                if (atom3.index == atom.index) { // get distinct atom\n                    i2 = (i2 + 1) % atom2.bonds.length;\n                    j2 = atom2.bonds[i2];\n                    atom3 = this.atoms[j2];\n                }\n                p3 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom3.x, atom3.y, atom3.z);\n                dir2 = p3.clone();\n                dir2.sub(p1);\n                v = dir2.clone();\n                v.cross(dir);\n            }\n        }\n        else {\n            v = this.getGoodCross(atom, atom2, p1, dir);\n            if (v.lengthSq() < 0.01) {\n                var v2 = this.getGoodCross(atom2, atom, p1, dir);\n                if (v2 != null)\n                    v = v2; //can be null if no other neighbors\n            }\n        }\n        // especially for C#C (triple bond) dir and dir2\n        // may be opposites resulting in a zero v\n        if (v.lengthSq() < 0.01) {\n            v = dir.clone();\n            if (Math.abs(v.x) > 0.0001)\n                v.y += 1;\n            else\n                v.x += 1;\n        }\n        v.cross(dir);\n        v.normalize();\n        return v;\n    }\n    ;\n    addLine(vertexArray, colorArray, offset, p1, p2, c1) {\n        //make line from p1 to p2, does not incremeant counts\n        vertexArray[offset] = p1.x;\n        vertexArray[offset + 1] = p1.y;\n        vertexArray[offset + 2] = p1.z;\n        colorArray[offset] = c1.r;\n        colorArray[offset + 1] = c1.g;\n        colorArray[offset + 2] = c1.b;\n        vertexArray[offset + 3] = p2.x;\n        vertexArray[offset + 4] = p2.y;\n        vertexArray[offset + 5] = p2.z;\n        colorArray[offset + 3] = c1.r;\n        colorArray[offset + 4] = c1.g;\n        colorArray[offset + 5] = c1.b;\n    }\n    ;\n    // bonds - both atoms must match bond style\n    // standardize on only drawing for lowest to highest\n    /**\n     *\n     * @param {AtomSpec}\n     *            atom\n     * @param {AtomSpec[]} atoms\n     * @param {Record<number,Geometry>} geos\n     */\n    drawBondLines(atom, atoms, geos) {\n        if (!atom.style.line)\n            return;\n        var style = atom.style.line;\n        if (style.hidden)\n            return;\n        var p1a, p1b, p2a, p2b;\n        // have a separate geometry for each linewidth\n        var linewidth = (style.linewidth || GLModel.defaultlineWidth);\n        if (!geos[linewidth])\n            geos[linewidth] = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry();\n        /** @type {geometryGroup} */\n        var geoGroup = geos[linewidth].updateGeoGroup(6 * atom.bonds.length); //reserve enough space even for triple bonds\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        for (var i = 0; i < atom.bonds.length; i++) {\n            var j = atom.bonds[i]; // our neighbor\n            var atom2 = atoms[j];\n            if (!atom2.style.line)\n                continue; // don't sweat the details\n            if (atom.index >= atom2.index) // only draw if less, this way we can do multi bonds correctly\n                continue;\n            var p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);\n            var p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom2.x, atom2.y, atom2.z);\n            var mp = p1.clone().add(p2).multiplyScalar(0.5);\n            var singleBond = false;\n            var atomneedsi = atom.clickable || atom.hoverable;\n            var atom2needsi = atom2.clickable || atom2.hoverable;\n            if (atomneedsi || atom2needsi) {\n                if (atomneedsi) {\n                    if (atom.intersectionShape === undefined)\n                        atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n                    atom.intersectionShape.line.push(p1);\n                    atom.intersectionShape.line.push(mp);\n                }\n                if (atom2needsi) {\n                    if (atom2.intersectionShape === undefined)\n                        atom2.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n                    atom2.intersectionShape.line.push(mp);\n                    atom2.intersectionShape.line.push(p2);\n                }\n            }\n            var c1 = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, atom.style.line);\n            var c2 = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom2, atom2.style.line);\n            if (atom.bondStyles && atom.bondStyles[i]) {\n                var bstyle = atom.bondStyles[i];\n                if (!bstyle.iswire) {\n                    continue;\n                }\n                if (bstyle.singleBond)\n                    singleBond = true;\n                if (typeof (bstyle.color1) != \"undefined\") {\n                    c1 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(bstyle.color1);\n                }\n                if (typeof (bstyle.color2) != \"undefined\") {\n                    c2 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(bstyle.color2);\n                }\n            }\n            var offset = geoGroup.vertices * 3;\n            var mpa, mpb;\n            if (atom.bondOrder[i] > 1 && atom.bondOrder[i] < 4 && !singleBond) {\n                var v = this.getSideBondV(atom, atom2, i);\n                var dir = p2.clone();\n                dir.sub(p1);\n                if (atom.bondOrder[i] == 2) { //double\n                    v.multiplyScalar(0.1);\n                    p1a = p1.clone();\n                    p1a.add(v);\n                    p1b = p1.clone();\n                    p1b.sub(v);\n                    p2a = p1a.clone();\n                    p2a.add(dir);\n                    p2b = p1b.clone();\n                    p2b.add(dir);\n                    if (c1 == c2) {\n                        geoGroup.vertices += 4;\n                        this.addLine(vertexArray, colorArray, offset, p1a, p2a, c1);\n                        this.addLine(vertexArray, colorArray, offset + 6, p1b, p2b, c1);\n                    }\n                    else {\n                        geoGroup.vertices += 8;\n                        dir.multiplyScalar(0.5);\n                        mpa = p1a.clone();\n                        mpa.add(dir);\n                        mpb = p1b.clone();\n                        mpb.add(dir);\n                        this.addLine(vertexArray, colorArray, offset, p1a, mpa, c1);\n                        this.addLine(vertexArray, colorArray, offset + 6, mpa, p2a, c2);\n                        this.addLine(vertexArray, colorArray, offset + 12, p1b, mpb, c1);\n                        this.addLine(vertexArray, colorArray, offset + 18, mpb, p2b, c2);\n                    }\n                }\n                else if (atom.bondOrder[i] == 3) { //triple\n                    v.multiplyScalar(0.1);\n                    p1a = p1.clone();\n                    p1a.add(v);\n                    p1b = p1.clone();\n                    p1b.sub(v);\n                    p2a = p1a.clone();\n                    p2a.add(dir);\n                    p2b = p1b.clone();\n                    p2b.add(dir);\n                    if (c1 == c2) {\n                        geoGroup.vertices += 6;\n                        this.addLine(vertexArray, colorArray, offset, p1, p2, c1);\n                        this.addLine(vertexArray, colorArray, offset + 6, p1a, p2a, c1);\n                        this.addLine(vertexArray, colorArray, offset + 12, p1b, p2b, c1);\n                    }\n                    else {\n                        geoGroup.vertices += 12;\n                        dir.multiplyScalar(0.5);\n                        mpa = p1a.clone();\n                        mpa.add(dir);\n                        mpb = p1b.clone();\n                        mpb.add(dir);\n                        this.addLine(vertexArray, colorArray, offset, p1, mp, c1);\n                        this.addLine(vertexArray, colorArray, offset + 6, mp, p2, c2);\n                        this.addLine(vertexArray, colorArray, offset + 12, p1a, mpa, c1);\n                        this.addLine(vertexArray, colorArray, offset + 18, mpa, p2a, c2);\n                        this.addLine(vertexArray, colorArray, offset + 24, p1b, mpb, c1);\n                        this.addLine(vertexArray, colorArray, offset + 30, mpb, p2b, c2);\n                    }\n                }\n            }\n            else { //single bond\n                if (c1 == c2) {\n                    geoGroup.vertices += 2;\n                    this.addLine(vertexArray, colorArray, offset, p1, p2, c1);\n                }\n                else {\n                    geoGroup.vertices += 4;\n                    this.addLine(vertexArray, colorArray, offset, p1, mp, c1);\n                    this.addLine(vertexArray, colorArray, offset + 6, mp, p2, c2);\n                }\n            }\n        }\n    }\n    ;\n    //sphere drawing\n    //See also: drawCylinder\n    /**\n     *\n     * @param {AtomSpec} atom\n     * @param {Geometry} geo\n     */\n    drawAtomSphere(atom, geo) {\n        if (!atom.style.sphere)\n            return;\n        var style = atom.style.sphere;\n        if (style.hidden)\n            return;\n        var C = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);\n        var radius = this.getRadiusFromStyle(atom, style);\n        if ((atom.clickable === true || atom.hoverable) && (atom.intersectionShape !== undefined)) {\n            var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);\n            atom.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, radius));\n        }\n        _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawSphere(geo, atom, radius, C);\n    }\n    ;\n    /** Register atom shaped click handlers */\n    drawAtomClickSphere(atom) {\n        if (!atom.style.clicksphere)\n            return;\n        var style = atom.style.clicksphere;\n        if (style.hidden)\n            return;\n        var radius = this.getRadiusFromStyle(atom, style);\n        if ((atom.clickable === true || atom.hoverable) && (atom.intersectionShape !== undefined)) {\n            var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);\n            atom.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, radius));\n        }\n    }\n    ;\n    drawAtomInstanced(atom, geo) {\n        if (!atom.style.sphere)\n            return;\n        var style = atom.style.sphere;\n        if (style.hidden)\n            return;\n        var radius = this.getRadiusFromStyle(atom, style);\n        var C = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);\n        var geoGroup = geo.updateGeoGroup(1);\n        var startv = geoGroup.vertices;\n        var start = startv * 3;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        var radiusArray = geoGroup.radiusArray;\n        vertexArray[start] = atom.x;\n        vertexArray[start + 1] = atom.y;\n        vertexArray[start + 2] = atom.z;\n        colorArray[start] = C.r;\n        colorArray[start + 1] = C.g;\n        colorArray[start + 2] = C.b;\n        radiusArray[startv] = radius;\n        if ((atom.clickable === true || atom.hoverable) && (atom.intersectionShape !== undefined)) {\n            var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);\n            atom.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, radius));\n        }\n        geoGroup.vertices += 1;\n    }\n    ;\n    drawSphereImposter(geo, center, radius, C) {\n        //create flat square\n        var geoGroup = geo.updateGeoGroup(4);\n        var i;\n        var startv = geoGroup.vertices;\n        var start = startv * 3;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        //use center point for each vertex\n        for (i = 0; i < 4; i++) {\n            vertexArray[start + 3 * i] = center.x;\n            vertexArray[start + 3 * i + 1] = center.y;\n            vertexArray[start + 3 * i + 2] = center.z;\n        }\n        //same colors for all 4 vertices\n        var normalArray = geoGroup.normalArray;\n        for (i = 0; i < 4; i++) {\n            colorArray[start + 3 * i] = C.r;\n            colorArray[start + 3 * i + 1] = C.g;\n            colorArray[start + 3 * i + 2] = C.b;\n        }\n        normalArray[start + 0] = -radius;\n        normalArray[start + 1] = radius;\n        normalArray[start + 2] = 0;\n        normalArray[start + 3] = -radius;\n        normalArray[start + 4] = -radius;\n        normalArray[start + 5] = 0;\n        normalArray[start + 6] = radius;\n        normalArray[start + 7] = -radius;\n        normalArray[start + 8] = 0;\n        normalArray[start + 9] = radius;\n        normalArray[start + 10] = radius;\n        normalArray[start + 11] = 0;\n        geoGroup.vertices += 4;\n        //two faces\n        var faceArray = geoGroup.faceArray;\n        var faceoffset = geoGroup.faceidx; //not number faces, but index\n        faceArray[faceoffset + 0] = startv;\n        faceArray[faceoffset + 1] = startv + 1;\n        faceArray[faceoffset + 2] = startv + 2;\n        faceArray[faceoffset + 3] = startv + 2;\n        faceArray[faceoffset + 4] = startv + 3;\n        faceArray[faceoffset + 5] = startv;\n        geoGroup.faceidx += 6;\n    }\n    ;\n    //dkoes -  code for sphere imposters\n    drawAtomImposter(atom, geo) {\n        if (!atom.style.sphere)\n            return;\n        var style = atom.style.sphere;\n        if (style.hidden)\n            return;\n        var radius = this.getRadiusFromStyle(atom, style);\n        var C = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);\n        if ((atom.clickable === true || atom.hoverable) && (atom.intersectionShape !== undefined)) {\n            var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);\n            atom.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, radius));\n        }\n        this.drawSphereImposter(geo, atom, radius, C);\n    }\n    ;\n    calculateDashes(from, to, radius, dashLength, gapLength) {\n        // Calculate the length of a cylinder defined by two points 'from' and 'to'.\n        var cylinderLength = Math.sqrt(Math.pow((from.x - to.x), 2) +\n            Math.pow((from.y - to.y), 2) +\n            Math.pow((from.z - to.z), 2));\n        // Ensure non-negative values for radius, dashLength, and gapLength.\n        // Adjust gapLength to include the radius of the cylinder.\n        radius = Math.max(radius, 0);\n        gapLength = Math.max(gapLength, 0) + 2 * radius;\n        dashLength = Math.max(dashLength, 0.001);\n        // Handle cases where the combined length of dash and gap exceeds the cylinder's length.\n        // In such cases, use a single dash to represent the entire cylinder with no gaps.\n        if (dashLength + gapLength > cylinderLength) {\n            dashLength = cylinderLength;\n            gapLength = 0; // No gap as the dash fills the entire cylinder.\n        }\n        // Calculate the total number of dash-gap segments that can fit within the cylinder.\n        var totalSegments = Math.floor((cylinderLength - dashLength) / (dashLength + gapLength)) + 1;\n        // Compute the total length covered by dashes.\n        var totalDashLength = totalSegments * dashLength;\n        // Recalculate gap length to evenly distribute remaining space among gaps.\n        // This ensures dashes and gaps are evenly spaced within the cylinder.\n        gapLength = (cylinderLength - totalDashLength) / totalSegments;\n        var new_to;\n        var new_from = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z);\n        var gapVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((to.x - from.x) / (cylinderLength / gapLength), (to.y - from.y) / (cylinderLength / gapLength), (to.z - from.z) / (cylinderLength / gapLength));\n        var dashVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((to.x - from.x) / (cylinderLength / dashLength), (to.y - from.y) / (cylinderLength / dashLength), (to.z - from.z) / (cylinderLength / dashLength));\n        var segments = [];\n        for (var place = 0; place < totalSegments; place++) {\n            new_to = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(new_from.x + dashVector.x, new_from.y + dashVector.y, new_from.z + dashVector.z);\n            segments.push({ from: new_from, to: new_to });\n            new_from = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(new_to.x + gapVector.x, new_to.y + gapVector.y, new_to.z + gapVector.z);\n        }\n        return segments;\n    }\n    static drawStickImposter(geo, from, to, radius, color, fromCap = 0, toCap = 0) {\n        //we need the four corners - two have from coord, two have to coord, the normal\n        //is the opposing point, from which we can get the normal and length\n        //also need the radius\n        var geoGroup = geo.updateGeoGroup(4);\n        var startv = geoGroup.vertices;\n        var start = startv * 3;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        var radiusArray = geoGroup.radiusArray;\n        var normalArray = geoGroup.normalArray;\n        //encode extra bits of information in the color\n        var r = color.r;\n        var g = color.g;\n        var b = color.b;\n        var negateColor = function (c) {\n            //set sign bit\n            var n = -c;\n            if (n == 0)\n                n = -0.0001;\n            return n;\n        };\n        /* for sticks, always draw caps, but we could in theory set caps in color */\n        //4 vertices, distinguish between p1 and p2 with neg blue\n        var pos = start;\n        for (var i = 0; i < 4; i++) {\n            vertexArray[pos] = from.x;\n            normalArray[pos] = to.x;\n            colorArray[pos] = r;\n            pos++;\n            vertexArray[pos] = from.y;\n            normalArray[pos] = to.y;\n            colorArray[pos] = g;\n            pos++;\n            vertexArray[pos] = from.z;\n            normalArray[pos] = to.z;\n            if (i < 2)\n                colorArray[pos] = b;\n            else\n                colorArray[pos] = negateColor(b);\n            pos++;\n        }\n        geoGroup.vertices += 4;\n        radiusArray[startv] = -radius;\n        radiusArray[startv + 1] = radius;\n        radiusArray[startv + 2] = -radius;\n        radiusArray[startv + 3] = radius;\n        //two faces\n        var faceArray = geoGroup.faceArray;\n        var faceoffset = geoGroup.faceidx; //not number faces, but index\n        faceArray[faceoffset + 0] = startv;\n        faceArray[faceoffset + 1] = startv + 1;\n        faceArray[faceoffset + 2] = startv + 2;\n        faceArray[faceoffset + 3] = startv + 2;\n        faceArray[faceoffset + 4] = startv + 3;\n        faceArray[faceoffset + 5] = startv;\n        geoGroup.faceidx += 6;\n    }\n    ;\n    // draws cylinders and small spheres (at bond radius)\n    drawBondSticks(atom, atoms, geo) {\n        var _a, _b;\n        if (!atom.style.stick)\n            return;\n        var style = atom.style.stick;\n        if (style.hidden)\n            return;\n        var atomBondR = style.radius || this.defaultStickRadius;\n        var doubleBondScale = style.doubleBondScaling || 0.4;\n        var tripleBondScale = style.tripleBondScaling || 0.25;\n        var bondDashLength = ((_a = style.dashedBondConfig) === null || _a === void 0 ? void 0 : _a.dashLength) || 0.1;\n        var bondGapLength = ((_b = style.dashedBondConfig) === null || _b === void 0 ? void 0 : _b.gapLength) || 0.25;\n        var bondR = atomBondR;\n        var atomSingleBond = style.singleBonds || false;\n        var atomDashedBonds = style.dashedBonds || false;\n        var fromCap = 0, toCap = 0;\n        var atomneedsi, atom2needsi, i, singleBond, bstyle;\n        var cylinder1a, cylinder1b, cylinder1c, cylinder2a, cylinder2b, cylinder2c;\n        var C1 = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom, style);\n        var mp, mp2, mp3;\n        if (!atom.capDrawn && atom.bonds.length < 4)\n            fromCap = 2;\n        var selectCylDrawMethod = (bondOrder) => {\n            var drawMethod = geo.imposter ? GLModel.drawStickImposter : _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawCylinder;\n            if (!atomDashedBonds && bondOrder >= 1) {\n                return drawMethod;\n            }\n            // draw dashes\n            return (geo, from, to, radius, color, fromCap = 0, toCap = 0, dashLength = 0.1, gapLength = 0.25) => {\n                var segments = this.calculateDashes(from, to, radius, dashLength, gapLength);\n                segments.forEach(segment => {\n                    drawMethod(geo, segment.from, segment.to, radius, color, fromCap, toCap);\n                });\n            };\n        };\n        for (i = 0; i < atom.bonds.length; i++) {\n            var drawCyl = selectCylDrawMethod(atom.bondOrder[i]);\n            var j = atom.bonds[i]; // our neighbor\n            var atom2 = atoms[j]; //parsePDB, etc should only add defined bonds\n            mp = mp2 = mp3 = null;\n            if (atom.index < atom2.index) { // only draw if less, this\n                // lets us combine\n                // cylinders of the same\n                // color\n                var style2 = atom2.style;\n                if (!style2.stick || style2.stick.hidden)\n                    continue; // don't sweat the details\n                var C2 = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(atom2, style2.stick);\n                //support bond specific styles\n                bondR = atomBondR;\n                singleBond = atomSingleBond;\n                if (atom.bondStyles && atom.bondStyles[i]) {\n                    bstyle = atom.bondStyles[i];\n                    if (bstyle.iswire) {\n                        continue;\n                    }\n                    if (bstyle.radius)\n                        bondR = bstyle.radius;\n                    if (bstyle.singleBond)\n                        singleBond = true;\n                    if (typeof (bstyle.color1) != \"undefined\") {\n                        C1 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(bstyle.color1);\n                    }\n                    if (typeof (bstyle.color2) != \"undefined\") {\n                        C2 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(bstyle.color2);\n                    }\n                }\n                var p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom.x, atom.y, atom.z);\n                var p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(atom2.x, atom2.y, atom2.z);\n                // draw cylinders\n                if (atom.bondOrder[i] <= 1 || singleBond || atom.bondOrder[i] > 3) { //TODO: aromatics at 4\n                    if (atom.bondOrder[i] < 1)\n                        bondR *= atom.bondOrder[i];\n                    if (!atom2.capDrawn && atom2.bonds.length < 4)\n                        toCap = 2;\n                    if (C1 != C2) {\n                        mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1, p2)\n                            .multiplyScalar(0.5);\n                        drawCyl(geo, p1, mp, bondR, C1, fromCap, 0, bondDashLength, bondGapLength);\n                        drawCyl(geo, mp, p2, bondR, C2, 0, toCap, bondDashLength, bondGapLength);\n                    }\n                    else {\n                        drawCyl(geo, p1, p2, bondR, C1, fromCap, toCap, bondDashLength, bondGapLength);\n                    }\n                    atomneedsi = atom.clickable || atom.hoverable;\n                    atom2needsi = atom2.clickable || atom2.hoverable;\n                    if (atomneedsi || atom2needsi) {\n                        if (!mp)\n                            mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1, p2).multiplyScalar(0.5);\n                        if (atomneedsi) {\n                            var cylinder1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1, mp, bondR);\n                            var sphere1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(p1, bondR);\n                            atom.intersectionShape.cylinder.push(cylinder1);\n                            atom.intersectionShape.sphere.push(sphere1);\n                        }\n                        if (atom2needsi) {\n                            var cylinder2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2, mp, bondR);\n                            var sphere2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(p2, bondR);\n                            atom2.intersectionShape.cylinder.push(cylinder2);\n                            atom2.intersectionShape.sphere.push(sphere2);\n                        }\n                    }\n                }\n                else if (atom.bondOrder[i] > 1) {\n                    //multi bond caps\n                    var mfromCap = 0;\n                    var mtoCap = 0;\n                    if (bondR != atomBondR) {\n                        //assume jmol style multiple bonds - the radius doesn't fit within atom sphere\n                        mfromCap = 2;\n                        mtoCap = 2;\n                    }\n                    var dir = p2.clone();\n                    var v = null;\n                    dir.sub(p1);\n                    var r, p1a, p1b, p2a, p2b;\n                    v = this.getSideBondV(atom, atom2, i);\n                    if (atom.bondOrder[i] == 2) {\n                        r = bondR * doubleBondScale;\n                        v.multiplyScalar(r * 1.5);\n                        p1a = p1.clone();\n                        p1a.add(v);\n                        p1b = p1.clone();\n                        p1b.sub(v);\n                        p2a = p1a.clone();\n                        p2a.add(dir);\n                        p2b = p1b.clone();\n                        p2b.add(dir);\n                        if (C1 != C2) {\n                            mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1a, p2a)\n                                .multiplyScalar(0.5);\n                            mp2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1b, p2b)\n                                .multiplyScalar(0.5);\n                            drawCyl(geo, p1a, mp, r, C1, mfromCap, 0);\n                            drawCyl(geo, mp, p2a, r, C2, 0, mtoCap);\n                            drawCyl(geo, p1b, mp2, r, C1, mfromCap, 0);\n                            drawCyl(geo, mp2, p2b, r, C2, 0, mtoCap);\n                        }\n                        else {\n                            drawCyl(geo, p1a, p2a, r, C1, mfromCap, mtoCap);\n                            drawCyl(geo, p1b, p2b, r, C1, mfromCap, mtoCap);\n                        }\n                        atomneedsi = atom.clickable || atom.hoverable;\n                        atom2needsi = atom2.clickable || atom2.hoverable;\n                        if (atomneedsi || atom2needsi) {\n                            if (!mp)\n                                mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1a, p2a)\n                                    .multiplyScalar(0.5);\n                            if (!mp2)\n                                mp2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1b, p2b)\n                                    .multiplyScalar(0.5);\n                            if (atomneedsi) {\n                                cylinder1a = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1a, mp, r);\n                                cylinder1b = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1b, mp2, r);\n                                atom.intersectionShape.cylinder.push(cylinder1a);\n                                atom.intersectionShape.cylinder.push(cylinder1b);\n                            }\n                            if (atom2needsi) {\n                                cylinder2a = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2a, mp, r);\n                                cylinder2b = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2b, mp2, r);\n                                atom2.intersectionShape.cylinder.push(cylinder2a);\n                                atom2.intersectionShape.cylinder.push(cylinder2b);\n                            }\n                        }\n                    }\n                    else if (atom.bondOrder[i] == 3) {\n                        r = bondR * tripleBondScale;\n                        v.cross(dir);\n                        v.normalize();\n                        v.multiplyScalar(r * 3);\n                        p1a = p1.clone();\n                        p1a.add(v);\n                        p1b = p1.clone();\n                        p1b.sub(v);\n                        p2a = p1a.clone();\n                        p2a.add(dir);\n                        p2b = p1b.clone();\n                        p2b.add(dir);\n                        if (C1 != C2) {\n                            mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1a, p2a)\n                                .multiplyScalar(0.5);\n                            mp2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1b, p2b)\n                                .multiplyScalar(0.5);\n                            mp3 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1, p2)\n                                .multiplyScalar(0.5);\n                            drawCyl(geo, p1a, mp, r, C1, mfromCap, 0);\n                            drawCyl(geo, mp, p2a, r, C2, 0, mtoCap);\n                            drawCyl(geo, p1, mp3, r, C1, fromCap, 0);\n                            drawCyl(geo, mp3, p2, r, C2, 0, toCap);\n                            drawCyl(geo, p1b, mp2, r, C1, mfromCap, 0);\n                            drawCyl(geo, mp2, p2b, r, C2, 0, mtoCap);\n                        }\n                        else {\n                            drawCyl(geo, p1a, p2a, r, C1, mfromCap, mtoCap);\n                            drawCyl(geo, p1, p2, r, C1, fromCap, toCap);\n                            drawCyl(geo, p1b, p2b, r, C1, mfromCap, mtoCap);\n                        }\n                        atomneedsi = atom.clickable || atom.hoverable;\n                        atom2needsi = atom2.clickable || atom2.hoverable;\n                        if (atomneedsi || atom2needsi) {\n                            if (!mp)\n                                mp = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1a, p2a)\n                                    .multiplyScalar(0.5);\n                            if (!mp2)\n                                mp2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1b, p2b)\n                                    .multiplyScalar(0.5);\n                            if (!mp3)\n                                mp3 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3().addVectors(p1, p2)\n                                    .multiplyScalar(0.5);\n                            if (atomneedsi) {\n                                cylinder1a = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1a.clone(), mp.clone(), r);\n                                cylinder1b = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1b.clone(), mp2.clone(), r);\n                                cylinder1c = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p1.clone(), mp3.clone(), r);\n                                atom.intersectionShape.cylinder.push(cylinder1a);\n                                atom.intersectionShape.cylinder.push(cylinder1b);\n                                atom.intersectionShape.cylinder.push(cylinder1c);\n                            }\n                            if (atom2needsi) {\n                                cylinder2a = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2a.clone(), mp.clone(), r);\n                                cylinder2b = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2b.clone(), mp2.clone(), r);\n                                cylinder2c = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(p2.clone(), mp3.clone(), r);\n                                atom2.intersectionShape.cylinder.push(cylinder2a);\n                                atom2.intersectionShape.cylinder.push(cylinder2b);\n                                atom2.intersectionShape.cylinder.push(cylinder2c);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // draw non bonded heteroatoms as spheres\n        var drawSphere = false;\n        var numsinglebonds = 0;\n        var differentradii = false;\n        //also, if any bonds were drawn as multiples, need sphere\n        for (i = 0; i < atom.bonds.length; i++) {\n            singleBond = atomSingleBond;\n            if (atom.bondStyles && atom.bondStyles[i]) {\n                bstyle = atom.bondStyles[i];\n                if (bstyle.singleBond)\n                    singleBond = true;\n                if (bstyle.radius && bstyle.radius != atomBondR) {\n                    differentradii = true;\n                }\n            }\n            if (singleBond || atom.bondOrder[i] == 1) {\n                numsinglebonds++;\n            }\n        }\n        if (differentradii) { //jmol style double/triple bonds - no sphere\n            if (numsinglebonds > 0)\n                drawSphere = true; //unless needed as a cap\n        }\n        else if (numsinglebonds == 0 && (atom.bonds.length > 0 || style.showNonBonded)) {\n            drawSphere = true;\n        }\n        if (drawSphere) {\n            bondR = atomBondR;\n            //do not use bond style as this can be variable, particularly\n            //with jmol export of double/triple bonds\n            if (geo.imposter) {\n                this.drawSphereImposter(geo.sphereGeometry, atom, bondR, C1);\n            }\n            else {\n                _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawSphere(geo, atom, bondR, C1);\n            }\n        }\n    }\n    ;\n    // go through all the atoms and regenerate their geometries\n    // we try to have one geometry for each style since this is much much\n    // faster\n    // at some point we should optimize this to avoid unnecessary\n    // recalculation\n    /** param {AtomSpec[]} atoms */\n    createMolObj(atoms, options) {\n        options = options || {};\n        var ret = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n        var cartoonAtoms = [];\n        var lineGeometries = {};\n        var crossGeometries = {};\n        var drawSphereFunc = this.drawAtomSphere;\n        var sphereGeometry = null;\n        var stickGeometry = null;\n        if (options.supportsImposters) {\n            drawSphereFunc = this.drawAtomImposter;\n            sphereGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);\n            sphereGeometry.imposter = true;\n            stickGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true, true);\n            stickGeometry.imposter = true;\n            stickGeometry.sphereGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true); //for caps\n            stickGeometry.sphereGeometry.imposter = true;\n            stickGeometry.drawnCaps = {};\n        }\n        else if (options.supportsAIA) {\n            drawSphereFunc = this.drawAtomInstanced;\n            sphereGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(false, true, true);\n            sphereGeometry.instanced = true;\n            stickGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true); //don't actually have instanced sticks\n        }\n        else {\n            sphereGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);\n            stickGeometry = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);\n        }\n        var i, j, n, testOpacities;\n        var opacities = {};\n        var range = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n        for (i = 0, n = atoms.length; i < n; i++) {\n            var atom = atoms[i];\n            // recreate gl info for each atom as necessary\n            // set up appropriate intersection spheres for clickable atoms\n            if (atom && atom.style) {\n                if ((atom.clickable || atom.hoverable) && atom.intersectionShape === undefined)\n                    atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n                testOpacities = { line: undefined, cross: undefined, stick: undefined, sphere: undefined };\n                for (j in testOpacities) {\n                    if (atom.style[j]) {\n                        if (atom.style[j].opacity)\n                            testOpacities[j] = parseFloat(atom.style[j].opacity);\n                        else\n                            testOpacities[j] = 1;\n                    }\n                    else\n                        testOpacities[j] = undefined;\n                    if (opacities[j]) {\n                        if (testOpacities[j] != undefined && opacities[j] != testOpacities[j]) {\n                            console.log(\"Warning: \" + j + \" opacity is ambiguous\");\n                            opacities[j] = 1;\n                        }\n                    }\n                    else\n                        opacities[j] = testOpacities[j];\n                }\n                drawSphereFunc.call(this, atom, sphereGeometry);\n                this.drawAtomClickSphere(atom);\n                this.drawAtomCross(atom, crossGeometries);\n                this.drawBondLines(atom, atoms, lineGeometries);\n                this.drawBondSticks(atom, atoms, stickGeometry);\n                if (typeof (atom.style.cartoon) !== \"undefined\" && !atom.style.cartoon.hidden) {\n                    //gradient color scheme range\n                    if (atom.style.cartoon.color === \"spectrum\" && typeof (atom.resi) === \"number\" && !atom.hetflag) {\n                        if (atom.resi < range[0])\n                            range[0] = atom.resi;\n                        if (atom.resi > range[1])\n                            range[1] = atom.resi;\n                    }\n                    cartoonAtoms.push(atom);\n                }\n            }\n        }\n        // create cartoon if needed - this is a whole model analysis\n        if (cartoonAtoms.length > 0) {\n            (0,_glcartoon__WEBPACK_IMPORTED_MODULE_5__.drawCartoon)(ret, cartoonAtoms, range, this.defaultCartoonQuality);\n        }\n        // add sphere geometry\n        if (sphereGeometry && sphereGeometry.vertices > 0) {\n            //Initialize buffers in geometry\n            sphereGeometry.initTypedArrays();\n            var sphereMaterial = null;\n            var sphere = null;\n            //create appropriate material\n            if (sphereGeometry.imposter) {\n                sphereMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.SphereImposterMaterial({\n                    ambient: 0x000000,\n                    vertexColors: true,\n                    reflectivity: 0\n                });\n            }\n            else if (sphereGeometry.instanced) {\n                sphere = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);\n                _GLDraw__WEBPACK_IMPORTED_MODULE_4__.GLDraw.drawSphere(sphere, { x: 0, y: 0, z: 0 }, 1, new _colors__WEBPACK_IMPORTED_MODULE_3__.Color(0.5, 0.5, 0.5));\n                sphere.initTypedArrays();\n                sphereMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.InstancedMaterial({\n                    sphereMaterial: new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial({\n                        ambient: 0x000000,\n                        vertexColors: true,\n                        reflectivity: 0,\n                    }),\n                    sphere: sphere\n                });\n            }\n            else { //regular mesh\n                sphereMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial({\n                    ambient: 0x000000,\n                    vertexColors: true,\n                    reflectivity: 0,\n                });\n            }\n            if (opacities.sphere < 1 && opacities.sphere >= 0) {\n                sphereMaterial.transparent = true;\n                sphereMaterial.opacity = opacities.sphere;\n            }\n            sphere = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(sphereGeometry, sphereMaterial);\n            ret.add(sphere);\n        }\n        // add stick geometry\n        if (stickGeometry.vertices > 0) {\n            var stickMaterial = null;\n            var ballMaterial = null;\n            var balls = stickGeometry.sphereGeometry;\n            if (!balls || typeof (balls.vertices) === 'undefined' || balls.vertices == 0)\n                balls = null; //no balls\n            //Initialize buffers in geometry\n            stickGeometry.initTypedArrays();\n            if (balls)\n                balls.initTypedArrays();\n            //create material\n            var matvals = { ambient: 0x000000, vertexColors: true, reflectivity: 0 };\n            if (stickGeometry.imposter) {\n                stickMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.StickImposterMaterial(matvals);\n                ballMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.SphereImposterMaterial(matvals);\n            }\n            else {\n                stickMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial(matvals);\n                ballMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial(matvals);\n                if (stickMaterial.wireframe) {\n                    stickGeometry.setUpWireframe();\n                    if (balls)\n                        balls.setUpWireframe();\n                }\n            }\n            if (opacities.stick < 1 && opacities.stick >= 0) {\n                stickMaterial.transparent = true;\n                stickMaterial.opacity = opacities.stick;\n                ballMaterial.transparent = true;\n                ballMaterial.opacity = opacities.stick;\n            }\n            var sticks = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(stickGeometry, stickMaterial);\n            ret.add(sticks);\n            if (balls) {\n                var stickspheres = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(balls, ballMaterial);\n                ret.add(stickspheres);\n            }\n        }\n        //var linewidth;\n        // add any line geometries, distinguished by line width\n        var linewidth;\n        for (i in lineGeometries) {\n            if (lineGeometries.hasOwnProperty(i)) {\n                linewidth = i;\n                var lineMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({\n                    linewidth: linewidth,\n                    vertexColors: true\n                });\n                if (opacities.line < 1 && opacities.line >= 0) {\n                    lineMaterial.transparent = true;\n                    lineMaterial.opacity = opacities.line;\n                }\n                lineGeometries[i].initTypedArrays();\n                var line = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometries[i], lineMaterial, _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineStyle.LinePieces);\n                ret.add(line);\n            }\n        }\n        // add any cross geometries\n        for (i in crossGeometries) {\n            if (crossGeometries.hasOwnProperty(i)) {\n                linewidth = i;\n                var crossMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({\n                    linewidth: linewidth,\n                    vertexColors: true\n                });\n                if (opacities.cross < 1 && opacities.cross >= 0) {\n                    crossMaterial.transparent = true;\n                    crossMaterial.opacity = opacities.cross;\n                }\n                crossGeometries[i].initTypedArrays();\n                var cross = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Line(crossGeometries[i], crossMaterial, _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineStyle.LinePieces);\n                ret.add(cross);\n            }\n        }\n        //for BIOMT assembly\n        if (this.dontDuplicateAtoms && this.modelData.symmetries && this.modelData.symmetries.length > 0) {\n            var finalRet = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            var t;\n            for (t = 0; t < this.modelData.symmetries.length; t++) {\n                var transformedRet = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n                transformedRet = ret.clone();\n                transformedRet.matrix.copy(this.modelData.symmetries[t]);\n                transformedRet.matrixAutoUpdate = false;\n                finalRet.add(transformedRet);\n            }\n            return finalRet;\n        }\n        return ret;\n    }\n    ;\n    /**\n     * Return object representing internal state of\n     * the model appropriate for passing to setInternalState\n     *\n    */\n    getInternalState() {\n        return {\n            'atoms': this.atoms,\n            'frames': this.frames\n        };\n    }\n    ;\n    /**\n     * Overwrite the internal model state with the passed state.\n     *\n    */\n    setInternalState(state) {\n        this.atoms = state.atoms;\n        this.frames = state.frames;\n        this.molObj = null;\n    }\n    ;\n    /**\n     * Returns crystallographic information if present.\n     *\n     *\n     */\n    getCrystData() {\n        if (this.modelData.cryst) {\n            // add the matrix if it is missing\n            if (!this.modelData.cryst.matrix) {\n                const cryst = this.modelData.cryst;\n                this.modelData.cryst.matrix = (0,_WebGL_math__WEBPACK_IMPORTED_MODULE_2__.conversionMatrix3)(cryst.a, cryst.b, cryst.c, cryst.alpha, cryst.beta, cryst.gamma);\n            }\n            return this.modelData.cryst;\n        }\n        else {\n            return null;\n        }\n    }\n    ;\n    /**\n     * Set crystallographic information using three angles and three lengths\n     *\n     * @param {number} a - length of unit cell side\n     * @param {number} b - length of unit cell side\n     * @param {number} c - length of unit cell side\n     * @param {number} alpha - unit cell angle in degrees (default 90)\n     * @param {number} beta - unit cell angle in degrees (default 90)\n     * @param {number} gamma - unit cell angle in degrees (default 90)\n\n     */\n    setCrystData(a, b, c, alpha, beta, gamma) {\n        //I am assuming these\n        a = a || 1.0;\n        b = b || 1.0;\n        c = c || 1.0;\n        alpha = alpha || 90;\n        beta = beta || 90;\n        gamma = gamma || 90;\n        const matrix = (0,_WebGL_math__WEBPACK_IMPORTED_MODULE_2__.conversionMatrix3)(a, b, c, alpha, beta, gamma);\n        this.modelData.cryst = {\n            'a': a, 'b': b, 'c': c,\n            'alpha': alpha, 'beta': beta, 'gamma': gamma,\n            'matrix': matrix\n        };\n    }\n    ;\n    /**\n     * Set the crystallographic matrix to the given matrix.\n     *\n     * This function removes `a`, `b`, `c`, `alpha`, `beta`, `gamma` from\n     * the crystal data.\n     *\n     * @param {Matrix3} matrix - unit cell matrix\n     */\n    setCrystMatrix(matrix) {\n        matrix = matrix || new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        this.modelData.cryst = {\n            'matrix': matrix\n        };\n    }\n    ;\n    /**\n     * Returns list of rotational/translational matrices if there is BIOMT data\n     * Otherwise returns a list of just the ID matrix\n     *\n     * @return {Array<Matrix4>}\n     *\n     */\n    getSymmetries() {\n        if (typeof (this.modelData.symmetries) == 'undefined') {\n            this.modelData.symmetries = [this.idMatrix];\n        }\n        return this.modelData.symmetries;\n    }\n    ;\n    /**\n     * Sets symmetries based on specified matrices in list\n     *\n     * @param {Array<Matrix4>} list\n     *\n     */\n    setSymmetries(list) {\n        if (typeof (list) == \"undefined\") { //delete sym data\n            this.modelData.symmetries = [this.idMatrix];\n        }\n        else {\n            this.modelData.symmetries = list;\n        }\n    }\n    ;\n    /**\n     * Returns model id number\n     *\n     * @return {number} Model ID\n     */\n    getID() {\n        return this.id;\n    }\n    ;\n    /**\n     * Returns model's frames property, a list of atom lists\n     *\n     * @return {number}\n     */\n    getNumFrames() {\n        return (this.frames.numFrames != undefined) ? this.frames.numFrames : this.frames.length;\n    }\n    ;\n    adjustCoord(x1, x2, margin, adjust) {\n        //return new value of x2 that isn't more than margin away\n        var dist = x2 - x1;\n        if (dist < -margin) {\n            return x2 + adjust;\n        }\n        else if (dist > margin) {\n            return x2 - adjust;\n        }\n        return x2;\n    }\n    ;\n    //go over current atoms in depth first order and ensure that connected\n    //attoms aren't split across the box\n    adjustCoordinatesToBox() {\n        if (!this.box)\n            return;\n        if (!this.atomdfs)\n            return;\n        var bx = this.box[0];\n        var by = this.box[1];\n        var bz = this.box[2];\n        var mx = bx * 0.9;\n        var my = by * 0.9;\n        var mz = bz * 0.9;\n        for (var c = 0; c < this.atomdfs.length; c++) {\n            //for each connected component\n            var component = this.atomdfs[c];\n            for (var i = 1; i < component.length; i++) {\n                //compare each atom to its previous and prevent coordinates from wrapping\n                var atom = this.atoms[component[i][0]];\n                var prev = this.atoms[component[i][1]];\n                atom.x = this.adjustCoord(prev.x, atom.x, mx, bx);\n                atom.y = this.adjustCoord(prev.y, atom.y, my, by);\n                atom.z = this.adjustCoord(prev.z, atom.z, mz, bz);\n            }\n        }\n    }\n    ;\n    /**\n     * Sets model's atomlist to specified frame\n     * Sets to last frame if framenum out of range\n     *\n     * @param {number} framenum - model's atoms are set to this index in frames list\n     * @return {Promise}\n     */\n    setFrame(framenum, viewer) {\n        var numFrames = this.getNumFrames();\n        let model = this;\n        return new Promise(function (resolve, reject) {\n            if (numFrames == 0) {\n                //return;\n                resolve();\n            }\n            if (framenum < 0 || framenum >= numFrames) {\n                framenum = numFrames - 1;\n            }\n            if (model.frames.url != undefined) {\n                var url = model.frames.url;\n                (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getbin)(url + \"/traj/frame/\" + framenum + \"/\" + model.frames.path, undefined, 'POST', undefined).then(function (buffer) {\n                    var values = new Float32Array(buffer, 44);\n                    var count = 0;\n                    for (var i = 0; i < model.atoms.length; i++) {\n                        model.atoms[i].x = values[count++];\n                        model.atoms[i].y = values[count++];\n                        model.atoms[i].z = values[count++];\n                    }\n                    //if a box was provided, check to see if we need to wrap connected components\n                    if (model.box && model.atomdfs) {\n                        model.adjustCoordinatesToBox();\n                    }\n                    resolve();\n                }).catch(reject);\n            }\n            else {\n                model.atoms = model.frames[framenum];\n                resolve();\n            }\n            model.molObj = null;\n            if (model.modelDatas && framenum < model.modelDatas.length) {\n                model.modelData = model.modelDatas[framenum];\n                if (model.unitCellObjects && viewer) {\n                    viewer.removeUnitCell(model);\n                    viewer.addUnitCell(model);\n                }\n            }\n        });\n    }\n    ;\n    /**\n     * Add atoms as frames of model\n     *\n     * @param {AtomSpec[]} atoms - atoms to be added\n     */\n    addFrame(atoms) {\n        this.frames.push(atoms);\n    }\n    ;\n    /**\n     * If model atoms have dx, dy, dz properties (in some xyz files), vibrate populates the model's frame property based on parameters.\n     * Model can then be animated\n     *\n     * @param {number} numFrames - number of frames to be created, default to 10\n     * @param {number} amplitude - amplitude of distortion, default to 1 (full)\n     * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames\n     * @param {GLViewer} viewer - required if arrowSpec is provided\n     * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.\n     *@example\n\n      $3Dmol.download(\"pdb:4UAA\",viewer,{},function(){\n        viewer.setStyle({},{stick:{}});\n        viewer.vibrate(10, 1);\n        viewer.animate({loop: \"forward\",reps: 1});\n\n        viewer.zoomTo();\n              viewer.render();\n          });\n     */\n    vibrate(numFrames = 10, amplitude = 1, bothWays = false, viewer, arrowSpec) {\n        var start = 0;\n        var end = numFrames;\n        if (bothWays) {\n            start = -numFrames;\n            end = numFrames;\n        }\n        //to enable multiple setting of vibrate with bothWays, must record original position\n        if (this.frames !== undefined && this.frames.origIndex !== undefined) {\n            this.setFrame(this.frames.origIndex);\n        }\n        else {\n            this.setFrame(0);\n        }\n        if (start < end)\n            this.frames = []; //clear\n        if (bothWays)\n            this.frames.origIndex = numFrames;\n        for (var i = start; i < end; i++) {\n            var newAtoms = [];\n            var currframe = this.frames.length;\n            if (i == 0 && !arrowSpec) { //still need to calculate if drawing arrows\n                this.frames.push(this.atoms);\n                continue;\n            }\n            for (var j = 0; j < this.atoms.length; j++) {\n                var dx = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getAtomProperty)(this.atoms[j], 'dx');\n                var dy = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getAtomProperty)(this.atoms[j], 'dy');\n                var dz = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getAtomProperty)(this.atoms[j], 'dz');\n                var newVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(dx, dy, dz);\n                var starting = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(this.atoms[j].x, this.atoms[j].y, this.atoms[j].z);\n                var mult = (i * amplitude) / numFrames;\n                newVector.multiplyScalar(mult);\n                starting.add(newVector);\n                var newAtom = {};\n                for (var k in this.atoms[j]) {\n                    newAtom[k] = this.atoms[j][k];\n                }\n                newAtom.x = starting.x;\n                newAtom.y = starting.y;\n                newAtom.z = starting.z;\n                newAtoms.push(newAtom);\n                if (viewer && arrowSpec) {\n                    var spec = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.extend)({}, arrowSpec);\n                    var arrowend = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(dx, dy, dz);\n                    arrowend.multiplyScalar(amplitude);\n                    arrowend.add(starting);\n                    spec.start = starting;\n                    spec.end = arrowend;\n                    spec.frame = currframe;\n                    if (!spec.color) {\n                        var s = newAtom.style.sphere;\n                        if (!s)\n                            s = newAtom.style.stick;\n                        if (!s)\n                            s = newAtom.style.line;\n                        spec.color = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(newAtom, s);\n                    }\n                    viewer.addArrow(spec);\n                }\n            }\n            this.frames.push(newAtoms);\n        }\n    }\n    ;\n    // set default style and colors for atoms\n    setAtomDefaults(atoms) {\n        for (let i = 0; i < atoms.length; i++) {\n            let atom = atoms[i];\n            if (atom) {\n                atom.style = atom.style || (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.deepCopy)(GLModel.defaultAtomStyle);\n                atom.color = atom.color || this.ElementColors[atom.elem] || this.defaultColor;\n                atom.model = this.id;\n                if (atom.clickable || atom.hoverable)\n                    atom.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n            }\n        }\n    }\n    ;\n    /** add atoms to this model from molecular data string\n     *\n     * @param {string|ArrayBuffer} data - atom structure file input data string, for gzipped input use ArrayBuffer\n     * @param {string} format - input file string format (e.g 'pdb', 'sdf', 'sdf.gz', etc.)\n     * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input format\n     */\n    addMolData(data, format, options = {}) {\n        var parsedAtoms = GLModel.parseMolData(data, format, options);\n        this.dontDuplicateAtoms = !options.duplicateAssemblyAtoms;\n        var mData = parsedAtoms.modelData;\n        if (mData) {\n            if (Array.isArray(mData)) {\n                this.modelData = mData[0];\n                if (options.frames) {\n                    this.modelDatas = mData;\n                }\n            }\n            else {\n                this.modelData = mData;\n            }\n        }\n        if (parsedAtoms.box) {\n            this.box = parsedAtoms.box;\n        }\n        else {\n            this.box = null;\n        }\n        if (this.frames.length == 0) { //first call\n            for (let i = 0; i < parsedAtoms.length; i++) {\n                if (parsedAtoms[i].length != 0)\n                    this.frames.push(parsedAtoms[i]);\n            }\n            if (this.frames[0])\n                this.atoms = this.frames[0];\n        }\n        else { //subsequent calls\n            if (options.frames) { //add to new frame\n                for (let i = 0; i < parsedAtoms.length; i++) {\n                    this.frames.push(parsedAtoms[i]);\n                }\n            }\n            else { //add atoms to current frame\n                for (var i = 0; i < parsedAtoms.length; i++) {\n                    this.addAtoms(parsedAtoms[i]);\n                }\n            }\n        }\n        for (let i = 0; i < this.frames.length; i++) {\n            this.setAtomDefaults(this.frames[i]);\n        }\n        if (options.vibrate && options.vibrate.frames && options.vibrate.amplitude) {\n            //fill in vibrational modes\n            this.vibrate(options.vibrate.frames, options.vibrate.amplitude);\n        }\n        if (options.style) {\n            this.setStyle({}, options.style);\n        }\n    }\n    ;\n    setDontDuplicateAtoms(dup) {\n        this.dontDuplicateAtoms = dup;\n    }\n    ;\n    setModelData(mData) {\n        this.modelData = mData;\n    }\n    ;\n    //return true if atom value matches property val\n    propertyMatches(atomval, val) {\n        if (atomval == val) {\n            return true;\n        }\n        else if (typeof (val) == 'string' && typeof (atomval) == 'number') {\n            //support numerical integer ranges, e.g. resi: 3-7\n            var match = val.match(/(-?\\d+)\\s*-\\s*(-?\\d+)/);\n            if (match) {\n                var lo = parseInt(match[1]);\n                var hi = parseInt(match[2]);\n                if (match && atomval >= lo && atomval <= hi) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    ;\n    // make a deep copy of a selection object and create caches of expensive\n    // selections.  We create a copy so caches are not attached to user\n    // supplied objects where the user might change them invalidating the cache.\n    // This does not support arbitrary\n    // javascript objects, but support enough for eveything that is\n    // used in selections: number, string, boolean, functions; as well\n    // as arrays and nested objects with values of the aformentioned\n    // types.\n    static deepCopyAndCache(selobject, model) {\n        if (typeof selobject != 'object' || selobject == null)\n            return selobject;\n        if (selobject.__cache_created)\n            return selobject; //already done\n        const copy = {};\n        for (const key in selobject) {\n            const item = selobject[key];\n            if (Array.isArray(item)) {\n                // handle array separatly from other typeof == \"object\"\n                // elements\n                copy[key] = [];\n                for (let i = 0; i < item.length; i++) {\n                    copy[key].push(GLModel.deepCopyAndCache(item[i], model));\n                }\n            }\n            else if (typeof item === \"object\" && key != \"properties\" && key != \"model\") {\n                copy[key] = GLModel.deepCopyAndCache(item, model);\n            }\n            else {\n                copy[key] = item;\n            }\n            //create caches of expensive selection types - the cache\n            //stores the atoms matching the selection type\n            if (key == \"and\" || key == \"or\") {\n                // create a list of sets of matching atoms indexes for\n                // each sub-selection\n                const results = [];\n                for (const subSelection of copy[key]) {\n                    const set = new Set();\n                    for (const match of model.selectedAtoms(subSelection)) {\n                        set.add(match.index);\n                    }\n                    results.push(set);\n                }\n                if (key == \"and\") {\n                    // get the intersection of two sets\n                    const intersect = function (first, other) {\n                        const result = new Set();\n                        for (const elem of other) {\n                            if (first.has(elem)) {\n                                result.add(elem);\n                            }\n                        }\n                        return result;\n                    };\n                    let intersection = new Set(results[0]);\n                    for (const set of results.splice(1)) {\n                        intersection = intersect(intersection, set);\n                    }\n                    copy[key].__cached_results = intersection;\n                }\n                else if (key == \"or\") {\n                    const union = new Set();\n                    for (const set of results) {\n                        for (const elem of set) {\n                            union.add(elem);\n                        }\n                    }\n                    copy[key].__cached_results = union;\n                }\n            }\n        }\n        copy.__cache_created = true;\n        return copy;\n    }\n    ;\n    /** given a selection specification, return true if atom is selected.\n     * Does not support context-aware selectors like expand/within/byres.\n     *\n     * @param {AtomSpec} atom\n     * @param {AtomSelectionSpec} sel\n     * @return {boolean}\n     */\n    atomIsSelected(atom, sel) {\n        if (typeof (sel) === \"undefined\")\n            return true; // undef gets all\n        var invert = !!sel.invert;\n        var ret = true;\n        for (var key in sel) {\n            if (key == \"and\" || key == \"or\" || key == \"not\") { //boolean operators\n                if (key == \"not\") {\n                    if (this.atomIsSelected(atom, sel[key])) {\n                        ret = false;\n                        break;\n                    }\n                }\n                else { //\"or\" and \"and\"\n                    // these selections are expensive so when called via\n                    //selectedAtoms shoudl be cached - but if atomIsSelected\n                    //is called directly create the cache\n                    if (sel[key].__cached_results === undefined) {\n                        sel = GLModel.deepCopyAndCache(sel, this);\n                    }\n                    ret = sel[key].__cached_results.has(atom.index);\n                    if (!ret) {\n                        break;\n                    }\n                }\n            }\n            else if (key === 'predicate') { //a user supplied function for evaluating atoms\n                if (!sel.predicate(atom)) {\n                    ret = false;\n                    break;\n                }\n            }\n            else if (key == \"properties\" && atom[key]) {\n                for (var propkey in sel.properties) {\n                    if (propkey.startsWith(\"__cache\"))\n                        continue;\n                    if (typeof (atom.properties[propkey]) === 'undefined') {\n                        ret = false;\n                        break;\n                    }\n                    if (atom.properties[propkey] != sel.properties[propkey]) {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n            else if (sel.hasOwnProperty(key) && !GLModel.ignoredKeys.has(key) && !key.startsWith('__cache')) {\n                // if something is in sel, atom must have it\n                if (typeof (atom[key]) === \"undefined\") {\n                    ret = false;\n                    break;\n                }\n                var isokay = false;\n                if (key === \"bonds\") {\n                    //special case counting number of bonds, for selecting nonbonded mostly\n                    var val = sel[key];\n                    if (val != atom.bonds.length) {\n                        ret = false;\n                        break;\n                    }\n                }\n                else if (Array.isArray(sel[key])) {\n                    // can be any of the listed values\n                    var valarr = sel[key];\n                    var atomval = atom[key];\n                    for (let i = 0; i < valarr.length; i++) {\n                        if (this.propertyMatches(atomval, valarr[i])) {\n                            isokay = true;\n                            break;\n                        }\n                    }\n                    if (!isokay) {\n                        ret = false;\n                        break;\n                    }\n                }\n                else { // single match\n                    let val = sel[key];\n                    if (!this.propertyMatches(atom[key], val)) {\n                        ret = false;\n                        break;\n                    }\n                }\n            }\n        }\n        return invert ? !ret : ret;\n    }\n    ;\n    static squaredDistance(atom1, atom2) {\n        var xd = atom2.x - atom1.x;\n        var yd = atom2.y - atom1.y;\n        var zd = atom2.z - atom1.z;\n        return xd * xd + yd * yd + zd * zd;\n    }\n    ;\n    /** returns a list of atoms in the expanded bounding box, but not in the current one\n     *\n     *  Bounding box:\n     *\n     *    [ [ xmin, ymin, zmin ],\n     *      [ xmax, ymax, zmax ],\n     *      [ xctr, yctr, zctr ] ]\n     *\n     **/\n    expandAtomList(atomList, amt) {\n        if (amt <= 0)\n            return atomList;\n        var pb = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getExtent)(atomList, undefined); // previous bounding box\n        var nb = [[], [], []]; // expanded bounding box\n        for (var i = 0; i < 3; i++) {\n            nb[0][i] = pb[0][i] - amt;\n            nb[1][i] = pb[1][i] + amt;\n            nb[2][i] = pb[2][i];\n        }\n        // look in added box \"shell\" for new atoms\n        var expand = [];\n        for (let i = 0; i < this.atoms.length; i++) {\n            var x = this.atoms[i].x;\n            var y = this.atoms[i].y;\n            var z = this.atoms[i].z;\n            if (x >= nb[0][0] && x <= nb[1][0] && y >= nb[0][1] && y <= nb[1][1] && z >= nb[0][2] && z <= nb[1][2]) {\n                if (!(x >= pb[0][0] && x <= pb[1][0] && y >= pb[0][1] && y <= pb[1][1] && z >= pb[0][2] && z <= pb[1][2])) {\n                    expand.push(this.atoms[i]);\n                }\n            }\n        }\n        return expand;\n    }\n    ;\n    static getFloat(val) {\n        if (typeof (val) === 'number')\n            return val;\n        else\n            return parseFloat(val);\n    }\n    /** return list of atoms selected by sel, this is specific to glmodel\n     *\n     * @param {AtomSelectionSpec} sel\n     * @return {Object[]}\n     * @example\n     $3Dmol.download(\"pdb:4wwy\",viewer,{},function(){\n              var atoms = viewer.selectedAtoms({chain:'A'});\n              for(var i = 0, n = atoms.length; i < n; i++) {\n                 atoms[i].b = 0.0;\n              }\n              viewer.setStyle({cartoon:{colorscheme:{prop:'b',gradient: 'roygb',min:0,max:30}}});\n              viewer.render();\n          });\n     */\n    selectedAtoms(sel, from) {\n        var ret = [];\n        // make a copy of the selection to allow caching results without\n        // the possibility for the user to change the selection and this\n        // code not noticing the changes\n        sel = GLModel.deepCopyAndCache(sel || {}, this);\n        if (!from)\n            from = this.atoms;\n        var aLength = from.length;\n        for (var i = 0; i < aLength; i++) {\n            var atom = from[i];\n            if (atom) {\n                if (this.atomIsSelected(atom, sel))\n                    ret.push(atom);\n            }\n        }\n        // expand selection by some distance\n        if (sel.hasOwnProperty(\"expand\")) {\n            // get atoms in expanded bounding box\n            const exdist = GLModel.getFloat(sel.expand);\n            let expand = this.expandAtomList(ret, exdist);\n            let retlen = ret.length;\n            const thresh = exdist * exdist;\n            for (let i = 0; i < expand.length; i++) {\n                for (let j = 0; j < retlen; j++) {\n                    var dist = GLModel.squaredDistance(expand[i], ret[j]);\n                    if (dist < thresh && dist > 0) {\n                        ret.push(expand[i]);\n                    }\n                }\n            }\n        }\n        // selection within distance of sub-selection\n        if (sel.hasOwnProperty(\"within\") && sel.within.hasOwnProperty(\"sel\") &&\n            sel.within.hasOwnProperty(\"distance\")) {\n            // get atoms in second selection\n            var sel2 = this.selectedAtoms(sel.within.sel, this.atoms);\n            var within = {};\n            const dist = GLModel.getFloat(sel.within.distance);\n            const thresh = dist * dist;\n            for (let i = 0; i < sel2.length; i++) {\n                for (let j = 0; j < ret.length; j++) {\n                    let dist = GLModel.squaredDistance(sel2[i], ret[j]);\n                    if (dist < thresh && dist > 0) {\n                        within[j] = 1;\n                    }\n                }\n            }\n            var newret = [];\n            if (sel.within.invert) {\n                for (let j = 0; j < ret.length; j++) {\n                    if (!within[j])\n                        newret.push(ret[j]);\n                }\n            }\n            else {\n                for (let j in within) {\n                    newret.push(ret[j]);\n                }\n            }\n            ret = newret;\n        }\n        // byres selection flag\n        if (sel.hasOwnProperty(\"byres\")) {\n            // Keep track of visited residues, visited atoms, and atom stack\n            var vResis = {};\n            var vAtoms = [];\n            var stack = [];\n            for (let i = 0; i < ret.length; i++) {\n                // Check if atom is part of a residue, and that the residue hasn't been traversed yet\n                let atom = ret[i];\n                var c = atom.chain;\n                var r = atom.resi;\n                if (vResis[c] === undefined)\n                    vResis[c] = {};\n                if (atom.hasOwnProperty(\"resi\") && vResis[c][r] === undefined) {\n                    // Perform a depth-first search of atoms with the same resi\n                    vResis[c][r] = true;\n                    stack.push(atom);\n                    while (stack.length > 0) {\n                        atom = stack.pop();\n                        c = atom.chain;\n                        r = atom.resi;\n                        if (vAtoms[atom.index] === undefined) {\n                            vAtoms[atom.index] = true;\n                            for (var j = 0; j < atom.bonds.length; j++) {\n                                var atom2 = this.atoms[atom.bonds[j]];\n                                if (vAtoms[atom2.index] === undefined && atom2.hasOwnProperty(\"resi\") && atom2.chain == c && atom2.resi == r) {\n                                    stack.push(atom2);\n                                    ret.push(atom2);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n    ;\n    /** Add list of new atoms to model.  Adjusts bonds appropriately.\n     *\n     * @param {AtomSpec[]} newatoms\n     * @example\n     * var atoms = [{elem: 'C', x: 0, y: 0, z: 0, bonds: [1,2], bondOrder: [1,2]}, {elem: 'O', x: -1.5, y: 0, z: 0, bonds: [0]},{elem: 'O', x: 1.5, y: 0, z: 0, bonds: [0], bondOrder: [2]}];\n\n        viewer.setBackgroundColor(0xffffffff);\n        var m = viewer.addModel();\n        m.addAtoms(atoms);\n        m.setStyle({},{stick:{}});\n        viewer.zoomTo();\n        viewer.render();\n     */\n    addAtoms(newatoms) {\n        this.molObj = null;\n        var start = this.atoms.length;\n        var indexmap = [];\n        // mapping from old index to new index\n        var i;\n        for (i = 0; i < newatoms.length; i++) {\n            if (typeof (newatoms[i].index) == \"undefined\")\n                newatoms[i].index = i;\n            if (typeof (newatoms[i].serial) == \"undefined\")\n                newatoms[i].serial = i;\n            indexmap[newatoms[i].index] = start + i;\n        }\n        // copy and push newatoms onto atoms\n        for (i = 0; i < newatoms.length; i++) {\n            var olda = newatoms[i];\n            var nindex = indexmap[olda.index];\n            var a = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.extend)({}, olda);\n            a.index = nindex;\n            a.bonds = [];\n            a.bondOrder = [];\n            a.model = this.id;\n            a.style = a.style || (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.deepCopy)(GLModel.defaultAtomStyle);\n            if (typeof (a.color) == \"undefined\")\n                a.color = this.ElementColors[a.elem] || this.defaultColor;\n            // copy over all bonds contained in selection,\n            // updating indices appropriately\n            var nbonds = olda.bonds ? olda.bonds.length : 0;\n            for (var j = 0; j < nbonds; j++) {\n                var neigh = indexmap[olda.bonds[j]];\n                if (typeof (neigh) != \"undefined\") {\n                    a.bonds.push(neigh);\n                    a.bondOrder.push(olda.bondOrder ? olda.bondOrder[j] : 1);\n                }\n            }\n            this.atoms.push(a);\n        }\n    }\n    ;\n    /** Assign bonds based on atomic coordinates.\n     *  This currently uses a primitive distance-based algorithm that does not\n     * consider valence constraints and will only create single bonds.\n     */\n    assignBonds() {\n        (0,_parsers_utils_assignBonds__WEBPACK_IMPORTED_MODULE_11__.assignBonds)(this.atoms, { assignBonds: true });\n    }\n    /** Remove specified atoms from model\n     *\n     * @param {AtomSpec[]} badatoms - list of atoms\n     */\n    removeAtoms(badatoms) {\n        this.molObj = null;\n        // make map of all baddies\n        var baddies = [];\n        var i;\n        for (i = 0; i < badatoms.length; i++) {\n            baddies[badatoms[i].index] = true;\n        }\n        // create list of good atoms\n        var newatoms = [];\n        for (i = 0; i < this.atoms.length; i++) {\n            var a = this.atoms[i];\n            if (!baddies[a.index])\n                newatoms.push(a);\n        }\n        // clear it all out\n        this.atoms = [];\n        // and add back in to get updated bonds\n        this.addAtoms(newatoms);\n    }\n    ;\n    /** Set atom style of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel\n     * @param {AtomStyleSpec} style\n     * @param {boolean} add - if true, add to current style, don't replace\n     @example\n    $3Dmol.download(\"pdb:4UB9\",viewer,{},function(){\n              viewer.setBackgroundColor(0xffffffff);\n\n              viewer.setStyle({chain:'A'},{line:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'B'},{line:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'C'},{cross:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'D'},{cross:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'E'},{cross:{radius:2.0,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'F'},{stick:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'G'},{stick:{radius:0.8,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.setStyle({chain:'H'},{stick:{singleBonds:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});\n              viewer.render();\n          });\n     */\n    setStyle(sel, style, add) {\n        if (typeof (style) === 'undefined' && typeof (add) == 'undefined') {\n            //if a single argument is provided, assume it is a style and select all\n            style = sel;\n            sel = {};\n        }\n        sel = sel;\n        //if type is just a string, promote it to an object\n        if (typeof (style) === 'string') {\n            style = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.specStringToObject)(style);\n        }\n        var changedAtoms = false;\n        // somethings we only calculate if there is a change in a certain\n        // style, although these checks will only catch cases where both\n        // are either null or undefined\n        var that = this;\n        var setStyleHelper = function (atomArr) {\n            var selected = that.selectedAtoms(sel, atomArr);\n            for (let i = 0; i < atomArr.length; i++) {\n                if (atomArr[i])\n                    atomArr[i].capDrawn = false; //reset for proper stick render\n            }\n            for (let i = 0; i < selected.length; i++) {\n                changedAtoms = true;\n                if (selected[i].clickable || selected[i].hoverable)\n                    selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n                if (!add)\n                    selected[i].style = {};\n                for (let s in style) {\n                    if (style.hasOwnProperty(s)) {\n                        selected[i].style[s] = selected[i].style[s] || {}; //create distinct object for each atom\n                        Object.assign(selected[i].style[s], style[s]);\n                    }\n                }\n            }\n        };\n        if (sel.frame !== undefined && sel.frame < this.frames.length) { //set specific frame only\n            let frame = sel.frame;\n            if (frame < 0)\n                frame = this.frames.length + frame;\n            setStyleHelper(this.frames[frame]);\n        }\n        else {\n            setStyleHelper(this.atoms);\n            for (var i = 0; i < this.frames.length; i++) {\n                if (this.frames[i] !== this.atoms)\n                    setStyleHelper(this.frames[i]);\n            }\n        }\n        if (changedAtoms)\n            this.molObj = null; //force rebuild\n    }\n    ;\n    /** Set clickable and callback of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to\n     * @param {boolean} clickable - whether click-handling is enabled for the selection\n     * @param {function} callback - function called when an atom in the selection is clicked\n\n     */\n    setClickable(sel, clickable, callback) {\n        // make sure clickable is a boolean\n        clickable = !!clickable;\n        callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.makeFunction)(callback);\n        if (callback === null) {\n            console.log(\"Callback is not a function\");\n            return;\n        }\n        var selected = this.selectedAtoms(sel, this.atoms);\n        var len = selected.length;\n        for (let i = 0; i < len; i++) {\n            selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n            selected[i].clickable = clickable;\n            if (callback)\n                selected[i].callback = callback;\n        }\n        if (len > 0)\n            this.molObj = null; // force rebuild to get correct intersection shapes\n    }\n    ;\n    /** Set hoverable and callback of selected atoms\n    *\n    * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to\n    * @param {boolean} hoverable - whether hover-handling is enabled for the selection\n    * @param {function} hover_callback - function called when an atom in the selection is hovered over\n    * @param {function} unhover_callback - function called when the mouse moves out of the hover area\n    */\n    setHoverable(sel, hoverable, hover_callback, unhover_callback) {\n        // make sure hoverable is a boolean\n        hoverable = !!hoverable;\n        hover_callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.makeFunction)(hover_callback);\n        unhover_callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.makeFunction)(unhover_callback);\n        // report to console if hover_callback is not a valid function\n        if (hover_callback === null) {\n            console.log(\"Hover_callback is not a function\");\n            return;\n        }\n        // report to console if unhover_callback is not a valid function\n        if (unhover_callback === null) {\n            console.log(\"Unhover_callback is not a function\");\n            return;\n        }\n        var selected = this.selectedAtoms(sel, this.atoms);\n        var len = selected.length;\n        for (let i = 0; i < len; i++) {\n            selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n            selected[i].hoverable = hoverable;\n            if (hover_callback)\n                selected[i].hover_callback = hover_callback;\n            if (unhover_callback)\n                selected[i].unhover_callback = unhover_callback;\n        }\n        if (len > 0)\n            this.molObj = null; // force rebuild to get correct intersection shapes\n    }\n    ;\n    /** enable context menu of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to\n     * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection\n     */\n    enableContextMenu(sel, contextMenuEnabled) {\n        // make sure contextMenuEnabled is a boolean\n        contextMenuEnabled = !!contextMenuEnabled;\n        var i;\n        var selected = this.selectedAtoms(sel, this.atoms);\n        var len = selected.length;\n        for (i = 0; i < len; i++) {\n            selected[i].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] };\n            selected[i].contextMenuEnabled = contextMenuEnabled;\n        }\n        if (len > 0)\n            this.molObj = null; // force rebuild to get correct intersection shapes\n    }\n    ;\n    /** given a mapping from element to color, set atom colors\n     *\n     * @param {AtomSelectionSpec} sel\n     * @param {object} colors\n     */\n    setColorByElement(sel, colors) {\n        if (this.molObj !== null && GLModel.sameObj(colors, this.lastColors))\n            return; // don't recompute\n        this.lastColors = colors;\n        var atoms = this.selectedAtoms(sel, atoms);\n        if (atoms.length > 0)\n            this.molObj = null; // force rebuild\n        for (var i = 0; i < atoms.length; i++) {\n            var a = atoms[i];\n            if (typeof (colors[a.elem]) !== \"undefined\") {\n                a.color = colors[a.elem];\n            }\n        }\n    }\n    ;\n    /**\n     * @param {AtomSelectionSpec} sel\n     * @param {string} prop\n     * @param {Gradient|string} scheme\n     */\n    setColorByProperty(sel, prop, scheme, range) {\n        var i, a;\n        var atoms = this.selectedAtoms(sel, atoms);\n        this.lastColors = null; // don't bother memoizing\n        if (atoms.length > 0)\n            this.molObj = null; // force rebuild\n        if (typeof scheme === 'string' && typeof (_Gradient__WEBPACK_IMPORTED_MODULE_7__.Gradient.builtinGradients[scheme]) != \"undefined\") {\n            scheme = new _Gradient__WEBPACK_IMPORTED_MODULE_7__.Gradient.builtinGradients[scheme]();\n        }\n        scheme = scheme;\n        if (!range) { //no explicit range, get from scheme\n            range = scheme.range();\n        }\n        if (!range) { //no range in scheme, compute the range for this model\n            range = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getPropertyRange)(atoms, prop);\n        }\n        // now apply colors using scheme\n        for (i = 0; i < atoms.length; i++) {\n            a = atoms[i];\n            var val = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getAtomProperty)(a, prop);\n            if (val != null) {\n                a.color = scheme.valueToHex(parseFloat(a.properties[prop]), range);\n            }\n        }\n    }\n    ;\n    /**\n     * @deprecated use setStyle and colorfunc attribute\n     * @param {AtomSelectionSpec} sel - selection object\n     * @param {function} func - function to be used to set the color\n     @example\n      $3Dmol.download(\"pdb:4UAA\",viewer,{},function(){\n              viewer.setBackgroundColor(0xffffffff);\n              var colorAsSnake = function(atom) {\n                return atom.resi % 2 ? 'white': 'green'\n              };\n\n              viewer.setStyle( {}, { cartoon: {colorfunc: colorAsSnake }});\n\n              viewer.render();\n          });\n\n     */\n    setColorByFunction(sel, colorfun) {\n        var atoms = this.selectedAtoms(sel, atoms);\n        if (typeof (colorfun) !== 'function')\n            return;\n        this.lastColors = null; // don't bother memoizing\n        if (atoms.length > 0)\n            this.molObj = null; // force rebuild\n        // now apply colorfun\n        for (let i = 0; i < atoms.length; i++) {\n            let a = atoms[i];\n            a.color = colorfun(a);\n        }\n    }\n    ;\n    /** Convert the model into an object in the format of a ChemDoodle JSON model.\n     *\n     * @param {boolean} whether or not to include style information. Defaults to false.\n     * @return {Object}\n     */\n    toCDObject(includeStyles = false) {\n        var out = { a: [], b: [] };\n        if (includeStyles) {\n            out.s = [];\n        }\n        for (let i = 0; i < this.atoms.length; i++) {\n            let atomJSON = {};\n            let atom = this.atoms[i];\n            atomJSON.x = atom.x;\n            atomJSON.y = atom.y;\n            atomJSON.z = atom.z;\n            if (atom.elem != \"C\") {\n                atomJSON.l = atom.elem;\n            }\n            if (includeStyles) {\n                var s = 0;\n                while (s < out.s.length &&\n                    (JSON.stringify(atom.style) !== JSON.stringify(out.s[s]))) {\n                    s++;\n                }\n                if (s === out.s.length) {\n                    out.s.push(atom.style);\n                }\n                if (s !== 0) {\n                    atomJSON.s = s;\n                }\n            }\n            out.a.push(atomJSON);\n            for (let b = 0; b < atom.bonds.length; b++) {\n                let firstAtom = i;\n                let secondAtom = atom.bonds[b];\n                if (firstAtom >= secondAtom)\n                    continue;\n                let bond = {\n                    b: firstAtom,\n                    e: secondAtom\n                };\n                let bondOrder = atom.bondOrder[b];\n                if (bondOrder != 1) {\n                    bond.o = bondOrder;\n                }\n                out.b.push(bond);\n            }\n        }\n        return out;\n    }\n    ;\n    /** manage the globj for this model in the possed modelGroup - if it has to be regenerated, remove and add\n     *\n     * @param {Object3D} group\n     * @param Object options\n     */\n    globj(group, options) {\n        if (this.molObj === null || options.regen) { // have to regenerate\n            this.molObj = this.createMolObj(this.atoms, options);\n            if (this.renderedMolObj) { // previously rendered, remove\n                group.remove(this.renderedMolObj);\n                this.renderedMolObj = null;\n            }\n            this.renderedMolObj = this.molObj.clone();\n            if (this.hidden) {\n                this.renderedMolObj.setVisible(false);\n                this.molObj.setVisible(false);\n            }\n            group.add(this.renderedMolObj);\n        }\n    }\n    ;\n    /** return a VRML string representation of the model.  Does not include VRML header information\n     * @return VRML\n     */\n    exportVRML() {\n        //todo: export spheres and cylinder objects instead of all mesh\n        var tmpobj = this.createMolObj(this.atoms, { supportsImposters: false, supportsAIA: false });\n        return tmpobj.vrml();\n    }\n    ;\n    /** Remove any renderable mol object from scene\n     *\n     * @param {Object3D} group\n     */\n    removegl(group) {\n        if (this.renderedMolObj) {\n            //dispose of geos and materials\n            if (this.renderedMolObj.geometry !== undefined)\n                this.renderedMolObj.geometry.dispose();\n            if (this.renderedMolObj.material !== undefined)\n                this.renderedMolObj.material.dispose();\n            group.remove(this.renderedMolObj);\n            this.renderedMolObj = null;\n        }\n        this.molObj = null;\n    }\n    ;\n    /**\n     * Don't show this model in future renderings. Keep all styles and state\n     * so it can be efficiencly shown again.\n     *\n     * * @see GLModel#show\n\n     * @example\n        $3Dmol.download(\"pdb:3ucr\",viewer,{},function(){\n        viewer.setStyle({},{stick:{}});\n        viewer.getModel().hide();\n        viewer.render();\n        });\n     */\n    hide() {\n        this.hidden = true;\n        if (this.renderedMolObj)\n            this.renderedMolObj.setVisible(false);\n        if (this.molObj)\n            this.molObj.setVisible(false);\n    }\n    ;\n    /**\n     * Unhide a hidden model\n     * @see GLModel#hide\n     * @example\n        $3Dmol.download(\"pdb:3ucr\",viewer,{},function(){\n        viewer.setStyle({},{stick:{}});\n        viewer.getModel().hide();\n        viewer.render(  )\n        viewer.getModel().show()\n        viewer.render();\n        });\n     */\n    show() {\n        this.hidden = false;\n        if (this.renderedMolObj)\n            this.renderedMolObj.setVisible(true);\n        if (this.molObj)\n            this.molObj.setVisible(true);\n    }\n    ;\n    /** Create labels for atoms that show the value of the passed property.\n     *\n     * @param {String} prop - property name\n     * @param {AtomSelectionSpec} sel\n     * @param {GLViewer} viewer\n     * @param {LabelSpec} options\n     */\n    addPropertyLabels(prop, sel, viewer, style) {\n        var atoms = this.selectedAtoms(sel, atoms);\n        var mystyle = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.deepCopy)(style);\n        for (var i = 0; i < atoms.length; i++) {\n            var a = atoms[i];\n            var label = null;\n            if (typeof (a[prop]) != 'undefined') {\n                label = String(a[prop]);\n            }\n            else if (typeof (a.properties[prop]) != 'undefined') {\n                label = String(a.properties[prop]);\n            }\n            if (label != null) {\n                mystyle.position = a;\n                viewer.addLabel(label, mystyle);\n            }\n        }\n    }\n    ;\n    /** Create labels for residues of selected atoms.\n     * Will create a single label at the center of mass of all atoms\n     * with the same chain,resn, and resi.\n     *\n     * @param {AtomSelectionSpec} sel\n     * @param {GLViewer} viewer\n     * @param {LabelSpec} options\n     * @param {boolean} byframe - if true, create labels for every individual frame, not just current; frames must be loaded already\n     */\n    addResLabels(sel, viewer, style, byframe = false) {\n        var created_labels = [];\n        var helper = function (model, framenum) {\n            var atoms = model.selectedAtoms(sel, atoms);\n            var bylabel = {};\n            //collect by chain:resn:resi\n            for (var i = 0; i < atoms.length; i++) {\n                var a = atoms[i];\n                var c = a.chain;\n                var resn = a.resn;\n                var resi = a.resi;\n                var label = resn + '' + resi;\n                if (!bylabel[c])\n                    bylabel[c] = {};\n                if (!bylabel[c][label])\n                    bylabel[c][label] = [];\n                bylabel[c][label].push(a);\n            }\n            var mystyle = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.deepCopy)(style);\n            //now compute centers of mass\n            for (let c in bylabel) {\n                if (bylabel.hasOwnProperty(c)) {\n                    var labels = bylabel[c];\n                    for (let label in labels) {\n                        if (labels.hasOwnProperty(label)) {\n                            let atoms = labels[label];\n                            let sum = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n                            for (let i = 0; i < atoms.length; i++) {\n                                let a = atoms[i];\n                                sum.x += a.x;\n                                sum.y += a.y;\n                                sum.z += a.z;\n                            }\n                            sum.divideScalar(atoms.length);\n                            mystyle.position = sum;\n                            mystyle.frame = framenum;\n                            let l = viewer.addLabel(label, mystyle, undefined, true);\n                            created_labels.push(l);\n                        }\n                    }\n                }\n            }\n        };\n        if (byframe) {\n            var n = this.getNumFrames();\n            let savedatoms = this.atoms;\n            for (let i = 0; i < n; i++) {\n                if (this.frames[i]) {\n                    this.atoms = this.frames[i];\n                    helper(this, i);\n                }\n            }\n            this.atoms = savedatoms;\n        }\n        else {\n            helper(this);\n        }\n        return created_labels;\n    }\n    ;\n    //recurse over the current atoms to establish a depth first order\n    setupDFS() {\n        this.atomdfs = [];\n        var self = this;\n        var visited = new Int8Array(this.atoms.length);\n        visited.fill(0);\n        var search = function (i, prev, component) {\n            //add i to component and recursive explore connected atoms\n            component.push([i, prev]);\n            var atom = self.atoms[i];\n            visited[i] = 1;\n            for (var b = 0; b < atom.bonds.length; b++) {\n                var nexti = atom.bonds[b];\n                if (self.atoms[nexti] && !visited[nexti]) {\n                    search(nexti, i, component);\n                }\n            }\n        };\n        for (var i = 0; i < this.atoms.length; i++) {\n            var atom = this.atoms[i];\n            if (atom && !visited[i]) {\n                var component = [];\n                search(i, -1, component);\n                this.atomdfs.push(component);\n            }\n        }\n    }\n    ;\n    /**\n    * Set coordinates from remote trajectory file.\n    * @param {string} url - contains the url where mdsrv has been hosted\n    * @param {string} path - contains the path of the file (<root>/filename)\n    * @return {Promise}\n    */\n    setCoordinatesFromURL(url, path) {\n        this.frames = [];\n        var self = this;\n        if (this.box)\n            this.setupDFS();\n        if (!url.startsWith('http'))\n            url = 'http://' + url;\n        return (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.get)(url + \"/traj/numframes/\" + path, function (numFrames) {\n            if (!isNaN(parseInt(numFrames))) {\n                self.frames.push(self.atoms);\n                self.frames.numFrames = numFrames;\n                self.frames.url = url;\n                self.frames.path = path;\n                return self.setFrame(0);\n            }\n        });\n    }\n    ;\n    /**\n    * Set coordinates for the atoms from provided trajectory file.\n    * @param {string|ArrayBuffer} str - contains the data of the file\n    * @param {string} format - contains the format of the file (mdcrd, inpcrd, pdb, netcdf, or array).  Arrays should be TxNx3 where T is the number of timesteps and N the number of atoms.\n      @example\n         let m = viewer.addModel()  //create an empty model\n         m.addAtoms([{x:0,y:0,z:0,elem:'C'},{x:2,y:0,z:0,elem:'C'}]) //provide a list of dictionaries representing the atoms\n         viewer.setStyle({'sphere':{}})\n         m.setCoordinates([[[0.0, 0.0, 0.0], [2.0, 0.0, 0.0]], [[0.0, 0.0, 0.0], [2.8888888359069824, 0.0, 0.0]], [[0.0, 0.0, 0.0], [3.777777671813965, 0.0, 0.0]], [[0.0, 0.0, 0.0], [4.666666507720947, 0.0, 0.0]], [[0.0, 0.0, 0.0], [5.55555534362793, 0.0, 0.0]], [[0.0, 0.0, 0.0], [6.44444465637207, 0.0, 0.0]], [[0.0, 0.0, 0.0], [7.333333492279053, 0.0, 0.0]], [[0.0, 0.0, 0.0], [8.222222328186035, 0.0, 0.0]], [[0.0, 0.0, 0.0], [9.11111068725586, 0.0, 0.0]], [[0.0, 0.0, 0.0], [10.0, 0.0, 0.0]]],'array');\n         viewer.animate({loop: \"forward\",reps: 1});\n         viewer.zoomTo();\n         viewer.zoom(0.5);\n         viewer.render();\n    */\n    setCoordinates(str, format) {\n        format = format || \"\";\n        if (!str)\n            return []; // leave an empty model\n        if (/\\.gz$/.test(format)) {\n            // unzip gzipped files\n            format = format.replace(/\\.gz$/, '');\n            try {\n                str = inflateString(str);\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        var supportedFormats = { \"mdcrd\": \"\", \"inpcrd\": \"\", \"pdb\": \"\", \"netcdf\": \"\", \"array\": \"\" };\n        if (supportedFormats.hasOwnProperty(format)) {\n            this.frames = [];\n            var atomCount = this.atoms.length;\n            var values = GLModel.parseCrd(str, format);\n            var count = 0;\n            while (count < values.length) {\n                var temp = [];\n                for (var i = 0; i < atomCount; i++) {\n                    var newAtom = {};\n                    for (var k in this.atoms[i]) {\n                        newAtom[k] = this.atoms[i][k];\n                    }\n                    temp[i] = newAtom;\n                    temp[i].x = values[count++];\n                    temp[i].y = values[count++];\n                    temp[i].z = values[count++];\n                }\n                this.frames.push(temp);\n            }\n            this.atoms = this.frames[0];\n            return this.frames;\n        }\n        return [];\n    }\n    ;\n    /**\n     * add atomSpecs to validAtomSelectionSpecs\n     * @deprecated\n     * @param {Array} customAtomSpecs - array of strings that can be used as atomSelectionSpecs\n     * this is to prevent the 'Unknown Selector x' message on the console for the strings passed.\n     * These messages are no longer generated as, in theory, typescript will catch problems at compile time.\n     * In practice, there may still be issues at run-time but we don't check for them...\n     *\n     * What we should do is use something like https://github.com/woutervh-/typescript-is to do runtime\n     * type checking, but it currently doesn't work with our types...\n     */\n    addAtomSpecs(customAtomSpecs) {\n    }\n    ;\n    static parseCrd(data, format) {\n        var values = []; // this will contain the all the float values in the\n        // file.\n        var counter = 0;\n        if (format == \"pdb\") {\n            var index = data.indexOf(\"\\nATOM\");\n            while (index != -1) {\n                while (data.slice(index, index + 5) == \"\\nATOM\" ||\n                    data.slice(index, index + 7) == \"\\nHETATM\") {\n                    values[counter++] = parseFloat(data.slice(index + 31, index + 39));\n                    values[counter++] = parseFloat(data.slice(index + 39, index + 47));\n                    values[counter++] = parseFloat(data.slice(index + 47, index + 55));\n                    index = data.indexOf(\"\\n\", index + 54);\n                    if (data.slice(index, index + 4) == \"\\nTER\")\n                        index = data.indexOf(\"\\n\", index + 5);\n                }\n                index = data.indexOf(\"\\nATOM\", index);\n            }\n        }\n        else if (format == \"netcdf\") {\n            var reader = new netcdfjs__WEBPACK_IMPORTED_MODULE_9__.NetCDFReader(data);\n            values = [].concat.apply([], reader.getDataVariable('coordinates'));\n        }\n        else if (format == \"array\" || Array.isArray(data)) {\n            return data.flat(2);\n        }\n        else {\n            let index = data.indexOf(\"\\n\"); // remove the first line containing title\n            if (format == 'inpcrd') {\n                index = data.indexOf(\"\\n\", index + 1); //remove second line w/#atoms\n            }\n            data = data.slice(index + 1);\n            values = data.match(/\\S+/g).map(parseFloat);\n        }\n        return values;\n    }\n    ;\n    static parseMolData(data, format = \"\", options) {\n        if (!data)\n            return []; //leave an empty model\n        if (/\\.gz$/.test(format)) {\n            //unzip gzipped files\n            format = format.replace(/\\.gz$/, '');\n            try {\n                data = inflateString(data);\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        if (typeof (_parsers__WEBPACK_IMPORTED_MODULE_8__.Parsers[format]) == \"undefined\") {\n            // let someone provide a file name and get format from extension\n            format = format.split('.').pop();\n            if (typeof (_parsers__WEBPACK_IMPORTED_MODULE_8__.Parsers[format]) == \"undefined\") {\n                console.log(\"Unknown format: \" + format);\n                // try to guess correct format from data contents\n                if (data instanceof Uint8Array) {\n                    format = \"mmtf\"; //currently only supported binary format?\n                }\n                else if (data.match(/^@<TRIPOS>MOLECULE/gm)) {\n                    format = \"mol2\";\n                }\n                else if (data.match(/^data_/gm) && data.match(/^loop_/gm)) {\n                    format = \"cif\";\n                }\n                else if (data.match(/^HETATM/gm) || data.match(/^ATOM/gm)) {\n                    format = \"pdb\";\n                }\n                else if (data.match(/ITEM: TIMESTEP/gm)) {\n                    format = \"lammpstrj\";\n                }\n                else if (data.match(/^.*\\n.*\\n.\\s*(\\d+)\\s+(\\d+)/gm)) {\n                    format = \"sdf\"; // could look at line 3\n                }\n                else if (data.match(/^%VERSION\\s+VERSION_STAMP/gm)) {\n                    format = \"prmtop\";\n                }\n                else {\n                    format = \"xyz\";\n                }\n                console.log(\"Best guess: \" + format);\n            }\n        }\n        var parse = _parsers__WEBPACK_IMPORTED_MODULE_8__.Parsers[format];\n        var parsedAtoms = parse(data, options);\n        return parsedAtoms;\n    }\n    ;\n}\n// class variables go here\nGLModel.defaultAtomStyle = {\n    line: {}\n};\nGLModel.defaultlineWidth = 1.0;\n// Reference: A. Bondi, J. Phys. Chem., 1964, 68, 441.\n// https://en.wikipedia.org/wiki/Van_der_Waals_radius\nGLModel.vdwRadii = {\n    \"H\": 1.2,\n    \"He\": 1.4,\n    \"Li\": 1.82,\n    \"Be\": 1.53,\n    \"B\": 1.92,\n    \"C\": 1.7,\n    \"N\": 1.55,\n    \"O\": 1.52,\n    \"F\": 1.47,\n    \"Ne\": 1.54,\n    \"Na\": 2.27,\n    \"Mg\": 1.73,\n    \"Al\": 1.84,\n    \"Si\": 2.1,\n    \"P\": 1.8,\n    \"S\": 1.8,\n    \"Cl\": 1.75,\n    \"Ar\": 1.88,\n    \"K\": 2.75,\n    \"Ca\": 2.31,\n    \"Ni\": 1.63,\n    \"Cu\": 1.4,\n    \"Zn\": 1.39,\n    \"Ga\": 1.87,\n    \"Ge\": 2.11,\n    \"As\": 1.85,\n    \"Se\": 1.9,\n    \"Br\": 1.85,\n    \"Kr\": 2.02,\n    \"Rb\": 3.03,\n    \"Sr\": 2.49,\n    \"Pd\": 1.63,\n    \"Ag\": 1.72,\n    \"Cd\": 1.58,\n    \"In\": 1.93,\n    \"Sn\": 2.17,\n    \"Sb\": 2.06,\n    \"Te\": 2.06,\n    \"I\": 1.98,\n    \"Xe\": 2.16,\n    \"Cs\": 3.43,\n    \"Ba\": 2.68,\n    \"Pt\": 1.75,\n    \"Au\": 1.66,\n    \"Hg\": 1.55,\n    \"Tl\": 1.96,\n    \"Pb\": 2.02,\n    \"Bi\": 2.07,\n    \"Po\": 1.97,\n    \"At\": 2.02,\n    \"Rn\": 2.20,\n    \"Fr\": 3.48,\n    \"Ra\": 2.83,\n    \"U\": 1.86\n};\nGLModel.ignoredKeys = new Set([\"props\", \"invert\", \"model\", \"frame\", \"byres\", \"expand\", \"within\", \"and\", \"or\", \"not\"]);\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/GLModel.ts?");

/***/ }),

/***/ "./src/GLShape.ts":
/*!************************!*\
  !*** ./src/GLShape.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLShape: () => (/* binding */ GLShape),\n/* harmony export */   splitMesh: () => (/* binding */ splitMesh)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGL/shapes */ \"./src/WebGL/shapes/index.ts\");\n/* harmony import */ var _WebGL_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGL/math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _ProteinSurface4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ProteinSurface4 */ \"./src/ProteinSurface4.ts\");\n/* harmony import */ var _VolumeData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VolumeData */ \"./src/VolumeData.ts\");\n/* harmony import */ var _GLDraw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GLDraw */ \"./src/GLDraw.ts\");\n/* harmony import */ var _glcartoon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./glcartoon */ \"./src/glcartoon.ts\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A GLShape is a collection of user specified shapes.\n *\n * @class\n * @extends {ShapeSpec}\n * @param {number} sid - Unique identifier\n * @param {ShapeSpec} stylespec - shape style specification\n */\nclass GLShape {\n    static finalizeGeo(geo) {\n        //to avoid creating a bunch of geometries, we leave geoGroup untruncated\n        //until render is called, at which point we truncate; \n        //successive called up updateGeo will return a new geometry\n        var geoGroup = geo.updateGeoGroup(0);\n        if (geoGroup.vertices > 0) {\n            geoGroup.truncateArrayBuffers(true, true);\n        }\n    }\n    ;\n    /*\n     *\n     * @param {Geometry}\n     *            geo\n     * @param {Color | colorlike} color\n     */\n    static updateColor(geo, color) {\n        color = color || _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(color);\n        geo.colorsNeedUpdate = true;\n        var r, g, b;\n        if (color.constructor !== Array) {\n            r = color.r;\n            g = color.g;\n            b = color.b;\n        }\n        for (let gg in geo.geometryGroups) {\n            let geoGroup = geo.geometryGroups[gg];\n            let colorArr = geoGroup.colorArray;\n            for (let i = 0, il = geoGroup.vertices; i < il; ++i) {\n                if (color.constructor === Array) {\n                    let c = color[i];\n                    r = c.r;\n                    g = c.g;\n                    b = c.b;\n                }\n                colorArr[i * 3] = r;\n                colorArr[i * 3 + 1] = g;\n                colorArr[i * 3 + 2] = b;\n            }\n        }\n    }\n    ;\n    /*\n     * @param {GLShape}\n     *            shape\n     * @param {geometryGroup}\n     *            geoGroup\n     * @param {ArrowSpec}\n     *            spec\n     */\n    static drawArrow(shape, geo, spec) {\n        var from = spec.start, end = spec.end, radius = spec.radius, radiusRatio = spec.radiusRatio, mid = spec.mid, midoffset = spec.midpos;\n        if (!(from && end))\n            return;\n        var geoGroup = geo.updateGeoGroup(51);\n        // vertices\n        var dir = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(end.x, end.y, end.z).sub(from);\n        if (midoffset) { //absolute offset, convert to relative\n            let length = dir.length();\n            if (midoffset > 0)\n                mid = midoffset / length;\n            else\n                mid = (length + midoffset) / length;\n        }\n        dir.multiplyScalar(mid);\n        var to = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z).add(dir);\n        var negDir = dir.clone().negate();\n        let fromv = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(from.x, from.y, from.z);\n        shape.intersectionShape.cylinder.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(fromv, to.clone(), radius));\n        shape.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(fromv, radius));\n        // get orthonormal vector\n        var nvecs = [];\n        nvecs[0] = dir.clone();\n        if (Math.abs(nvecs[0].x) > 0.0001)\n            nvecs[0].y += 1;\n        else\n            nvecs[0].x += 1;\n        nvecs[0].cross(dir);\n        nvecs[0].normalize();\n        // another orth vector\n        nvecs[4] = nvecs[0].clone();\n        nvecs[4].crossVectors(nvecs[0], dir);\n        nvecs[4].normalize();\n        nvecs[8] = nvecs[0].clone().negate();\n        nvecs[12] = nvecs[4].clone().negate();\n        // now quarter positions\n        nvecs[2] = nvecs[0].clone().add(nvecs[4]).normalize();\n        nvecs[6] = nvecs[4].clone().add(nvecs[8]).normalize();\n        nvecs[10] = nvecs[8].clone().add(nvecs[12]).normalize();\n        nvecs[14] = nvecs[12].clone().add(nvecs[0]).normalize();\n        // eights\n        nvecs[1] = nvecs[0].clone().add(nvecs[2]).normalize();\n        nvecs[3] = nvecs[2].clone().add(nvecs[4]).normalize();\n        nvecs[5] = nvecs[4].clone().add(nvecs[6]).normalize();\n        nvecs[7] = nvecs[6].clone().add(nvecs[8]).normalize();\n        nvecs[9] = nvecs[8].clone().add(nvecs[10]).normalize();\n        nvecs[11] = nvecs[10].clone().add(nvecs[12]).normalize();\n        nvecs[13] = nvecs[12].clone().add(nvecs[14]).normalize();\n        nvecs[15] = nvecs[14].clone().add(nvecs[0]).normalize();\n        var start = geoGroup.vertices;\n        var vertexArray = geoGroup.vertexArray;\n        var faceArray = geoGroup.faceArray;\n        var normalArray = geoGroup.normalArray;\n        var lineArray = geoGroup.lineArray;\n        var offset, i, n;\n        // add vertices, opposing vertices paired together\n        for (i = 0, n = nvecs.length; i < n; ++i) {\n            offset = 3 * (start + 3 * i);\n            var bottom = nvecs[i].clone().multiplyScalar(radius).add(from);\n            var top = nvecs[i].clone().multiplyScalar(radius).add(to);\n            var conebase = nvecs[i].clone()\n                .multiplyScalar(radius * radiusRatio).add(to);\n            vertexArray[offset] = bottom.x;\n            vertexArray[offset + 1] = bottom.y;\n            vertexArray[offset + 2] = bottom.z;\n            vertexArray[offset + 3] = top.x;\n            vertexArray[offset + 4] = top.y;\n            vertexArray[offset + 5] = top.z;\n            vertexArray[offset + 6] = conebase.x;\n            vertexArray[offset + 7] = conebase.y;\n            vertexArray[offset + 8] = conebase.z;\n            if (i > 0) {\n                var prev_x = vertexArray[offset - 3];\n                var prev_y = vertexArray[offset - 2];\n                var prev_z = vertexArray[offset - 1];\n                var c = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(prev_x, prev_y, prev_z);\n                var b = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(end.x, end.y, end.z), b2 = to.clone();\n                var a = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(conebase.x, conebase.y, conebase.z);\n                shape.intersectionShape.triangle.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(a, b, c));\n                shape.intersectionShape.triangle.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(c.clone(), b2, a.clone()));\n            }\n        }\n        geoGroup.vertices += 48;\n        offset = geoGroup.vertices * 3;\n        // caps\n        vertexArray[offset] = from.x;\n        vertexArray[offset + 1] = from.y;\n        vertexArray[offset + 2] = from.z;\n        vertexArray[offset + 3] = to.x;\n        vertexArray[offset + 4] = to.y;\n        vertexArray[offset + 5] = to.z;\n        vertexArray[offset + 6] = end.x;\n        vertexArray[offset + 7] = end.y;\n        vertexArray[offset + 8] = end.z;\n        geoGroup.vertices += 3;\n        // now faces\n        var face, faceoffset, lineoffset;\n        var t1, t2, t2b, t3, t3b, t4, t1offset, t2offset, t2boffset, t3offset, t3boffset, t4offset;\n        var n1, n2, n3, n4;\n        var fromi = geoGroup.vertices - 3, toi = geoGroup.vertices - 2, endi = geoGroup.vertices - 1;\n        var fromoffset = fromi * 3, tooffset = toi * 3, endoffset = endi * 3;\n        for (i = 0, n = nvecs.length - 1; i < n; ++i) {\n            var ti = start + 3 * i;\n            offset = ti * 3;\n            faceoffset = geoGroup.faceidx;\n            lineoffset = geoGroup.lineidx;\n            t1 = ti;\n            t1offset = t1 * 3;\n            t2 = ti + 1;\n            t2offset = t2 * 3;\n            t2b = ti + 2;\n            t2boffset = t2b * 3;\n            t3 = ti + 4;\n            t3offset = t3 * 3;\n            t3b = ti + 5;\n            t3boffset = t3b * 3;\n            t4 = ti + 3;\n            t4offset = t4 * 3;\n            // face = [t1, t2, t4], [t2, t3, t4];\n            // face = [t1, t2, t3, t4];\n            //   norm = [nvecs[i], nvecs[i], nvecs[i + 1], nvecs[i + 1]];\n            n1 = n2 = nvecs[i];\n            n3 = n4 = nvecs[i + 1];\n            normalArray[t1offset] = n1.x;\n            normalArray[t2offset] = n2.x;\n            normalArray[t4offset] = n4.x;\n            normalArray[t1offset + 1] = n1.y;\n            normalArray[t2offset + 1] = n2.y;\n            normalArray[t4offset + 1] = n4.y;\n            normalArray[t1offset + 2] = n1.z;\n            normalArray[t2offset + 2] = n2.z;\n            normalArray[t4offset + 2] = n4.z;\n            normalArray[t2offset] = n2.x;\n            normalArray[t3offset] = n3.x;\n            normalArray[t4offset] = n4.x;\n            normalArray[t2offset + 1] = n2.y;\n            normalArray[t3offset + 1] = n3.y;\n            normalArray[t4offset + 1] = n4.y;\n            normalArray[t2offset + 2] = n2.z;\n            normalArray[t3offset + 2] = n3.z;\n            normalArray[t4offset + 2] = n4.z;\n            normalArray[t2boffset] = n2.x;\n            normalArray[t3boffset] = n3.x;\n            normalArray[t2boffset + 1] = n2.y;\n            normalArray[t3boffset + 1] = n3.y;\n            normalArray[t2boffset + 2] = n2.z;\n            normalArray[t3boffset + 2] = n3.z;\n            // sides\n            faceArray[faceoffset] = t1;\n            faceArray[faceoffset + 1] = t2;\n            faceArray[faceoffset + 2] = t4;\n            faceArray[faceoffset + 3] = t2;\n            faceArray[faceoffset + 4] = t3;\n            faceArray[faceoffset + 5] = t4;\n            // caps\n            faceArray[faceoffset + 6] = t1;\n            faceArray[faceoffset + 7] = t4;\n            faceArray[faceoffset + 8] = fromi;\n            faceArray[faceoffset + 9] = t2b;\n            faceArray[faceoffset + 10] = toi;\n            faceArray[faceoffset + 11] = t3b;\n            // arrowhead\n            faceArray[faceoffset + 12] = t2b;\n            faceArray[faceoffset + 13] = endi;\n            faceArray[faceoffset + 14] = t3b;\n            // sides\n            lineArray[lineoffset] = t1;\n            lineArray[lineoffset + 1] = t2;\n            lineArray[lineoffset + 2] = t1;\n            lineArray[lineoffset + 3] = t4;\n            // lineArray[lineoffset+4] = t2, lineArray[lineoffset+5] = t3;\n            lineArray[lineoffset + 4] = t3;\n            lineArray[lineoffset + 5] = t4;\n            // caps\n            lineArray[lineoffset + 6] = t1;\n            lineArray[lineoffset + 7] = t4;\n            // lineArray[lineoffset+10] = t1, lineArray[lineoffset+11] = fromi;\n            // lineArray[lineoffset+12] = t4, lineArray[lineoffset+13] = fromi;\n            lineArray[lineoffset + 8] = t2b;\n            lineArray[lineoffset + 9] = t2; // toi\n            lineArray[lineoffset + 10] = t2b;\n            lineArray[lineoffset + 11] = t3b;\n            lineArray[lineoffset + 12] = t3;\n            lineArray[lineoffset + 13] = t3b; // toi\n            // arrowhead\n            lineArray[lineoffset + 14] = t2b;\n            lineArray[lineoffset + 15] = endi;\n            lineArray[lineoffset + 16] = t2b;\n            lineArray[lineoffset + 17] = t3b;\n            lineArray[lineoffset + 18] = endi;\n            lineArray[lineoffset + 19] = t3b;\n            geoGroup.faceidx += 15;\n            geoGroup.lineidx += 20;\n        }\n        // final face\n        face = [start + 45, start + 46, start + 1, start, start + 47,\n            start + 2];\n        //norm = [nvecs[15], nvecs[15], nvecs[0], nvecs[0]];\n        faceoffset = geoGroup.faceidx;\n        lineoffset = geoGroup.lineidx;\n        t1 = face[0];\n        t1offset = t1 * 3;\n        t2 = face[1];\n        t2offset = t2 * 3;\n        t2b = face[4];\n        t2boffset = t2b * 3;\n        t3 = face[2];\n        t3offset = t3 * 3;\n        t3b = face[5];\n        t3boffset = t3b * 3;\n        t4 = face[3];\n        t4offset = t4 * 3;\n        n1 = n2 = nvecs[15];\n        n3 = n4 = nvecs[0];\n        normalArray[t1offset] = n1.x;\n        normalArray[t2offset] = n2.x;\n        normalArray[t4offset] = n4.x;\n        normalArray[t1offset + 1] = n1.y;\n        normalArray[t2offset + 1] = n2.y;\n        normalArray[t4offset + 1] = n4.y;\n        normalArray[t1offset + 2] = n1.z;\n        normalArray[t2offset + 2] = n2.z;\n        normalArray[t4offset + 2] = n4.z;\n        normalArray[t2offset] = n2.x;\n        normalArray[t3offset] = n3.x;\n        normalArray[t4offset] = n4.x;\n        normalArray[t2offset + 1] = n2.y;\n        normalArray[t3offset + 1] = n3.y;\n        normalArray[t4offset + 1] = n4.y;\n        normalArray[t2offset + 2] = n2.z;\n        normalArray[t3offset + 2] = n3.z;\n        normalArray[t4offset + 2] = n4.z;\n        normalArray[t2boffset] = n2.x;\n        normalArray[t3boffset] = n3.x;\n        normalArray[t2boffset + 1] = n2.y;\n        normalArray[t3boffset + 1] = n3.y;\n        normalArray[t2boffset + 2] = n2.z;\n        normalArray[t3boffset + 2] = n3.z;\n        // Cap normals\n        dir.normalize();\n        negDir.normalize();\n        normalArray[fromoffset] = negDir.x;\n        normalArray[tooffset] = normalArray[endoffset] = dir.x;\n        normalArray[fromoffset + 1] = negDir.y;\n        normalArray[tooffset + 1] = normalArray[endoffset + 1] = dir.y;\n        normalArray[fromoffset + 2] = negDir.z;\n        normalArray[tooffset + 2] = normalArray[endoffset + 2] = dir.z;\n        // Final side\n        faceArray[faceoffset] = t1;\n        faceArray[faceoffset + 1] = t2;\n        faceArray[faceoffset + 2] = t4;\n        faceArray[faceoffset + 3] = t2;\n        faceArray[faceoffset + 4] = t3;\n        faceArray[faceoffset + 5] = t4;\n        // final caps\n        faceArray[faceoffset + 6] = t1;\n        faceArray[faceoffset + 7] = t4;\n        faceArray[faceoffset + 8] = fromi;\n        faceArray[faceoffset + 9] = t2b;\n        faceArray[faceoffset + 10] = toi;\n        faceArray[faceoffset + 11] = t3b;\n        // final arrowhead\n        faceArray[faceoffset + 12] = t2b;\n        faceArray[faceoffset + 13] = endi;\n        faceArray[faceoffset + 14] = t3b;\n        // sides\n        lineArray[lineoffset] = t1;\n        lineArray[lineoffset + 1] = t2;\n        lineArray[lineoffset + 2] = t1;\n        lineArray[lineoffset + 3] = t4;\n        // lineArray[lineoffset+4] = t2, lineArray[lineoffset+5] = t3;\n        lineArray[lineoffset + 4] = t3;\n        lineArray[lineoffset + 5] = t4;\n        // caps\n        lineArray[lineoffset + 6] = t1;\n        lineArray[lineoffset + 7] = t4;\n        // lineArray[lineoffset+10] = t1, lineArray[lineoffset+11] = fromi;\n        // lineArray[lineoffset+12] = t4, lineArray[lineoffset+13] = fromi;\n        lineArray[lineoffset + 8] = t2b;\n        lineArray[lineoffset + 9] = t2; // toi\n        lineArray[lineoffset + 10] = t2b;\n        lineArray[lineoffset + 11] = t3b;\n        lineArray[lineoffset + 12] = t3;\n        lineArray[lineoffset + 13] = t3b; // toi\n        // arrowhead\n        lineArray[lineoffset + 14] = t2b;\n        lineArray[lineoffset + 15] = endi;\n        lineArray[lineoffset + 16] = t2b;\n        lineArray[lineoffset + 17] = t3b;\n        lineArray[lineoffset + 18] = endi;\n        lineArray[lineoffset + 19] = t3b;\n        geoGroup.faceidx += 15;\n        geoGroup.lineidx += 20;\n    }\n    ;\n    // Update a bounding sphere's position and radius\n    // from list of centroids and new points\n    /*\n     * @param {Sphere}\n     *            sphere\n     * @param {Object}\n     *            components, centroid of all objects in shape\n     * @param {Array}\n     *            points, flat array of all points in shape\n     * @param {int} numPoints, number of valid poitns in points\n     */\n    static updateBoundingFromPoints(sphere, components, points, numPoints) {\n        sphere.center.set(0, 0, 0);\n        //previously I weighted each component's center equally, but I think\n        //it is better to use all points\n        let xmin = Infinity, ymin = Infinity, zmin = Infinity;\n        let xmax = -Infinity, ymax = -Infinity, zmax = -Infinity;\n        if (sphere.box) {\n            xmin = sphere.box.min.x;\n            xmax = sphere.box.max.x;\n            ymin = sphere.box.min.y;\n            ymax = sphere.box.max.y;\n            zmin = sphere.box.min.z;\n            zmax = sphere.box.max.z;\n        }\n        for (let i = 0, il = numPoints; i < il; i++) {\n            var x = points[i * 3], y = points[i * 3 + 1], z = points[i * 3 + 2];\n            if (x < xmin)\n                xmin = x;\n            if (y < ymin)\n                ymin = y;\n            if (z < zmin)\n                zmin = z;\n            if (x > xmax)\n                xmax = x;\n            if (y > ymax)\n                ymax = y;\n            if (z > zmax)\n                zmax = z;\n        }\n        sphere.center.set((xmax + xmin) / 2, (ymax + ymin) / 2, (zmax + zmin) / 2);\n        sphere.radius = sphere.center.distanceTo({ x: xmax, y: ymax, z: zmax });\n        sphere.box = { min: { x: xmin, y: ymin, z: zmin }, max: { x: xmax, y: ymax, z: zmax } };\n    }\n    ;\n    //helper function for adding an appropriately sized mesh\n    static addCustomGeo(shape, geo, mesh, color, clickable) {\n        var geoGroup = geo.addGeoGroup();\n        var vertexArr = mesh.vertexArr, normalArr = mesh.normalArr, faceArr = mesh.faceArr;\n        geoGroup.vertices = vertexArr.length;\n        geoGroup.faceidx = faceArr.length;\n        var offset, v, a, b, c, i, il, r, g;\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        if (color.constructor !== Array) {\n            r = color.r;\n            g = color.g;\n            b = color.b;\n        }\n        for (i = 0, il = geoGroup.vertices; i < il; ++i) {\n            offset = i * 3;\n            v = vertexArr[i];\n            vertexArray[offset] = v.x;\n            vertexArray[offset + 1] = v.y;\n            vertexArray[offset + 2] = v.z;\n            if (color.constructor === Array) {\n                c = color[i];\n                r = c.r;\n                g = c.g;\n                b = c.b;\n            }\n            colorArray[offset] = r;\n            colorArray[offset + 1] = g;\n            colorArray[offset + 2] = b;\n        }\n        if (clickable) {\n            for (i = 0, il = geoGroup.faceidx / 3; i < il; ++i) {\n                offset = i * 3;\n                a = faceArr[offset];\n                b = faceArr[offset + 1];\n                c = faceArr[offset + 2];\n                var vA = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(), vB = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(), vC = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n                shape.intersectionShape.triangle.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(vA.copy(vertexArr[a]), vB.copy(vertexArr[b]), vC.copy(vertexArr[c])));\n            }\n        }\n        if (clickable) {\n            var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n            var cnt = 0;\n            for (let g = 0; g < geo.geometryGroups.length; g++) {\n                center.add(geo.geometryGroups[g].getCentroid());\n                cnt++;\n            }\n            center.divideScalar(cnt);\n            GLShape.updateBoundingFromPoints(shape.boundingSphere, { centroid: center }, vertexArray, geoGroup.vertices);\n        }\n        geoGroup.faceArray = new Uint16Array(faceArr);\n        geoGroup.truncateArrayBuffers(true, true);\n        if (normalArr.length < geoGroup.vertices)\n            geoGroup.setNormals();\n        else {\n            var normalArray = geoGroup.normalArray = new Float32Array(geoGroup.vertices * 3);\n            var n;\n            for (i = 0, il = geoGroup.vertices; i < il; ++i) {\n                offset = i * 3;\n                n = normalArr[i];\n                normalArray[offset] = n.x;\n                normalArray[offset + 1] = n.y;\n                normalArray[offset + 2] = n.z;\n            }\n        }\n        geoGroup.setLineIndices();\n        geoGroup.lineidx = geoGroup.lineArray.length;\n    }\n    ;\n    /*\n     *\n     * @param {$3Dmol.GLShape}\n     *            shape\n     * @param {ShapeSpec}\n     *            stylespec\n     * @returns {undefined}\n     */\n    static updateFromStyle(shape, stylespec) {\n        if (typeof (stylespec.color) != 'undefined') {\n            shape.color = stylespec.color || new _colors__WEBPACK_IMPORTED_MODULE_3__.Color();\n            if (!(stylespec.color instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color))\n                shape.color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(stylespec.color);\n        }\n        else {\n            shape.color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(0);\n        }\n        shape.wireframe = stylespec.wireframe ? true : false;\n        //opacity is the preferred nomenclature, support alpha for backwards compat\n        shape.opacity = stylespec.alpha ? (0,_WebGL_math__WEBPACK_IMPORTED_MODULE_2__.clamp)(stylespec.alpha, 0.0, 1.0) : 1.0;\n        if (typeof (stylespec.opacity) != 'undefined') {\n            shape.opacity = (0,_WebGL_math__WEBPACK_IMPORTED_MODULE_2__.clamp)(stylespec.opacity, 0.0, 1.0);\n        }\n        shape.side = (stylespec.side !== undefined) ? stylespec.side : _WebGL__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        shape.linewidth = typeof (stylespec.linewidth) == 'undefined' ? 1 : stylespec.linewidth;\n        // Click handling\n        shape.clickable = stylespec.clickable ? true : false;\n        shape.callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_8__.makeFunction)(stylespec.callback);\n        shape.hoverable = stylespec.hoverable ? true : false;\n        shape.hover_callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_8__.makeFunction)(stylespec.hover_callback);\n        shape.unhover_callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_8__.makeFunction)(stylespec.unhover_callback);\n        shape.contextMenuEnabled = !!stylespec.contextMenuEnabled;\n        shape.hidden = stylespec.hidden;\n        shape.frame = stylespec.frame;\n    }\n    ;\n    /**\n     * Custom renderable shape\n     *\n     * @constructor\n     *\n     * @param {ShapeSpec} stylespec\n     */\n    constructor(stylespec) {\n        this.color = 0xffffff;\n        this.hidden = false;\n        this.wireframe = false;\n        this.opacity = 1;\n        this.linewidth = 1;\n        this.clickable = false;\n        this.hoverable = false;\n        this.contextMenuEnabled = false;\n        this.side = _WebGL__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        this.stylespec = stylespec || {};\n        this.boundingSphere = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere();\n        /** @type {IntersectionShapes} */\n        this.intersectionShape = {\n            sphere: [],\n            cylinder: [],\n            line: [],\n            triangle: []\n        };\n        GLShape.updateFromStyle(this, this.stylespec);\n        // Keep track of shape components and their centroids\n        this.components = [];\n        this.shapeObj = null;\n        this.renderedShapeObj = null;\n        this.geo = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);\n        this.linegeo = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);\n    }\n    ;\n    /** Update shape with new style specification\n     * @param {ShapeSpec} newspec\n       @example\n        let sphere = viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});\n        sphere.updateStyle({color:'yellow',opacity:0.5});\n        viewer.render();\n     */\n    updateStyle(newspec) {\n        for (var prop in newspec) {\n            this.stylespec[prop] = newspec[prop];\n        }\n        GLShape.updateFromStyle(this, this.stylespec);\n        if (newspec.voldata && newspec.volscheme) {\n            (0,_utilities__WEBPACK_IMPORTED_MODULE_8__.adjustVolumeStyle)(newspec);\n            //convert volumetric data into colors\n            const scheme = newspec.volscheme;\n            const voldata = newspec.voldata;\n            const cc = _colors__WEBPACK_IMPORTED_MODULE_3__.CC;\n            const range = scheme.range() || [-1, 1];\n            this.geo.setColors(function (x, y, z) {\n                let val = voldata.getVal(x, y, z);\n                let col = cc.color(scheme.valueToHex(val, range));\n                return col;\n            });\n            delete this.color;\n        }\n    }\n    ;\n    /**\n     * Creates a custom shape from supplied vertex and face arrays\n     * @param {CustomShapeSpec} customSpec\n     */\n    addCustom(customSpec) {\n        customSpec.vertexArr = customSpec.vertexArr || [];\n        customSpec.faceArr = customSpec.faceArr || [];\n        customSpec.normalArr = customSpec.normalArr || [];\n        // will split mesh as needed\n        GLShape.drawCustom(this, this.geo, customSpec);\n    }\n    ;\n    /**\n     * Creates a sphere shape\n     * @param {SphereSpec} sphereSpec\n     @example\n     viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});\n     \n     viewer.render();\n     */\n    addSphere(sphereSpec) {\n        if (!sphereSpec.center) {\n            sphereSpec.center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        }\n        sphereSpec.radius = sphereSpec.radius ? (0,_WebGL_math__WEBPACK_IMPORTED_MODULE_2__.clamp)(sphereSpec.radius, 0, Infinity) : 1.5;\n        sphereSpec.color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(sphereSpec.color);\n        this.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(sphereSpec.center, sphereSpec.radius));\n        _GLDraw__WEBPACK_IMPORTED_MODULE_6__.GLDraw.drawSphere(this.geo, sphereSpec.center, sphereSpec.radius, sphereSpec.color, sphereSpec.quality);\n        this.components.push({\n            centroid: new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(sphereSpec.center.x, sphereSpec.center.y, sphereSpec.center.z)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);\n    }\n    ;\n    /**\n     * Creates a box\n     * @param {BoxSpec} boxSpec\n     @example\n     var shape = viewer.addShape({color:'red'});\n     shape.addBox({corner: {x:1,y:2,z:0}, dimensions: {w: 4, h: 2, d: 6}});\n     shape.addBox({corner: {x:-5,y:-3,z:0},\n                   dimensions: { w: {x:1,y:1,z:0},\n                                 h: {x:-1,y:1,z:0},\n                                 d: {x:0,y:0,z:1} }});\n     viewer.zoomTo();\n     viewer.rotate(30);\n     viewer.render();\n     */\n    addBox(boxSpec) {\n        var dim = boxSpec.dimensions || { w: 1, h: 1, d: 1 };\n        //dimensions may be scalar or vector quantities\n        var w;\n        if (typeof (dim.w) == \"number\") {\n            w = { x: dim.w, y: 0, z: 0 };\n        }\n        else {\n            w = dim.w;\n        }\n        var h;\n        if (typeof (dim.h) == \"number\") {\n            h = { x: 0, y: dim.h, z: 0 };\n        }\n        else {\n            h = dim.h;\n        }\n        var d;\n        if (typeof (dim.d) == \"number\") {\n            d = { x: 0, y: 0, z: dim.d };\n        }\n        else {\n            d = dim.d;\n        }\n        //can position using corner OR center\n        var c = boxSpec.corner;\n        if (c == undefined) {\n            if (boxSpec.center !== undefined) {\n                c = {\n                    x: boxSpec.center.x - 0.5 * (w.x + h.x + d.x),\n                    y: boxSpec.center.y - 0.5 * (w.y + h.y + d.y),\n                    z: boxSpec.center.z - 0.5 * (w.z + h.z + d.z)\n                };\n            }\n            else { // default to origin\n                c = { x: 0, y: 0, z: 0 };\n            }\n        }\n        //8 vertices\n        var uv = [{ x: c.x, y: c.y, z: c.z },\n            { x: c.x + w.x, y: c.y + w.y, z: c.z + w.z },\n            { x: c.x + h.x, y: c.y + h.y, z: c.z + h.z },\n            { x: c.x + w.x + h.x, y: c.y + w.y + h.y, z: c.z + w.z + h.z },\n            { x: c.x + d.x, y: c.y + d.y, z: c.z + d.z },\n            { x: c.x + w.x + d.x, y: c.y + w.y + d.y, z: c.z + w.z + d.z },\n            { x: c.x + h.x + d.x, y: c.y + h.y + d.y, z: c.z + h.z + d.z },\n            { x: c.x + w.x + h.x + d.x, y: c.y + w.y + h.y + d.y, z: c.z + w.z + h.z + d.z }];\n        //but.. so that we can have sharp issues, we want a unique normal\n        //for each face - since normals are associated with vertices, need to duplicate \n        //bottom\n        // 0 1\n        // 2 3\n        //top\n        // 4 5\n        // 6 7\n        var verts = [];\n        var faces = [];\n        //bottom\n        verts.splice(verts.length, 0, uv[0], uv[1], uv[2], uv[3]);\n        faces.splice(faces.length, 0, 0, 2, 1, 1, 2, 3);\n        var foff = 4;\n        //front\n        verts.splice(verts.length, 0, uv[2], uv[3], uv[6], uv[7]);\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        //back\n        verts.splice(verts.length, 0, uv[4], uv[5], uv[0], uv[1]);\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        //top\n        verts.splice(verts.length, 0, uv[6], uv[7], uv[4], uv[5]);\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        //right\n        verts.splice(verts.length, 0, uv[3], uv[1], uv[7], uv[5]);\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        //left\n        verts.splice(verts.length, 0, uv[2], uv[6], uv[0], uv[4]); // fix: was 2 0 6 4 , was flipped! will this ruin anything?\n        // and is this the reason for having double sided lambert shading? the box had a flipped face\n        faces.splice(faces.length, 0, foff + 0, foff + 2, foff + 1, foff + 1, foff + 2, foff + 3);\n        foff += 4;\n        var spec = (0,_utilities__WEBPACK_IMPORTED_MODULE_8__.extend)({}, boxSpec);\n        spec.vertexArr = verts;\n        spec.faceArr = faces;\n        spec.normalArr = [];\n        GLShape.drawCustom(this, this.geo, spec);\n        var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(uv[0], uv[7]).multiplyScalar(0.5)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);\n    }\n    ;\n    /**\n     * Creates a cylinder shape\n     * @param {CylinderSpec} cylinderSpec\n     @example\n          viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},\n                              end:{x:10.0,y:0.0,z:0.0},\n                              radius:1.0,\n                              fromCap:1,\n                              toCap:2,\n                              color:'red',\n                              hoverable:true,\n                              clickable:true,\n                              callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},\n                              hover_callback: function(){ viewer.render( );},\n                              unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}\n                             });\n          viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},\n                              end:{x:0.0,y:10.0,z:0.0},\n                              radius:0.5,\n                              fromCap:false,\n                              toCap:true,\n                              color:'teal'});\n          viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},\n                              end:{x:20.0,y:0.0,z:0.0},\n                              radius:1.0,\n                              color:'black',\n                              fromCap:false,\n                              toCap:false});\n          viewer.render();\n     */\n    addCylinder(cylinderSpec) {\n        var start;\n        var end;\n        if (!cylinderSpec.start) {\n            start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        }\n        else {\n            start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.start.x || 0, cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);\n        }\n        if (!cylinderSpec.end) {\n            end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        }\n        else {\n            end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.end.x, cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);\n            if (typeof (end.x) == 'undefined')\n                end.x = 3; //show something even if undefined\n        }\n        var radius = cylinderSpec.radius || 0.1;\n        var color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(cylinderSpec.color);\n        this.intersectionShape.cylinder.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(start, end, radius));\n        _GLDraw__WEBPACK_IMPORTED_MODULE_6__.GLDraw.drawCylinder(this.geo, start, end, radius, color, cylinderSpec.fromCap, cylinderSpec.toCap);\n        var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(start, end).multiplyScalar(0.5)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);\n    }\n    ;\n    /**\n     * Creates a dashed cylinder shape\n     * @param {CylinderSpec} cylinderSpec\n     */\n    addDashedCylinder(cylinderSpec) {\n        cylinderSpec.dashLength = cylinderSpec.dashLength || 0.25;\n        cylinderSpec.gapLength = cylinderSpec.gapLength || 0.25;\n        var start;\n        if (!cylinderSpec.start)\n            start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        else {\n            start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.start.x || 0, cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);\n        }\n        var end;\n        if (!cylinderSpec.end)\n            end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(3, 0, 0);\n        else {\n            end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.end.x, cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);\n            if (typeof (end.x) == 'undefined')\n                end.x = 3; //show something even if undefined\n        }\n        var radius = cylinderSpec.radius || 0.1;\n        var color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(cylinderSpec.color);\n        var cylinderLength = Math.sqrt(Math.pow((start.x - end.x), 2) + Math.pow((start.y - end.y), 2) + Math.pow((start.z - end.z), 2));\n        var count = cylinderLength / (cylinderSpec.gapLength + cylinderSpec.dashLength);\n        var new_start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.start.x || 0, cylinderSpec.start.y || 0, cylinderSpec.start.z || 0);\n        var new_end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(cylinderSpec.end.x, cylinderSpec.end.y || 0, cylinderSpec.end.z || 0);\n        var gapVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((end.x - start.x) / (cylinderLength / cylinderSpec.gapLength), (end.y - start.y) / (cylinderLength / cylinderSpec.gapLength), (end.z - start.z) / (cylinderLength / cylinderSpec.gapLength));\n        var dashVector = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3((end.x - start.x) / (cylinderLength / cylinderSpec.dashLength), (end.y - start.y) / (cylinderLength / cylinderSpec.dashLength), (end.z - start.z) / (cylinderLength / cylinderSpec.dashLength));\n        for (var place = 0; place < count; place++) {\n            new_end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(new_start.x + dashVector.x, new_start.y + dashVector.y, new_start.z + dashVector.z);\n            this.intersectionShape.cylinder.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder(new_start, new_end, radius));\n            _GLDraw__WEBPACK_IMPORTED_MODULE_6__.GLDraw.drawCylinder(this.geo, new_start, new_end, radius, color, cylinderSpec.fromCap, cylinderSpec.toCap);\n            new_start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(new_end.x + gapVector.x, new_end.y + gapVector.y, new_end.z + gapVector.z);\n        }\n        var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(start, end).multiplyScalar(0.5)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);\n    }\n    ;\n    /**\n     * Creates a curved shape\n     * @param {CurveSpec} curveSpec\n     */\n    addCurve(curveSpec) {\n        curveSpec.points = curveSpec.points || [];\n        curveSpec.smooth = curveSpec.smooth || 10;\n        if (typeof (curveSpec.fromCap) == \"undefined\")\n            curveSpec.fromCap = 2;\n        if (typeof (curveSpec.toCap) == \"undefined\")\n            curveSpec.toCap = 2;\n        //subdivide into smoothed spline points\n        var points = (0,_glcartoon__WEBPACK_IMPORTED_MODULE_7__.subdivide_spline)(curveSpec.points, curveSpec.smooth);\n        if (points.length < 3) {\n            console.log(\"Too few points in addCurve\");\n            return;\n        }\n        var radius = curveSpec.radius || 0.1;\n        var color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(curveSpec.color);\n        //TODO TODO - this is very inefficient, should create our\n        //own water tight model with proper normals...\n        //if arrows are requested, peel off enough points to fit\n        //at least 2*r of arrowness\n        var start = 0;\n        var end = points.length - 1;\n        var segmentlen = points[0].distanceTo(points[1]);\n        var npts = Math.ceil(2 * radius / segmentlen);\n        if (curveSpec.toArrow) {\n            end -= npts;\n            let arrowspec = {\n                start: points[end],\n                end: points[points.length - 1],\n                radius: radius,\n                color: color,\n                mid: 0.0001\n            };\n            this.addArrow(arrowspec);\n        }\n        if (curveSpec.fromArrow) {\n            start += npts;\n            let arrowspec = {\n                start: points[start],\n                end: points[0],\n                radius: radius,\n                color: color,\n                mid: 0.0001\n            };\n            this.addArrow(arrowspec);\n        }\n        var midway = Math.ceil(points.length / 2);\n        var middleSpec = { radius: radius, color: color, fromCap: 2, toCap: 2 };\n        for (var i = start; i < end; i++) {\n            middleSpec.start = points[i];\n            middleSpec.end = points[i + 1];\n            middleSpec.fromCap = 2;\n            middleSpec.toCap = 2;\n            if (i < midway) {\n                middleSpec.fromCap = 2;\n                middleSpec.toCap = 0;\n            }\n            else if (i > midway) {\n                middleSpec.fromCap = 0;\n                middleSpec.toCap = 2;\n            }\n            else {\n                middleSpec.fromCap = 2;\n                middleSpec.toCap = 2;\n            }\n            this.addCylinder(middleSpec);\n        }\n    }\n    ;\n    /**\n     * Creates a line shape\n     * @param {LineSpec} lineSpec\n     @example\n     $3Dmol.download(\"pdb:2ABJ\",viewer,{},function(){\n              viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});\n              viewer.render(callback);\n          });\n    \n     */\n    addLine(lineSpec) {\n        var start;\n        var end;\n        if (!lineSpec.start) {\n            start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        }\n        else {\n            start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(lineSpec.start.x || 0, lineSpec.start.y || 0, lineSpec.start.z || 0);\n        }\n        if (!lineSpec.end) {\n            end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(3, 0, 0);\n        }\n        else {\n            end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(lineSpec.end.x, lineSpec.end.y || 0, lineSpec.end.z || 0);\n            if (typeof (end.x) == 'undefined')\n                end.x = 3; //show something even if undefined\n        }\n        var geoGroup = this.geo.updateGeoGroup(2);\n        //make line from start to end\n        //for consistency with rest of shapes, uses vertices and lines rather\n        //than a separate line geometry\n        var vstart = geoGroup.vertices;\n        var i = vstart * 3;\n        var vertexArray = geoGroup.vertexArray;\n        vertexArray[i] = start.x;\n        vertexArray[i + 1] = start.y;\n        vertexArray[i + 2] = start.z;\n        vertexArray[i + 3] = end.x;\n        vertexArray[i + 4] = end.y;\n        vertexArray[i + 5] = end.z;\n        geoGroup.vertices += 2;\n        var lineArray = geoGroup.lineArray;\n        var li = geoGroup.lineidx;\n        lineArray[li] = vstart;\n        lineArray[li + 1] = vstart + 1;\n        geoGroup.lineidx += 2;\n        var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(start, end).multiplyScalar(0.5)\n        });\n        geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);\n    }\n    ;\n    /**\n     * Creates an arrow shape\n     * @param {ArrowSpec} arrowSpec\n     @example\n      $3Dmol.download(\"pdb:4DM7\",viewer,{},function(){\n              viewer.setBackgroundColor(0xffffffff);\n              viewer.addArrow({\n                  start: {x:-10.0, y:0.0, z:0.0},\n                  end: {x:0.0, y:-10.0, z:0.0},\n                  radius: 1.0,\n                  radiusRadio:1.0,\n                  mid:1.0,\n                  clickable:true,\n                  callback:function(){\n                      this.color.setHex(0xFF0000FF);\n                      viewer.render( );\n                  }\n              });\n              viewer.render();\n            });\n     */\n    addArrow(arrowSpec) {\n        if (!arrowSpec.start) {\n            arrowSpec.start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        }\n        else {\n            arrowSpec.start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(arrowSpec.start.x || 0, arrowSpec.start.y || 0, arrowSpec.start.z || 0);\n        }\n        if (arrowSpec.dir instanceof _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3 && typeof (arrowSpec.length) === 'number') {\n            var end = arrowSpec.dir.clone().multiplyScalar(arrowSpec.length).add(arrowSpec.start);\n            arrowSpec.end = end;\n        }\n        else if (!arrowSpec.end) {\n            arrowSpec.end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(3, 0, 0);\n        }\n        else {\n            arrowSpec.end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(arrowSpec.end.x, arrowSpec.end.y || 0, arrowSpec.end.z || 0);\n            if (typeof (arrowSpec.end.x) == 'undefined')\n                arrowSpec.end.x = 3; //show something even if undefined\n        }\n        arrowSpec.radius = arrowSpec.radius || 0.1;\n        arrowSpec.radiusRatio = arrowSpec.radiusRatio || 1.618034;\n        arrowSpec.mid = (0 < arrowSpec.mid && arrowSpec.mid < 1) ? arrowSpec.mid\n            : 0.618034;\n        GLShape.drawArrow(this, this.geo, arrowSpec);\n        var centroid = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.components.push({\n            centroid: centroid.addVectors(arrowSpec.start, arrowSpec.end)\n                .multiplyScalar(0.5)\n        });\n        var geoGroup = this.geo.updateGeoGroup(0);\n        GLShape.updateBoundingFromPoints(this.boundingSphere, this.components, geoGroup.vertexArray, geoGroup.vertices);\n    }\n    ;\n    static distance_from(c1, c2) {\n        return Math.sqrt(Math.pow((c1.x - c2.x), 2) + Math.pow((c1.y - c2.y), 2) + Math.pow((c1.z - c2.z), 2));\n    }\n    ;\n    static inSelectedRegion(coordinate, selectedRegion, radius) {\n        for (var i = 0; i < selectedRegion.length; i++) {\n            if (GLShape.distance_from(selectedRegion[i], coordinate) <= radius)\n                return true;\n        }\n        return false;\n    }\n    ;\n    /**\n     * Create isosurface from volumetric data.\n     * @param {VolumeData} data - volumetric input data\n     * @param {IsoSurfaceSpec} isoSpec - volumetric data shape specification\n     * @example //the user can specify a selected region for the isosurface\n     $.get('../test_structs/benzene-homo.cube', function(data){\n              var voldata = new $3Dmol.VolumeData(data, \"cube\");\n              viewer.addIsosurface(voldata, {isoval: 0.01,\n                                             color: \"blue\",\n                                             alpha: 0.5,\n                                             smoothness: 10});\n              viewer.addIsosurface(voldata, {isoval: -0.01,\n                                             color: \"red\",\n                                             smoothness: 5,\n                                             opacity:0.5,\n                                             wireframe:true,\n                                             clickable:true,\n                                             callback:\n                                             function() {\n                                                 this.opacity = 0.0;\n                                                 viewer.render( );\n                                             }});\n              viewer.setStyle({}, {stick:{}});\n              viewer.zoomTo();\n              viewer.render();\n            });\n     */\n    addIsosurface(data, volSpec, callback, viewer) {\n        var isoval = (volSpec.isoval !== undefined && typeof (volSpec.isoval) === \"number\") ? volSpec.isoval\n            : 0.0;\n        var voxel = (volSpec.voxel) ? true : false;\n        var smoothness = (volSpec.smoothness === undefined) ? 1 : volSpec.smoothness;\n        var nX = data.size.x;\n        var nY = data.size.y;\n        var nZ = data.size.z;\n        var vertnums = new Int16Array(nX * nY * nZ);\n        var vals = data.data;\n        var i, il;\n        for (i = 0, il = vertnums.length; i < il; ++i)\n            vertnums[i] = -1;\n        var bitdata = new Uint8Array(nX * nY * nZ);\n        //mark locations partitioned by isoval\n        for (i = 0, il = vals.length; i < il; ++i) {\n            var val = (isoval >= 0) ? vals[i] - isoval : isoval - vals[i];\n            if (val > 0)\n                bitdata[i] |= GLShape.ISDONE;\n        }\n        var verts = [], faces = [];\n        _ProteinSurface4__WEBPACK_IMPORTED_MODULE_4__.MarchingCube.march(bitdata, verts, faces, {\n            fulltable: true,\n            voxel: voxel,\n            unitCube: data.unit,\n            origin: data.origin,\n            matrix: data.matrix,\n            nX: nX,\n            nY: nY,\n            nZ: nZ\n        });\n        if (!voxel && smoothness > 0)\n            _ProteinSurface4__WEBPACK_IMPORTED_MODULE_4__.MarchingCube.laplacianSmooth(smoothness, verts, faces);\n        var vertexmapping = [];\n        var newvertices = [];\n        var newfaces = [];\n        if (volSpec.selectedRegion && volSpec.coords === undefined) {\n            volSpec.coords = volSpec.selectedRegion; //backwards compat for incorrectly documented feature\n        }\n        if (volSpec.coords === undefined && volSpec.selection !== undefined) {\n            if (!viewer) {\n                console.log(\"addIsosurface needs viewer is selection provided.\");\n            }\n            else {\n                volSpec.coords = viewer.selectedAtoms(volSpec.selection);\n            }\n        }\n        if (volSpec.coords !== undefined) {\n            var xmax = volSpec.coords[0].x, ymax = volSpec.coords[0].y, zmax = volSpec.coords[0].z, xmin = volSpec.coords[0].x, ymin = volSpec.coords[0].y, zmin = volSpec.coords[0].z;\n            for (let i = 0; i < volSpec.coords.length; i++) {\n                if (volSpec.coords[i].x > xmax)\n                    xmax = volSpec.coords[i].x;\n                else if (volSpec.coords[i].x < xmin)\n                    xmin = volSpec.coords[i].x;\n                if (volSpec.coords[i].y > ymax)\n                    ymax = volSpec.coords[i].y;\n                else if (volSpec.coords[i].y < ymin)\n                    ymin = volSpec.coords[i].y;\n                if (volSpec.coords[i].z > zmax)\n                    zmax = volSpec.coords[i].z;\n                else if (volSpec.coords[i].z < zmin)\n                    zmin = volSpec.coords[i].z;\n            }\n            var rad = 2;\n            if (volSpec.radius !== undefined) {\n                rad = volSpec.radius; //backwards compat\n            }\n            if (volSpec.selectedOffset !== undefined) { //backwards compat\n                rad = volSpec.selectedOffset;\n            }\n            if (volSpec.seldist !== undefined) {\n                rad = volSpec.seldist;\n            }\n            xmin -= rad;\n            xmax += rad;\n            ymin -= rad;\n            ymax += rad;\n            zmin -= rad;\n            zmax += rad;\n            // accounts for radius\n            for (let i = 0; i < verts.length; i++) {\n                if (verts[i].x > xmin &&\n                    verts[i].x < xmax &&\n                    verts[i].y > ymin &&\n                    verts[i].y < ymax &&\n                    verts[i].z > zmin &&\n                    verts[i].z < zmax &&\n                    GLShape.inSelectedRegion(verts[i], volSpec.coords, rad)) {\n                    vertexmapping.push(newvertices.length);\n                    newvertices.push(verts[i]);\n                }\n                else {\n                    vertexmapping.push(-1);\n                }\n            }\n            for (let i = 0; i + 2 < faces.length; i += 3) {\n                if (vertexmapping[faces[i]] !== -1 &&\n                    vertexmapping[faces[i + 1]] !== -1 &&\n                    vertexmapping[faces[i + 2]] !== -1) {\n                    newfaces.push(faces[i] - (faces[i] - vertexmapping[faces[i]]));\n                    newfaces.push(faces[i + 1] - (faces[i + 1] - vertexmapping[faces[i + 1]]));\n                    newfaces.push(faces[i + 2] - (faces[i + 2] - vertexmapping[faces[i + 2]]));\n                }\n            }\n            verts = newvertices;\n            faces = newfaces;\n        }\n        GLShape.drawCustom(this, this.geo, {\n            vertexArr: verts,\n            faceArr: faces,\n            normalArr: [],\n            clickable: volSpec.clickable,\n            hoverable: volSpec.hoverable\n        });\n        this.updateStyle(volSpec);\n        //computing bounding sphere from vertices\n        var origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(data.origin.x, data.origin.y, data.origin.z);\n        var size = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(data.size.x * data.unit.x, data.size.y * data.unit.y, data.size.z * data.unit.z);\n        var total = new _WebGL_math__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        var maxv = origin.clone();\n        var minv = origin.clone().add(size);\n        for (let i = 0; i < verts.length; i++) {\n            total.add(verts[i]);\n            maxv.max(verts[i]);\n            minv.min(verts[i]);\n        }\n        total.divideScalar(verts.length);\n        var len1 = total.distanceTo(minv);\n        var len2 = total.distanceTo(maxv);\n        this.boundingSphere.center = total;\n        this.boundingSphere.radius = Math.max(len1, len2);\n        if (typeof callback == \"function\")\n            callback();\n    }\n    ;\n    /**\n     * @deprecated Use addIsosurface instead\n     * Creates custom shape from volumetric data\n     * @param {string} data - Volumetric input data\n     * @param {string} fmt - Input data format (e.g. 'cube' for cube file format)\n     * @param {IsoSurfaceSpec} isoSpec - Volumetric data shape specification\n     */\n    addVolumetricData(data, fmt, volSpec) {\n        data = new _VolumeData__WEBPACK_IMPORTED_MODULE_5__.VolumeData(data, fmt);\n        this.addIsosurface(data, volSpec);\n    }\n    ;\n    //for internal use, truncate buffers to save memory\n    finalize() {\n        GLShape.finalizeGeo(this.geo);\n        this.geo.initTypedArrays();\n        return this.geo;\n    }\n    ;\n    /*\n     * Initialize webgl objects for rendering\n     * @param {$3Dmol.Object3D} group\n     *\n     */\n    globj(group) {\n        if (this.renderedShapeObj) {\n            group.remove(this.renderedShapeObj);\n            this.renderedShapeObj = null;\n        }\n        if (this.hidden)\n            return;\n        GLShape.finalizeGeo(this.geo);\n        this.geo.initTypedArrays();\n        if (this.wireframe) {\n            this.geo.setUpWireframe();\n        }\n        if (typeof (this.color) != 'undefined')\n            GLShape.updateColor(this.geo, this.color);\n        this.shapeObj = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n        var material = null;\n        if (this.side == _WebGL__WEBPACK_IMPORTED_MODULE_0__.DoubleSide) {\n            material = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshDoubleLambertMaterial({\n                wireframe: this.wireframe,\n                side: this.side,\n                transparent: (this.opacity < 1) ? true : false,\n                opacity: this.opacity,\n                wireframeLinewidth: this.linewidth,\n                vertexColors: _WebGL__WEBPACK_IMPORTED_MODULE_0__.Coloring.VertexColors\n            });\n        }\n        else {\n            material = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial({\n                wireframe: this.wireframe,\n                side: this.side,\n                transparent: (this.opacity < 1) ? true : false,\n                opacity: this.opacity,\n                wireframeLinewidth: this.linewidth,\n                vertexColors: _WebGL__WEBPACK_IMPORTED_MODULE_0__.Coloring.VertexColors\n            });\n        }\n        var mesh = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geo, material);\n        this.shapeObj.add(mesh);\n        var lineMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({\n            linewidth: this.linewidth,\n            color: this.color\n        });\n        var line = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Line(this.linegeo, lineMaterial, _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineStyle.LinePieces);\n        this.shapeObj.add(line);\n        this.renderedShapeObj = this.shapeObj.clone();\n        group.add(this.renderedShapeObj);\n    }\n    ;\n    removegl(group) {\n        if (this.renderedShapeObj) {\n            // dispose of geos and materials\n            if (this.renderedShapeObj.geometry !== undefined)\n                this.renderedShapeObj.geometry.dispose();\n            if (this.renderedShapeObj.material !== undefined)\n                this.renderedShapeObj.material.dispose();\n            group.remove(this.renderedShapeObj);\n            this.renderedShapeObj = null;\n        }\n        this.shapeObj = null;\n    }\n    ;\n    get position() {\n        return this.boundingSphere.center;\n    }\n    get x() {\n        return this.boundingSphere.center.x;\n    }\n    get y() {\n        return this.boundingSphere.center.y;\n    }\n    get z() {\n        return this.boundingSphere.center.z;\n    }\n}\n// Marching cube, to match with protein surface generation\nGLShape.ISDONE = 2;\n// handles custom shape generation from user supplied arrays\n// May need to generate normal and/or line indices\n/*\n * @param {$3Dmol.GLShape}\n *            shape\n * @param {geometry}\n *            geo\n * @param {CustomShapeSpec}\n *            customSpec\n */\nGLShape.drawCustom = function (shape, geo, customSpec) {\n    var mesh = customSpec;\n    var vertexArr = mesh.vertexArr;\n    var faceArr = mesh.faceArr;\n    if (vertexArr.length === 0 || faceArr.length === 0) {\n        console\n            .warn(\"Error adding custom shape component: No vertices and/or face indices supplied!\");\n    }\n    var color = customSpec.color;\n    if (typeof (color) == 'undefined') {\n        color = shape.color;\n    }\n    color = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(color);\n    //var firstgeo = geo.geometryGroups.length;\n    var splits = splitMesh(mesh);\n    for (var i = 0, n = splits.length; i < n; i++) {\n        GLShape.addCustomGeo(shape, geo, splits[i], splits[i].colorArr ? splits[i].colorArr : color, customSpec.clickable);\n    }\n};\n;\nfunction splitMesh(mesh) {\n    var MAXVERT = 64000; //webgl only supports 2^16 elements, leave a little breathing room (require at least 2)\n    //peel off 64k vertices rsvh into their own mesh\n    //duplicating vertices and normals as necessary to preserve faces and lines\n    if (mesh.vertexArr.length < MAXVERT)\n        return [mesh]; //typical case\n    var slices = [{ vertexArr: [], normalArr: [], faceArr: [] }];\n    if (mesh.colorArr)\n        slices.colorArr = [];\n    var vertSlice = []; //indexed by original vertex to get current slice\n    var vertIndex = []; //indexed by original vertex to get index within slice\n    var currentSlice = 0;\n    //for each face, make sure all three vertices (or copies) are in the same slice\n    var faces = mesh.faceArr;\n    for (let i = 0, nf = faces.length; i < nf; i += 3) {\n        let slice = slices[currentSlice];\n        for (let j = 0; j < 3; j++) {\n            //process each vertex to make sure it is assigned a slice\n            //all vertices of a face must belong to the same slice\n            var v = faces[i + j];\n            if (vertSlice[v] !== currentSlice) { //true if undefined\n                vertSlice[v] = currentSlice;\n                vertIndex[v] = slice.vertexArr.length;\n                slice.vertexArr.push(mesh.vertexArr[v]);\n                if (mesh.normalArr && mesh.normalArr[v])\n                    slice.normalArr.push(mesh.normalArr[v]);\n                if (mesh.colorArr && mesh.colorArr[v])\n                    slice.colorArr.push(mesh.colorArr[v]);\n            }\n            slice.faceArr.push(vertIndex[v]);\n        }\n        if (slice.vertexArr.length >= MAXVERT) {\n            //new slice\n            slices.push({ vertexArr: [], normalArr: [], faceArr: [] });\n            if (mesh.colorArr)\n                slices.colorArr = [];\n            currentSlice++;\n        }\n    }\n    return slices;\n}\n;\n;\n;\n;\n;\n;\n;\n;\n;\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/GLShape.ts?");

/***/ }),

/***/ "./src/GLViewer.ts":
/*!*************************!*\
  !*** ./src/GLViewer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLViewer: () => (/* binding */ GLViewer),\n/* harmony export */   createStereoViewer: () => (/* binding */ createStereoViewer),\n/* harmony export */   createViewer: () => (/* binding */ createViewer),\n/* harmony export */   createViewerGrid: () => (/* binding */ createViewerGrid)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _WebGL_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGL/math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.ts\");\n/* harmony import */ var _Gradient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Gradient */ \"./src/Gradient.ts\");\n/* harmony import */ var _GLModel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GLModel */ \"./src/GLModel.ts\");\n/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Label */ \"./src/Label.ts\");\n/* harmony import */ var _GLShape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GLShape */ \"./src/GLShape.ts\");\n/* harmony import */ var _VolumeData__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./VolumeData */ \"./src/VolumeData.ts\");\n/* harmony import */ var _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ProteinSurface4 */ \"./src/ProteinSurface4.ts\");\n/* harmony import */ var _VolumetricRender__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./VolumetricRender */ \"./src/VolumetricRender.ts\");\n/* harmony import */ var upng_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! upng-js */ \"./node_modules/upng-js/UPNG.js\");\n/* harmony import */ var upng_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(upng_js__WEBPACK_IMPORTED_MODULE_11__);\n//a molecular viewer based on GLMol\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * WebGL-based 3Dmol.js viewer\n * Note: The preferred method of instantiating a GLViewer is through {@link createViewer}\n *\n * @class\n*/\nclass GLViewer {\n    getWidth() {\n        let div = this.container;\n        //offsetwidth accounts for scaling\n        let w = div.offsetWidth;\n        if (w == 0 && div.style.display === 'none') {\n            let oldpos = div.style.position;\n            let oldvis = div.style.visibility;\n            div.style.display = 'block';\n            div.style.visibility = 'hidden';\n            div.style.position = 'absolute';\n            w = div.offsetWidth;\n            div.style.display = 'none';\n            div.style.visibility = oldvis;\n            div.style.position = oldpos;\n        }\n        return w;\n    }\n    ;\n    getHeight() {\n        let div = this.container;\n        let h = div.offsetHeight;\n        if (h == 0 && div.style.display === 'none') {\n            let oldpos = div.style.position;\n            let oldvis = div.style.visibility;\n            div.style.display = 'block';\n            div.style.visibility = 'hidden';\n            div.style.position = 'absolute';\n            h = div.offsetHeight;\n            div.style.display = 'none';\n            div.style.visibility = oldvis;\n            div.style.position = oldpos;\n        }\n        return h;\n    }\n    ;\n    setupRenderer() {\n        this.renderer = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Renderer({\n            antialias: this.config.antialias,\n            preserveDrawingBuffer: true,\n            premultipliedAlpha: false,\n            id: this.config.id,\n            row: this.config.row,\n            col: this.config.col,\n            rows: this.config.rows,\n            cols: this.config.cols,\n            canvas: this.config.canvas,\n            //cannot initialize with zero size - render will start out lost\n            containerWidth: this.WIDTH,\n            containerHeight: this.HEIGHT\n        });\n        this.renderer.domElement.style.width = \"100%\";\n        this.renderer.domElement.style.height = \"100%\";\n        this.renderer.domElement.style.padding = \"0\";\n        this.renderer.domElement.style.position = \"absolute\"; //TODO: get rid of this\n        this.renderer.domElement.style.top = \"0px\";\n        this.renderer.domElement.style.left = \"0px\";\n        this.renderer.domElement.style.zIndex = \"0\";\n    }\n    initializeScene() {\n        this.scene = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this.scene.fog = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Fog(this.bgColor, 100, 200);\n        this.modelGroup = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n        this.rotationGroup = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n        this.rotationGroup.useQuaternion = true;\n        this.rotationGroup.quaternion = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0, 0, 0, 1);\n        this.rotationGroup.add(this.modelGroup);\n        this.scene.add(this.rotationGroup);\n        // setup lights\n        var directionalLight = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Light(0xFFFFFF);\n        directionalLight.position = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.2, 0.2, 1)\n            .normalize();\n        directionalLight.intensity = 1.0;\n        this.scene.add(directionalLight);\n    }\n    ;\n    initContainer(element) {\n        this.container = element;\n        this.WIDTH = this.getWidth();\n        this.HEIGHT = this.getHeight();\n        this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);\n        this.renderer.setSize(this.WIDTH, this.HEIGHT);\n        this.container.append(this.renderer.domElement);\n        this.glDOM = this.renderer.domElement;\n        if (!this.nomouse) {\n            // user can request that the mouse handlers not be installed\n            this.glDOM.addEventListener('mousedown', this._handleMouseDown.bind(this), { passive: false });\n            this.glDOM.addEventListener('touchstart', this._handleMouseDown.bind(this), { passive: false });\n            this.glDOM.addEventListener('wheel', this._handleMouseScroll.bind(this), { passive: false });\n            this.glDOM.addEventListener('mousemove', this._handleMouseMove.bind(this), { passive: false });\n            this.glDOM.addEventListener('touchmove', this._handleMouseMove.bind(this), { passive: false });\n            this.glDOM.addEventListener(\"contextmenu\", this._handleContextMenu.bind(this), { passive: false });\n        }\n    }\n    ;\n    decAnim() {\n        //decrement the number of animations currently\n        this.animated--;\n        if (this.animated < 0)\n            this.animated = 0;\n    }\n    ;\n    incAnim() {\n        this.animated++;\n    }\n    ;\n    nextSurfID() {\n        //compute the next highest surface id directly from surfaces\n        //this is necessary to support linking of model data\n        var max = 0;\n        for (let i in this.surfaces) { // this is an object with possible holes\n            if (!this.surfaces.hasOwnProperty(i))\n                continue;\n            var val = parseInt(i);\n            if (!isNaN(val)) {\n                if (val > max)\n                    max = val;\n            }\n        }\n        return max + 1;\n    }\n    ;\n    setSlabAndFog() {\n        let center = this.camera.position.z - this.rotationGroup.position.z;\n        if (center < 1)\n            center = 1;\n        this.camera.near = center + this.slabNear;\n        if (this.camera.near < 1)\n            this.camera.near = 1;\n        this.camera.far = center + this.slabFar;\n        if (this.camera.near + 1 > this.camera.far)\n            this.camera.far = this.camera.near + 1;\n        this.camera.fov = this.fov;\n        this.camera.right = center * Math.tan(Math.PI / 180 * this.fov);\n        this.camera.left = -this.camera.right;\n        this.camera.top = this.camera.right / this.ASPECT;\n        this.camera.bottom = -this.camera.top;\n        this.camera.updateProjectionMatrix();\n        this.scene.fog.near = this.camera.near + this.fogStart * (this.camera.far - this.camera.near);\n        // if (scene.fog.near > center) scene.fog.near = center;\n        this.scene.fog.far = this.camera.far;\n        if (this.config.disableFog) {\n            this.scene.fog.near = this.scene.fog.far;\n        }\n    }\n    ;\n    // display scene\n    //if nolink is set/true, don't propagate changes to linked viewers\n    show(nolink) {\n        this.renderer.setViewport();\n        if (!this.scene)\n            return;\n        // var time = new Date();\n        this.setSlabAndFog();\n        this.renderer.render(this.scene, this.camera);\n        // console.log(\"rendered in \" + (+new Date() - time) + \"ms\");\n        //have any scene change trigger a callback\n        if (this.viewChangeCallback)\n            this.viewChangeCallback(this._viewer.getView());\n        if (!nolink && this.linkedViewers.length > 0) {\n            var view = this._viewer.getView();\n            for (var i = 0; i < this.linkedViewers.length; i++) {\n                var other = this.linkedViewers[i];\n                other.setView(view, true);\n            }\n        }\n    }\n    ;\n    //regenerate the list of clickables\n    //also updates hoverables\n    updateClickables() {\n        this.clickables.splice(0, this.clickables.length);\n        this.hoverables.splice(0, this.hoverables.length);\n        this.contextMenuEnabledObjects.splice(0, this.contextMenuEnabledObjects.length);\n        for (let i = 0, il = this.models.length; i < il; i++) {\n            let model = this.models[i];\n            if (model) {\n                let atoms = model.selectedAtoms({\n                    clickable: true\n                });\n                let hoverable_atoms = model.selectedAtoms({\n                    hoverable: true\n                });\n                let contextMenuEnabled_atom = model.selectedAtoms({ contextMenuEnabled: true });\n                // Array.prototype.push.apply(hoverables,hoverable_atoms);\n                for (let n = 0; n < hoverable_atoms.length; n++) {\n                    this.hoverables.push(hoverable_atoms[n]);\n                }\n                // Array.prototype.push.apply(clickables, atoms); //add atoms into clickables\n                for (let m = 0; m < atoms.length; m++) {\n                    this.clickables.push(atoms[m]);\n                }\n                // add atoms into contextMenuEnabledObjects\n                for (let m = 0; m < contextMenuEnabled_atom.length; m++) {\n                    this.contextMenuEnabledObjects.push(contextMenuEnabled_atom[m]);\n                }\n            }\n        }\n        for (let i = 0, il = this.shapes.length; i < il; i++) {\n            let shape = this.shapes[i];\n            if (shape && shape.clickable) {\n                this.clickables.push(shape);\n            }\n            if (shape && shape.hoverable) {\n                this.hoverables.push(shape);\n            }\n            if (shape && shape.contextMenuEnabled) {\n                this.contextMenuEnabledObjects.push(shape);\n            }\n        }\n    }\n    ;\n    // Checks for selection intersects on mousedown\n    handleClickSelection(mouseX, mouseY, event) {\n        let intersects = this.targetedObjects(mouseX, mouseY, this.clickables);\n        // console.log('handleClickSelection', mouseX, mouseY, intersects);\n        if (intersects.length) {\n            var selected = intersects[0].clickable;\n            if (selected.callback !== undefined) {\n                if (typeof (selected.callback) != \"function\") {\n                    selected.callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.makeFunction)(selected.callback);\n                }\n                if (typeof (selected.callback) === \"function\") {\n                    // Suppress click callbacks when context menu will be invoked.\n                    // This only applies to clicks from \"mouseup\" events after right-click.\n                    // Clicks from \"touchend\" after longtouch contextmenu are suppressed\n                    // in _handleContextMenu.\n                    const isContextMenu = this.mouseButton === 3\n                        && this.contextMenuEnabledObjects.includes(selected)\n                        && this.userContextMenuHandler;\n                    if (!isContextMenu) {\n                        selected.callback(selected, this._viewer, event, this.container, intersects);\n                    }\n                }\n            }\n        }\n    }\n    ;\n    //return offset of container\n    canvasOffset() {\n        let canvas = this.glDOM;\n        let rect = canvas.getBoundingClientRect();\n        let doc = canvas.ownerDocument;\n        let docElem = doc.documentElement;\n        let win = doc.defaultView;\n        return {\n            top: rect.top + win.pageYOffset - docElem.clientTop,\n            left: rect.left + win.pageXOffset - docElem.clientLeft\n        };\n    }\n    ;\n    //set current_hover to sel (which can be null), calling appropraite callbacks\n    setHover(selected, event, intersects) {\n        if (this.current_hover == selected)\n            return;\n        if (this.current_hover) {\n            if (typeof (this.current_hover.unhover_callback) != \"function\") {\n                this.current_hover.unhover_callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.makeFunction)(this.current_hover.unhover_callback);\n            }\n            this.current_hover.unhover_callback(this.current_hover, this._viewer, event, this.container, intersects);\n        }\n        this.current_hover = selected;\n        if (selected && selected.hover_callback !== undefined) {\n            if (typeof (selected.hover_callback) != \"function\") {\n                selected.hover_callback = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.makeFunction)(selected.hover_callback);\n            }\n            if (typeof (selected.hover_callback) === \"function\") {\n                selected.hover_callback(selected, this._viewer, event, this.container, intersects);\n            }\n        }\n    }\n    ;\n    //checks for selection intersects on hover\n    handleHoverSelection(mouseX, mouseY, event) {\n        if (this.hoverables.length == 0)\n            return;\n        let intersects = this.targetedObjects(mouseX, mouseY, this.hoverables);\n        if (intersects.length) {\n            var selected = intersects[0].clickable;\n            this.setHover(selected, event, intersects);\n            this.current_hover = selected;\n        }\n        else {\n            this.setHover(null);\n        }\n    }\n    ;\n    //sees if the mouse is still on the object that invoked a hover event and if not then the unhover callback is called\n    handleHoverContinue(mouseX, mouseY) {\n        let intersects = this.targetedObjects(mouseX, mouseY, this.hoverables);\n        if (intersects.length == 0 || intersects[0] === undefined) {\n            this.setHover(null);\n        }\n        if (intersects[0] !== undefined && intersects[0].clickable !== this.current_hover) {\n            this.setHover(null);\n        }\n    }\n    ;\n    /**\n     * Determine if a positioned event is \"close enough\" to mouseStart to be considered a click.\n     * With a mouse, the position should be exact, but allow a slight delta for a touch interface.\n     * @param {Event} event\n     * @param {{ allowTolerance, tolerance: number }} options\n     */\n    closeEnoughForClick(event, { allowTolerance = event.targetTouches, tolerance = 5 } = {}) {\n        const x = this.getX(event);\n        const y = this.getY(event);\n        if (allowTolerance) {\n            const deltaX = Math.abs(x - this.mouseStartX);\n            const deltaY = Math.abs(y - this.mouseStartY);\n            return deltaX <= tolerance && deltaY <= tolerance;\n        }\n        else {\n            return x === this.mouseStartX && y === this.mouseStartY;\n        }\n    }\n    calcTouchDistance(ev) {\n        // fingers\n        var xdiff = ev.targetTouches[0].pageX -\n            ev.targetTouches[1].pageX;\n        var ydiff = ev.targetTouches[0].pageY -\n            ev.targetTouches[1].pageY;\n        return Math.hypot(xdiff, ydiff);\n    }\n    ;\n    //check targetTouches as well\n    getX(ev) {\n        var x = ev.pageX;\n        if (x == undefined)\n            x = ev.pageX; //firefox\n        if (ev.targetTouches &&\n            ev.targetTouches[0]) {\n            x = ev.targetTouches[0].pageX;\n        }\n        else if (ev.changedTouches &&\n            ev.changedTouches[0]) {\n            x = ev.changedTouches[0].pageX;\n        }\n        return x;\n    }\n    ;\n    getY(ev) {\n        var y = ev.pageY;\n        if (y == undefined)\n            y = ev.pageY;\n        if (ev.targetTouches &&\n            ev.targetTouches[0]) {\n            y = ev.targetTouches[0].pageY;\n        }\n        else if (ev.changedTouches &&\n            ev.changedTouches[0]) {\n            y = ev.changedTouches[0].pageY;\n        }\n        return y;\n    }\n    ;\n    //for grid viewers, return true if point is in this viewer\n    isInViewer(x, y) {\n        if (this.viewers != undefined) {\n            var width = this.WIDTH / this.cols;\n            var height = this.HEIGHT / this.rows;\n            var offset = this.canvasOffset();\n            var relx = (x - offset.left);\n            var rely = (y - offset.top);\n            var r = this.rows - Math.floor(rely / height) - 1;\n            var c = Math.floor(relx / width);\n            if (r != this.row || c != this.col)\n                return false;\n        }\n        return true;\n    }\n    ;\n    //if the user has specify zoom limits, readjust to fit within them\n    //also, make sure we don't go past CAMERA_Z\n    adjustZoomToLimits(z) {\n        //a lower limit of 0 is at CAMERA_Z\n        if (this.config.lowerZoomLimit && this.config.lowerZoomLimit > 0) {\n            let lower = this.CAMERA_Z - this.config.lowerZoomLimit;\n            if (z > lower)\n                z = lower;\n        }\n        if (this.config.upperZoomLimit && this.config.upperZoomLimit > 0) {\n            let upper = this.CAMERA_Z - this.config.upperZoomLimit;\n            if (z < upper)\n                z = upper;\n        }\n        if (z > this.CAMERA_Z - 1) {\n            z = this.CAMERA_Z - 1; //avoid getting stuck\n        }\n        return z;\n    }\n    ;\n    //interpolate between two normalized quaternions (t between 0 and 1)\n    //https://en.wikipedia.org/wiki/Slerp\n    static slerp(v0, v1, t) {\n        // Compute the cosine of the angle between the two vectors.\n        //dot product\n        if (t == 1)\n            return v1.clone();\n        else if (t == 0)\n            return v0.clone();\n        let dot = v0.x * v1.x + v0.y * v1.y + v0.z * v1.z + v0.w * v1.w;\n        if (dot > 0.9995) {\n            // If the inputs are too close for comfort, linearly interpolate\n            // and normalize the result.\n            let result = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Quaternion(v0.x + t * (v1.x - v0.x), v0.y + t * (v1.y - v0.y), v0.z + t * (v1.z - v0.z), v0.w + t * (v1.w - v0.w));\n            result.normalize();\n            return result;\n        }\n        // If the dot product is negative, the quaternions\n        // have opposite handed-ness and slerp won't take\n        // the shorted path. Fix by reversing one quaternion.\n        if (dot < 0.0) {\n            v1 = v1.clone().multiplyScalar(-1);\n            dot = -dot;\n        }\n        if (dot > 1)\n            dot = 1.0;\n        else if (dot < -1)\n            dot = -1.0;\n        var theta_0 = Math.acos(dot); // theta_0 = angle between input vectors\n        var theta = theta_0 * t; // theta = angle between v0 and result\n        var v2 = v1.clone();\n        v2.sub(v0.clone().multiplyScalar(dot));\n        v2.normalize(); // { v0, v2 } is now an orthonormal basis\n        var c = Math.cos(theta);\n        var s = Math.sin(theta);\n        var ret = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Quaternion(v0.x * c + v2.x * s, v0.y * c + v2.y * s, v0.z * c + v2.z * s, v0.w * c + v2.w * s);\n        ret.normalize();\n        return ret;\n    }\n    ;\n    /* @param {Object} element HTML element within which to create viewer\n     * @param {ViewerSpec} config Object containing optional configuration for the viewer\n     */\n    constructor(element, c = {}) {\n        this.nomouse = false;\n        this.glDOM = null;\n        this.models = []; // atomistic molecular models\n        this.surfaces = {};\n        this.shapes = []; // Generic shapes\n        this.labels = [];\n        this.clickables = []; //things you can click on\n        this.hoverables = []; //things you can hover over\n        this.contextMenuEnabledObjects = []; // atoms and shapes with context menu\n        this.current_hover = null;\n        this.hoverDuration = 500;\n        this.longTouchDuration = 1000;\n        this.viewer_frame = 0;\n        this.viewChangeCallback = null;\n        this.stateChangeCallback = null;\n        this.NEAR = 1;\n        this.FAR = 800;\n        this.CAMERA_Z = 150;\n        this.fov = 20;\n        this.linkedViewers = [];\n        this.renderer = null;\n        this.control_all = false;\n        this.scene = null;\n        this.rotationGroup = null; // which contains modelGroup\n        this.modelGroup = null;\n        this.fogStart = 0.4;\n        this.slabNear = -50; // relative to the center of rotationGroup\n        this.slabFar = 50;\n        this.cq = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0, 0, 0, 1);\n        this.dq = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0, 0, 0, 1);\n        this.animated = 0;\n        this.animationTimers = new Set();\n        this.isDragging = false;\n        this.mouseStartX = 0;\n        this.mouseStartY = 0;\n        this.touchDistanceStart = 0;\n        this.touchHold = false;\n        this.currentModelPos = 0;\n        this.cz = 0;\n        this.cslabNear = 0;\n        this.cslabFar = 0;\n        /** User specified function for handling a context menu event.\n         * Handler is passed the selected object, x and y in canvas coordinates,\n         * and original event.\n         */\n        this.userContextMenuHandler = null;\n        // set variables\n        this.config = c;\n        this.callback = this.config.callback;\n        this.defaultcolors = this.config.defaultcolors;\n        if (!this.defaultcolors)\n            this.defaultcolors = _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors.defaultColors;\n        this.nomouse = this.config.nomouse;\n        this.bgColor = 0;\n        this.config.backgroundColor = this.config.backgroundColor || \"#ffffff\";\n        if (typeof (this.config.backgroundColor) != 'undefined') {\n            this.bgColor = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(this.config.backgroundColor).getHex();\n        }\n        this.config.backgroundAlpha = this.config.backgroundAlpha == undefined ? 1.0 : this.config.backgroundAlpha;\n        this.camerax = 0;\n        if (typeof (this.config.camerax) != 'undefined') {\n            this.camerax = parseFloat(this.config.camerax);\n        }\n        this._viewer = this;\n        this.container = element; //we expect container to be HTMLElement\n        if (this.config.hoverDuration != undefined) {\n            this.hoverDuration = this.config.hoverDuration;\n        }\n        if (this.config.antialias === undefined)\n            this.config.antialias = true;\n        if (this.config.cartoonQuality === undefined)\n            this.config.cartoonQuality = 10;\n        this.WIDTH = this.getWidth();\n        this.HEIGHT = this.getHeight();\n        this.setupRenderer();\n        this.row = this.config.row == undefined ? 0 : this.config.row;\n        this.col = this.config.col == undefined ? 0 : this.config.col;\n        this.cols = this.config.cols;\n        this.rows = this.config.rows;\n        this.viewers = this.config.viewers;\n        this.control_all = this.config.control_all;\n        this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);\n        this.camera = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Camera(this.fov, this.ASPECT, this.NEAR, this.FAR, this.config.orthographic);\n        this.camera.position = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(this.camerax, 0, this.CAMERA_Z);\n        this.lookingAt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        this.camera.lookAt(this.lookingAt);\n        this.raycaster = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Raycaster(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0), new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0));\n        this.projector = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Projector();\n        this.initializeScene();\n        this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha);\n        this.scene.fog.color = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(this.bgColor);\n        // this event is bound to the body element, not the container,\n        // so no need to put it inside initContainer()\n        document.body.addEventListener('mouseup', this._handleMouseUp.bind(this));\n        document.body.addEventListener('touchend', this._handleMouseUp.bind(this));\n        this.initContainer(this.container);\n        if (this.config.style) { //enable setting style in constructor\n            this.setViewStyle(this.config);\n        }\n        window.addEventListener(\"resize\", this.resize.bind(this));\n        if (typeof (window.ResizeObserver) !== \"undefined\") {\n            this.divwatcher = new window.ResizeObserver(this.resize.bind(this));\n            this.divwatcher.observe(this.container);\n        }\n        try {\n            if (typeof (this.callback) === \"function\")\n                this.callback(this);\n        }\n        catch (e) {\n            // errors in callback shouldn't invalidate the viewer\n            console.log(\"error with glviewer callback: \" + e);\n        }\n    }\n    ;\n    /**\n    * Return a list of objects that intersect that at the specified viewer position.\n    *\n    * @param x - x position in screen coordinates\n    * @param y - y position in screen coordinates\n    * @param {Object[]} - list of objects or selection object specifying what object to check for targeting\n    */\n    targetedObjects(x, y, objects) {\n        var mouse = {\n            x: x,\n            y: y,\n            z: -1.0\n        };\n        if (!Array.isArray(objects)) { //assume selection object\n            objects = this.selectedAtoms(objects);\n        }\n        if (objects.length == 0)\n            return [];\n        this.raycaster.setFromCamera(mouse, this.camera);\n        return this.raycaster.intersectObjects(this.modelGroup, objects);\n    }\n    ;\n    /** Convert model coordinates to screen coordinates.\n     * @param {object | list} - an object or list of objects with x,y,z attributes (e.g. an atom)\n     * @return {object | list} - and object or list of {x: screenX, y: screenY}\n     */\n    modelToScreen(coords) {\n        let returnsingle = false;\n        if (!Array.isArray(coords)) {\n            coords = [coords];\n            returnsingle = true;\n        }\n        let ratioX = this.renderer.getXRatio();\n        let ratioY = this.renderer.getYRatio();\n        let col = this.col;\n        let row = this.row;\n        let viewxoff = col * (this.WIDTH / ratioX);\n        //row is from bottom \n        let viewyoff = (ratioY - row - 1) * (this.HEIGHT / ratioY);\n        let results = [];\n        let offset = this.canvasOffset();\n        coords.forEach(coord => {\n            let t = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(coord.x, coord.y, coord.z);\n            t.applyMatrix4(this.modelGroup.matrixWorld);\n            this.projector.projectVector(t, this.camera);\n            let screenX = (this.WIDTH / ratioX) * (t.x + 1) / 2.0 + offset.left + viewxoff;\n            let screenY = -(this.HEIGHT / ratioY) * (t.y - 1) / 2.0 + offset.top + viewyoff;\n            results.push({ x: screenX, y: screenY });\n        });\n        if (returnsingle)\n            results = results[0];\n        return results;\n    }\n    ;\n    /**\n     * For a given screen (x,y) displacement return model displacement\n     * @param{x} x displacement in screen coordinates\n     * @param{y} y displacement in screen corodinates\n     * @param{modelz} z coordinate in model coordinates to compute offset for, default is model axis\n    */\n    screenOffsetToModel(x, y, modelz) {\n        var dx = x / this.WIDTH;\n        var dy = y / this.HEIGHT;\n        var zpos = (modelz === undefined ? this.rotationGroup.position.z : modelz);\n        var q = this.rotationGroup.quaternion;\n        var t = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, zpos);\n        this.projector.projectVector(t, this.camera);\n        t.x += dx * 2;\n        t.y -= dy * 2;\n        this.projector.unprojectVector(t, this.camera);\n        t.z = 0;\n        t.applyQuaternion(q);\n        return t;\n    }\n    ;\n    /**\n     * Distance from screen coordinate to model coordinate assuming screen point\n     * is projected to the same depth as model coordinate\n     * @param{screen} xy screen coordinate\n     * @param{model} xyz model coordinate\n    */\n    screenToModelDistance(screen, model) {\n        let offset = this.canvasOffset();\n        //convert model to screen to get screen z\n        let mvec = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(model.x, model.y, model.z);\n        mvec.applyMatrix4(this.modelGroup.matrixWorld);\n        let m = mvec.clone();\n        this.projector.projectVector(mvec, this.camera);\n        let t = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3((screen.x - offset.left) * 2 / this.WIDTH - 1, (screen.y - offset.top) * 2 / -this.HEIGHT + 1, mvec.z);\n        this.projector.unprojectVector(t, this.camera);\n        return t.distanceTo(m);\n    }\n    ;\n    /**\n     * Set a callback to call when the view has potentially changed.\n     *\n    */\n    setViewChangeCallback(callback) {\n        if (typeof (callback) === 'function' || callback == null)\n            this.viewChangeCallback = callback;\n    }\n    ;\n    /**\n     * Set a callback to call when the view has potentially changed.\n     *\n    */\n    setStateChangeCallback(callback) {\n        if (typeof (callback) === 'function' || callback == null)\n            this.stateChangeCallback = callback;\n    }\n    ;\n    /**\n     * Return configuration of viewer\n     */\n    getConfig() {\n        return this.config;\n    }\n    ;\n    /**\n     * Set the configuration object.  Note that some setting may only\n     * have an effect at viewer creation time.\n     */\n    setConfig(c) {\n        this.config = c;\n    }\n    ;\n    /**\n     * Return object representing internal state of\n     * the viewer appropriate for passing to setInternalState\n     *\n    */\n    getInternalState() {\n        var ret = { 'models': [], 'surfaces': [], 'shapes': [], 'labels': [] };\n        for (let i = 0; i < this.models.length; i++) {\n            if (this.models[i]) {\n                ret.models[i] = this.models[i].getInternalState();\n            }\n        }\n        //todo: labels, shapes, surfaces\n        return ret;\n    }\n    ;\n    /**\n     * Overwrite internal state of the viewer with passed  object\n     * which should come from getInternalState.\n     *\n    */\n    setInternalState(state) {\n        //clear out current viewer\n        this.clear();\n        //set model state\n        var newm = state.models;\n        for (let i = 0; i < newm.length; i++) {\n            if (newm[i]) {\n                this.models[i] = new _GLModel__WEBPACK_IMPORTED_MODULE_5__.GLModel(i);\n                this.models[i].setInternalState(newm[i]);\n            }\n        }\n        //todo: labels, shapes, surfaces\n        this.render();\n    }\n    ;\n    /**\n     * Set lower and upper limit stops for zoom.\n     *\n     * @param {lower} - limit on zoom in (positive number).  Default 0.\n     * @param {upper} - limit on zoom out (positive number).  Default infinite.\n     * @example\n      $3Dmol.get(\"data/set1_122_complex.mol2\", function(moldata) {\n            var m = viewer.addModel(moldata);\n            viewer.setStyle({stick:{colorscheme:\"Jmol\"}});\n            viewer.setZoomLimits(100,200);\n            viewer.zoomTo();\n            viewer.zoom(10); //will not zoom all the way\n            viewer.render();\n        });\n    */\n    setZoomLimits(lower, upper) {\n        if (typeof (lower) !== 'undefined')\n            this.config.lowerZoomLimit = lower;\n        if (upper)\n            this.config.upperZoomLimit = upper;\n        this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);\n        this.show();\n    }\n    ;\n    /**\n     * Set camera parameters (distance to the origin and field of view)\n     *\n     * @param {parameters} - new camera parameters, with possible fields\n     *                       being fov for the field of view, z for the\n     *                       distance to the origin, and orthographic (boolean)\n     *                       for kind of projection (default false).\n     * @example\n      $3Dmol.get(\"data/set1_122_complex.mol2\", function(data) {\n            var m = viewer.addModel(data);\n            viewer.setStyle({stick:{}});\n            viewer.zoomTo();\n            viewer.setCameraParameters({ fov: 10 , z: 300 });\n            viewer.render();\n        });\n    */\n    setCameraParameters(parameters) {\n        if (parameters.fov !== undefined) {\n            this.fov = parameters.fov;\n            this.camera.fov = this.fov;\n        }\n        if (parameters.z !== undefined) {\n            this.CAMERA_Z = parameters.z;\n            this.camera.z = this.CAMERA_Z;\n        }\n        if (parameters.orthographic !== undefined) {\n            this.camera.ortho = parameters.orthographic;\n        }\n    }\n    ;\n    _handleMouseDown(ev) {\n        ev.preventDefault();\n        if (!this.scene)\n            return;\n        var x = this.getX(ev);\n        var y = this.getY(ev);\n        if (x === undefined)\n            return;\n        this.isDragging = true;\n        this.mouseButton = ev.which;\n        this.mouseStartX = x;\n        this.mouseStartY = y;\n        this.touchHold = true;\n        this.touchDistanceStart = 0;\n        if (ev.targetTouches &&\n            ev.targetTouches.length == 2) {\n            this.touchDistanceStart = this.calcTouchDistance(ev);\n        }\n        this.cq = this.rotationGroup.quaternion.clone();\n        this.cz = this.rotationGroup.position.z;\n        this.currentModelPos = this.modelGroup.position.clone();\n        this.cslabNear = this.slabNear;\n        this.cslabFar = this.slabFar;\n        let self = this;\n        if (ev.targetTouches && ev.targetTouches.length === 1) {\n            this.longTouchTimeout = setTimeout(function () {\n                if (self.touchHold == true) {\n                    // console.log('Touch hold', x,y);\n                    self.glDOM = self.renderer.domElement;\n                    const touch = ev.targetTouches[0];\n                    const newEvent = new PointerEvent('contextmenu', Object.assign(Object.assign({}, ev), { pageX: touch.pageX, pageY: touch.pageY, screenX: touch.screenX, screenY: touch.screenY, clientX: touch.clientX, clientY: touch.clientY }));\n                    self.glDOM.dispatchEvent(newEvent);\n                }\n                else {\n                    // console.log('Touch hold ended earlier');\n                }\n            }, this.longTouchDuration);\n        }\n    }\n    ;\n    _handleMouseUp(ev) {\n        // handle touch\n        this.touchHold = false;\n        // handle selection\n        if (this.isDragging && this.scene) { //saw mousedown, haven't moved\n            var x = this.getX(ev);\n            var y = this.getY(ev);\n            if (this.closeEnoughForClick(ev) && this.isInViewer(x, y)) {\n                let mouse = this.mouseXY(x, y);\n                this.handleClickSelection(mouse.x, mouse.y, ev);\n            }\n        }\n        this.isDragging = false;\n    }\n    _handleMouseScroll(ev) {\n        ev.preventDefault();\n        if (!this.scene)\n            return;\n        var x = this.getX(ev);\n        var y = this.getY(ev);\n        if (x === undefined)\n            return;\n        if (!this.control_all && !this.isInViewer(x, y)) {\n            return;\n        }\n        var scaleFactor = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85;\n        var mult = 1.0;\n        if (ev.ctrlKey) {\n            mult = -1.0; //this is a pinch event turned into a wheel event (or they're just holding down the ctrl)\n        }\n        if (ev.detail) {\n            this.rotationGroup.position.z += mult * scaleFactor * ev.detail / 10;\n        }\n        else if (ev.wheelDelta) {\n            //dampen the wheelDelta since some browser/OS/mouse combinations can be quite large\n            let wd = ev.wheelDelta * 600 / (ev.wheelDelta + 600);\n            this.rotationGroup.position.z -= mult * scaleFactor * wd / 400;\n        }\n        this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);\n        this.show();\n    }\n    ;\n    /**\n     * Return image URI of viewer contents (base64 encoded).     *\n     */\n    pngURI() {\n        return this.getCanvas().toDataURL('image/png');\n    }\n    ;\n    /**\n     * Return a promise that resolves to an animated PNG image URI of\n     viewer contents (base64 encoded) for nframes of viewer changes.\n     * @return {Promise}\n     */\n    apngURI(nframes) {\n        let viewer = this;\n        nframes = nframes ? nframes : 1;\n        return new Promise(function (resolve) {\n            let framecnt = 0;\n            let oldcb = viewer.viewChangeCallback;\n            let bufpromise = [];\n            let delays = [];\n            let lasttime = Date.now();\n            viewer.viewChangeCallback = function () {\n                delays.push(Date.now() - lasttime);\n                lasttime = Date.now();\n                bufpromise.push(new Promise(resolve => {\n                    viewer.getCanvas().toBlob(function (blob) {\n                        blob.arrayBuffer().then(resolve);\n                    }, \"image/png\");\n                }));\n                framecnt += 1;\n                if (framecnt == nframes) {\n                    viewer.viewChangeCallback = oldcb;\n                    Promise.all(bufpromise).then((buffers) => {\n                        //convert to apng\n                        let rgbas = [];\n                        //have to convert png to rgba, before creating the apng\n                        for (let i = 0; i < buffers.length; i++) {\n                            let img = (0,upng_js__WEBPACK_IMPORTED_MODULE_11__.decode)(buffers[i]);\n                            rgbas.push((0,upng_js__WEBPACK_IMPORTED_MODULE_11__.toRGBA8)(img)[0]);\n                        }\n                        let width = viewer.getCanvas().width;\n                        let height = viewer.getCanvas().height;\n                        let apng = (0,upng_js__WEBPACK_IMPORTED_MODULE_11__.encode)(rgbas, width, height, 0, delays);\n                        let blob = new Blob([apng], { type: 'image/png' });\n                        let fr = new FileReader();\n                        fr.onload = function (e) {\n                            resolve(e.target.result);\n                        };\n                        fr.readAsDataURL(blob);\n                    });\n                }\n            };\n        });\n    }\n    ;\n    /**\n     * Return underlying canvas element.\n     */\n    getCanvas() {\n        return this.glDOM;\n    }\n    ;\n    /**\n     * Return renderer element.\n     */\n    getRenderer() {\n        return this.renderer;\n    }\n    ;\n    /**\n         * Set the duration of the hover delay\n         *\n         * @param {number}\n         *            [hoverDuration] - an optional parameter that denotes\n         *            the duration of the hover delay (in milliseconds) before the hover action is called\n         *\n     */\n    setHoverDuration(duration) {\n        this.hoverDuration = duration;\n    }\n    ;\n    mouseXY(x, y) {\n        //convert to -1..1 coordinates\n        let offset = this.canvasOffset();\n        let ratioX = this.renderer.getXRatio();\n        let ratioY = this.renderer.getYRatio();\n        let col = this.col;\n        let row = this.row;\n        let viewxoff = col * (this.WIDTH / ratioX);\n        //row is from bottom \n        let viewyoff = (ratioY - row - 1) * (this.HEIGHT / ratioY);\n        let mouseX = ((x - offset.left - viewxoff) / (this.WIDTH / ratioX)) * 2 - 1;\n        let mouseY = -((y - offset.top - viewyoff) / (this.HEIGHT / ratioY)) * 2 + 1;\n        return { x: mouseX, y: mouseY };\n    }\n    _handleMouseMove(ev) {\n        clearTimeout(this.hoverTimeout);\n        ev.preventDefault();\n        let x = this.getX(ev);\n        let y = this.getY(ev);\n        if (x === undefined)\n            return;\n        let ratioX = this.renderer.getXRatio();\n        let ratioY = this.renderer.getYRatio();\n        let mouse = this.mouseXY(x, y);\n        let self = this;\n        // hover timeout\n        if (this.current_hover !== null) {\n            this.handleHoverContinue(mouse.x, mouse.y);\n        }\n        var mode = 0;\n        if (!this.control_all && !this.isInViewer(x, y)) {\n            return;\n        }\n        if (!this.scene)\n            return;\n        if (this.hoverables.length > 0) {\n            this.hoverTimeout = setTimeout(function () {\n                self.handleHoverSelection(mouse.x, mouse.y, ev);\n            }, this.hoverDuration);\n        }\n        if (!this.isDragging)\n            return;\n        // Cancel longtouch timer to avoid invoking context menu if dragged away from start\n        if (ev.targetTouches && (ev.targetTouches.length > 1 ||\n            (ev.targetTouches.length === 1 && !this.closeEnoughForClick(ev)))) {\n            clearTimeout(this.longTouchTimeout);\n        }\n        var dx = (x - this.mouseStartX) / this.WIDTH;\n        var dy = (y - this.mouseStartY) / this.HEIGHT;\n        // check for pinch\n        if (this.touchDistanceStart != 0 &&\n            ev.targetTouches &&\n            ev.targetTouches.length == 2) {\n            var newdist = this.calcTouchDistance(ev);\n            // change to zoom\n            mode = 2;\n            dy = (newdist - this.touchDistanceStart) * 2 / (this.WIDTH + this.HEIGHT);\n        }\n        else if (ev.targetTouches &&\n            ev.targetTouches.length == 3) {\n            // translate\n            mode = 1;\n        }\n        dx *= ratioX;\n        dy *= ratioY;\n        var r = Math.hypot(dx, dy);\n        var scaleFactor;\n        if (mode == 3 || (this.mouseButton == 3 && ev.ctrlKey)) { // Slab\n            this.slabNear = this.cslabNear + dx * 100;\n            this.slabFar = this.cslabFar - dy * 100;\n        }\n        else if (mode == 2 || this.mouseButton == 3 || ev.shiftKey) { // Zoom\n            scaleFactor = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85;\n            if (scaleFactor < 80)\n                scaleFactor = 80;\n            this.rotationGroup.position.z = this.cz + dy * scaleFactor;\n            this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);\n        }\n        else if (mode == 1 || this.mouseButton == 2 || ev.ctrlKey) { // Translate\n            var t = this.screenOffsetToModel(ratioX * (x - this.mouseStartX), ratioY * (y - this.mouseStartY));\n            this.modelGroup.position.addVectors(this.currentModelPos, t);\n        }\n        else if ((mode === 0 || this.mouseButton == 1) && r !== 0) { // Rotate\n            var rs = Math.sin(r * Math.PI) / r;\n            this.dq.x = Math.cos(r * Math.PI);\n            this.dq.y = 0;\n            this.dq.z = rs * dx;\n            this.dq.w = -rs * dy;\n            this.rotationGroup.quaternion.set(1, 0, 0, 0);\n            this.rotationGroup.quaternion.multiply(this.dq);\n            this.rotationGroup.quaternion.multiply(this.cq);\n        }\n        this.show();\n    }\n    ;\n    _handleContextMenu(ev) {\n        ev.preventDefault();\n        if (this.closeEnoughForClick(ev)) {\n            var x = this.mouseStartX;\n            var y = this.mouseStartY;\n            var offset = this.canvasOffset();\n            let mouse = this.mouseXY(x, y);\n            let mouseX = mouse.x;\n            let mouseY = mouse.y;\n            let intersects = this.targetedObjects(mouseX, mouseY, this.contextMenuEnabledObjects);\n            var selected = null;\n            if (intersects.length) {\n                selected = intersects[0].clickable;\n            }\n            var offset = this.canvasOffset();\n            var x = this.mouseStartX - offset.left;\n            var y = this.mouseStartY - offset.top;\n            if (this.userContextMenuHandler) {\n                this.userContextMenuHandler(selected, x, y, intersects, ev);\n                // We've processed this as a context menu evt; ignore further mouseup / touchend.\n                // This is really for touchend after longtouch, since the mouseup for right-click\n                // occurs before the contextmenu event.\n                this.isDragging = false;\n            }\n        }\n    }\n    ;\n    /**\n     * Change the viewer's container element\n     * Also useful if the original container element was removed from the DOM.\n     *\n     * @param {Object | string} element\n     *            Either HTML element or string identifier. Defaults to the element used to initialize the viewer.\n\n     */\n    setContainer(element) {\n        let elem = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getElement)(element) || this.container;\n        this.initContainer(elem);\n        return this;\n    }\n    ;\n    /**\n     * Set the background color (default white)\n     *\n     * @param {number}\n     *            hex Hexcode specified background color, or standard color spec\n     * @param {number}\n     *            a Alpha level (default 1.0)\n     *\n     * @example\n     *\n     * viewer.setBackgroundColor(0x000000);\n\n\n     *\n     */\n    setBackgroundColor(hex, a) {\n        if (typeof (a) == \"undefined\") {\n            a = 1.0;\n        }\n        else if (a < 0 || a > 1.0) {\n            a = 1.0;\n        }\n        var c = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(hex);\n        this.scene.fog.color = c;\n        this.bgColor = c.getHex();\n        this.renderer.setClearColorHex(c.getHex(), a);\n        this.show();\n        return this;\n    }\n    ;\n    /**\n     * Set view projection scheme.  Either orthographic or perspective.\n     * Default is perspective.  Orthographic can also be enabled on viewer creation\n     * by setting orthographic to true in the config object.\n     *\n     *\n     * @example\n     viewer.setViewStyle({style:\"outline\"});\n          $3Dmol.get('data/1fas.pqr', function(data){\n              viewer.addModel(data, \"pqr\");\n              $3Dmol.get(\"data/1fas.cube\",function(volumedata){\n                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, \"cube\"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});\n              });\n              viewer.zoomTo();\n\n              viewer.setProjection(\"orthographic\");\n              viewer.render(callback);\n          });\n     *\n     */\n    setProjection(proj) {\n        this.camera.ortho = (proj === \"orthographic\");\n        this.setSlabAndFog();\n    }\n    ;\n    /**\n     * Set global view styles.\n     *\n     * @example\n     *   viewer.setViewStyle({style:\"outline\"});\n          $3Dmol.get('data/1fas.pqr', function(data){\n              viewer.addModel(data, \"pqr\");\n              $3Dmol.get(\"data/1fas.cube\",function(volumedata){\n                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, \"cube\"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});\n              });\n              viewer.zoomTo();\n              viewer.render(callback);\n          });\n     *\n     */\n    setViewStyle(parameters) {\n        if (parameters.style === \"outline\") {\n            var params = {};\n            if (parameters.color)\n                params.color = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(parameters.color);\n            if (parameters.width)\n                params.width = parameters.width;\n            this.renderer.enableOutline(params);\n        }\n        else {\n            this.renderer.disableOutline();\n        }\n        return this;\n    }\n    ;\n    updateSize() {\n        this.renderer.setSize(this.WIDTH, this.HEIGHT);\n        this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT);\n        this.renderer.setSize(this.WIDTH, this.HEIGHT);\n        this.camera.aspect = this.ASPECT;\n        this.camera.updateProjectionMatrix();\n    }\n    /**\n     * Set viewer width independently of the HTML container.  This is probably not what you want.\n     *\n     * @param {number} w Width in pixels\n     */\n    setWidth(w) {\n        this.WIDTH = w || this.WIDTH;\n        this.updateSize();\n        return this;\n    }\n    ;\n    /**\n     * Set viewer height independently of the HTML container.  This is probably not what you want.\n     *\n     * @param {number} h Height in pixels\n     */\n    setHeight(h) {\n        this.HEIGHT = h || this.HEIGHT;\n        this.updateSize();\n        return this;\n    }\n    ;\n    /**\n     * Resize viewer according to containing HTML element's dimensions\n     *\n     */\n    resize() {\n        this.WIDTH = this.getWidth();\n        this.HEIGHT = this.getHeight();\n        let regen = false;\n        if (this.renderer.isLost() && this.WIDTH > 0 && this.HEIGHT > 0) {\n            //create new context\n            let resetcanvas = false;\n            let currentcanvas = this.container.querySelector('canvas');\n            if (currentcanvas && currentcanvas != this.renderer.getCanvas()) {\n                //canvas has been replaced, use new one\n                this.config.canvas = currentcanvas;\n            }\n            else {\n                currentcanvas.remove(); //remove existing\n                if (this.config && this.config.canvas != undefined) {\n                    delete this.config.canvas;\n                    resetcanvas = true;\n                }\n            }\n            this.setupRenderer();\n            this.initContainer(this.container);\n            this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha);\n            regen = true;\n            if (resetcanvas) {\n                this.config.canvas = this.renderer.getCanvas();\n            }\n        }\n        if (this.WIDTH == 0 || this.HEIGHT == 0) {\n            if (this.animated)\n                this._viewer.pauseAnimate();\n        }\n        else if (this.animated) {\n            this._viewer.resumeAnimate();\n        }\n        this.updateSize();\n        if (regen) { //restored rendere, need to regenerate scene\n            let options = this.renderer.supportedExtensions();\n            options.regen = true;\n            if (this.viewers) {\n                for (let i = 0, n = this.viewers.length; i < n; i++) {\n                    for (let j = 0, m = this.viewers[i].length; j < m; j++) {\n                        this.viewers[i][j].render(null, options);\n                    }\n                }\n            }\n            this._viewer.render(null, options);\n        }\n        else {\n            this.show();\n        }\n        return this;\n    }\n    ;\n    /**\n     * Return specified model\n     *\n     * @param {number}\n     *            [id=last model id] - Retrieve model with specified id\n     * @default Returns last model added to viewer or null if there are no models\n     * @return {GLModel}\n     *\n     * @example // Retrieve reference to first GLModel added var m =\n     *    $3Dmol.download(\"pdb:1UBQ\",viewer,{},function(m1){\n              $3Dmol.download(\"pdb:1UBI\", viewer,{}, function(m2) {\n                viewer.zoomTo();\n                m1.setStyle({cartoon: {color:'green'}});\n                //could use m2 here as well\n                viewer.getModel().setStyle({cartoon: {color:'blue'}});\n                viewer.render();\n            })\n          });\n     */\n    getModel(id) {\n        if (id === undefined) {\n            return this.models.length == 0 ? null : this.models[this.models.length - 1];\n        }\n        if (id instanceof _GLModel__WEBPACK_IMPORTED_MODULE_5__.GLModel) {\n            return id;\n        }\n        if (!(id in this.models)) {\n            if (this.models.length == 0)\n                return null;\n            else\n                return this.models[this.models.length - 1]; //get last model if no (or invalid) id specified\n        }\n        return this.models[id];\n    }\n    ;\n    /**\n     * Continuously rotate a scene around the specified axis.\n     *\n     * Call `spin(false)` to stop spinning.\n     *\n     * @param  {string|boolean|Array} axis\n     *            [axis] - Axis (\"x\", \"y\", \"z\", \"vx\", \"vy\", or \"vz\") to rotate around.\n     *            Default \"y\".  View relative (rather than model relative) axes are prefixed with v.\n     * @param  {number} speed\n     *            [speed] - Speed multiplier for spinning the viewer. 1 is default and a negative\n     *             value reverses the direction of the spin.\n     *\n     */\n    spin(axis, speed = 1) {\n        clearInterval(this.spinInterval);\n        if (typeof axis == 'undefined')\n            axis = 'y';\n        if (typeof axis == \"boolean\") {\n            if (!axis)\n                return;\n            else\n                axis = 'y';\n        }\n        if (Array.isArray(axis)) {\n            axis = { x: axis[0], y: axis[1], z: axis[2] };\n        }\n        //out of bounds check\n        var viewer = this;\n        this.spinInterval = setInterval(function () {\n            if (!viewer.getCanvas().isConnected && viewer.renderer.isLost()) {\n                clearInterval(viewer.spinInterval);\n            }\n            viewer.rotate(1 * speed, axis);\n        }, 25);\n    }\n    ;\n    //animate motion between current position and passed position\n    // can set some parameters to null\n    //if fixed is true will enforce the request animation, otherwise\n    //does relative updates\n    //positions objects have modelggroup position, rotation group position.z,\n    //and rotationgroup quaternion\n    //return array includes final position, but not current\n    //the returned array includes an animate method\n    animateMotion(duration, fixed, mpos, rz, rot, cam) {\n        var interval = 20;\n        var nsteps = Math.ceil(duration / interval);\n        if (nsteps < 1)\n            nsteps = 1;\n        this.incAnim();\n        var curr = {\n            mpos: this.modelGroup.position.clone(),\n            rz: this.rotationGroup.position.z,\n            rot: this.rotationGroup.quaternion.clone(),\n            cam: this.lookingAt.clone()\n        };\n        if (fixed) { //precompute path and stick to it\n            let steps = new Array(nsteps);\n            for (let i = 0; i < nsteps; i++) {\n                let frac = (i + 1) / nsteps;\n                let next = { mpos: curr.mpos, rz: curr.rz, rot: curr.rot };\n                next.mpos = mpos.clone().sub(curr.mpos).multiplyScalar(frac).add(curr.mpos);\n                next.rz = curr.rz + frac * (rz - curr.rz);\n                next.rot = GLViewer.slerp(curr.rot, rot, frac);\n                next.cam = cam.clone().sub(curr.cam).multiplyScalar(frac).add(curr.cam);\n                steps[i] = next;\n            }\n            let step = 0;\n            let self = this;\n            let callback = function () {\n                var p = steps[step];\n                step += 1;\n                self.modelGroup.position = p.mpos;\n                self.rotationGroup.position.z = p.rz;\n                self.rotationGroup.quaternion = p.rot;\n                self.camera.lookAt(p.cam);\n                if (step < steps.length) {\n                    setTimeout(callback, interval);\n                }\n                else {\n                    self.decAnim();\n                }\n                self.show();\n            };\n            setTimeout(callback, interval);\n        }\n        else { //relative update\n            var delta = {};\n            let frac = 1.0 / nsteps;\n            if (mpos) {\n                delta.mpos = mpos.clone().sub(curr.mpos).multiplyScalar(frac);\n            }\n            if (typeof (rz) != 'undefined' && rz != null) {\n                delta.rz = frac * (rz - curr.rz);\n            }\n            if (rot) {\n                var next = GLViewer.slerp(curr.rot, rot, frac);\n                //comptute step delta rotation\n                delta.rot = curr.rot.clone().inverse().multiply(next);\n            }\n            if (cam) {\n                delta.cam = cam.clone().sub(curr.cam).multiplyScalar(frac);\n            }\n            let step = 0.0;\n            let self = this;\n            let callback = function () {\n                step += 1;\n                if (delta.mpos) {\n                    self.modelGroup.position.add(delta.mpos);\n                }\n                if (delta.rz) {\n                    self.rotationGroup.position.z += delta.rz;\n                }\n                if (delta.rot) {\n                    self.rotationGroup.quaternion.multiply(delta.rot);\n                }\n                if (delta.cam) {\n                    self.lookingAt.add(delta.cam);\n                    self.camera.lookAt(self.lookingAt);\n                }\n                if (step < nsteps) {\n                    setTimeout(callback, interval);\n                }\n                else {\n                    self.decAnim();\n                }\n                self.show();\n            };\n            setTimeout(callback, interval);\n        }\n    }\n    ;\n    /**\n     * Rotate scene by angle degrees around axis\n     *\n     * @param {number}\n     *            [angle] - Angle, in degrees, to rotate by.\n     * @param {string}\n     *            [axis] - Axis (\"x\", \"y\", \"z\", \"vx\", \"vy\", or \"vz\") to rotate around.\n     *            Default \"y\".  View relative (rather than model relative) axes are prefixed with v.\n     *            Axis can also be specified as a vector.\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of the rotation animation. Default 0 (no animation)\n     * @param {boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n     * @example     $3Dmol.download('cid:4000', viewer, {}, function() {\n    viewer.setStyle({stick:{}});\n    viewer.zoomTo();\n    viewer.rotate(90,'y',1);\n    viewer.render(callback);\n    });\n\n     *\n     */\n    rotate(angle, axis = \"y\", animationDuration = 0, fixedPath = false) {\n        if (axis == \"x\") {\n            axis = { x: 1, y: 0, z: 0 };\n        }\n        else if (axis == \"y\") {\n            axis = { x: 0, y: 1, z: 0 };\n        }\n        else if (axis == \"z\") {\n            axis = { x: 0, y: 0, z: 1 };\n        }\n        //support rotating with respect to view axis, not model\n        if (axis == \"vx\") {\n            axis = { vx: 1, vy: 0, vz: 0 };\n        }\n        else if (axis == \"vy\") {\n            axis = { vx: 0, vy: 1, vz: 0 };\n        }\n        else if (axis == \"vz\") {\n            axis = { vx: 0, vy: 0, vz: 1 };\n        }\n        if (typeof (axis.vx) !== 'undefined') {\n            var vaxis = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(axis.vx, axis.vy, axis.vz);\n            vaxis.applyQuaternion(this.rotationGroup.quaternion);\n            axis = { x: vaxis.x, y: vaxis.y, z: vaxis.z };\n        }\n        var qFromAngle = function (rangle) {\n            var s = Math.sin(rangle / 2.0);\n            var c = Math.cos(rangle / 2.0);\n            var i = 0, j = 0, k = 0;\n            i = axis.x * s;\n            j = axis.y * s;\n            k = axis.z * s;\n            return new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Quaternion(i, j, k, c).normalize();\n        };\n        var rangle = Math.PI * angle / 180.0;\n        var q = qFromAngle(rangle);\n        if (animationDuration) {\n            var final = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Quaternion().copy(this.rotationGroup.quaternion).multiply(q); //final\n            this.animateMotion(animationDuration, fixedPath, this.modelGroup.position, this.rotationGroup.position.z, final, this.lookingAt);\n        }\n        else { //not animated\n            this.rotationGroup.quaternion.multiply(q);\n            this.show();\n        }\n        return this;\n    }\n    ;\n    surfacesFinished() {\n        for (var key in this.surfaces) {\n            if (!this.surfaces[key][0].done) {\n                return false;\n            }\n        }\n        return true;\n    }\n    ;\n    /** Returns an array representing the current viewpoint.\n     * Translation, zoom, and rotation quaternion.\n     * @returns {Array.<number>} [ pos.x, pos.y, pos.z, rotationGroup.position.z, q.x, q.y, q.z, q.w ]\n     *  */\n    getView() {\n        if (!this.modelGroup)\n            return [0, 0, 0, 0, 0, 0, 0, 1];\n        var pos = this.modelGroup.position;\n        var q = this.rotationGroup.quaternion;\n        return [pos.x, pos.y, pos.z, this.rotationGroup.position.z, q.x, q.y,\n            q.z, q.w];\n    }\n    ;\n    /** Sets the view to the specified translation, zoom, and rotation.\n     *\n     * @param {Array.<number>} arg Array formatted identically to the return value of getView */\n    setView(arg, nolink) {\n        if (arg === undefined ||\n            !(arg instanceof Array || arg.length !== 8))\n            return this;\n        if (!this.modelGroup || !this.rotationGroup)\n            return this;\n        this.modelGroup.position.x = arg[0];\n        this.modelGroup.position.y = arg[1];\n        this.modelGroup.position.z = arg[2];\n        this.rotationGroup.position.z = arg[3];\n        this.rotationGroup.quaternion.x = arg[4];\n        this.rotationGroup.quaternion.y = arg[5];\n        this.rotationGroup.quaternion.z = arg[6];\n        this.rotationGroup.quaternion.w = arg[7];\n        if (typeof (arg[8]) != \"undefined\") {\n            this.rotationGroup.position.x = arg[8];\n            this.rotationGroup.position.y = arg[9];\n        }\n        this.show(nolink);\n        return this;\n    }\n    ;\n    // apply styles, models, etc in viewer\n    /**\n     * Render current state of viewer, after\n     * adding/removing models, applying styles, etc.\n     *\n     */\n    render(callback, exts) {\n        this.renderer.setViewport();\n        this.updateClickables(); //must render for clickable styles to take effect\n        var view = this.getView();\n        if (this.stateChangeCallback) {\n            //todo: have ability to only send delta updates\n            this.stateChangeCallback(this.getInternalState());\n        }\n        var i, n;\n        if (!exts)\n            exts = this.renderer.supportedExtensions();\n        for (i = 0; i < this.models.length; i++) {\n            if (this.models[i]) {\n                this.models[i].globj(this.modelGroup, exts);\n            }\n        }\n        for (i = 0; i < this.shapes.length; i++) {\n            if (this.shapes[i]) { //exists\n                if ((typeof (this.shapes[i].frame) === 'undefined' || this.viewer_frame < 0 ||\n                    this.shapes[i].frame < 0 || this.shapes[i].frame == this.viewer_frame)) {\n                    this.shapes[i].globj(this.modelGroup, exts);\n                }\n                else { //should not be displayed in current frame\n                    this.shapes[i].removegl(this.modelGroup);\n                }\n            }\n        }\n        for (i = 0; i < this.labels.length; i++) {\n            if (exts.regen) {\n                this.labels[i].dispose();\n                this.modelGroup.remove(this.labels[i].sprite);\n                this.labels[i].setContext();\n                this.modelGroup.add(this.labels[i].sprite);\n            }\n            if (this.labels[i] && typeof (this.labels[i].frame) != 'undefined' && this.labels[i].frame >= 0) { //exists and has frame specifier\n                this.modelGroup.remove(this.labels[i].sprite);\n                if (this.viewer_frame < 0 || this.labels[i].frame == this.viewer_frame) {\n                    this.modelGroup.add(this.labels[i].sprite);\n                }\n            }\n        }\n        for (i in this.surfaces) { // this is an object with possible holes\n            if (!this.surfaces.hasOwnProperty(i))\n                continue;\n            var surfArr = this.surfaces[i];\n            for (n = 0; n < surfArr.length; n++) {\n                if (surfArr.hasOwnProperty(n)) {\n                    var geo = surfArr[n].geo;\n                    // async surface generation can cause\n                    // the geometry to be webgl initialized before it is fully\n                    // formed; force various recalculations until full surface\n                    // is available\n                    if (!surfArr[n].finished || exts.regen) {\n                        geo.verticesNeedUpdate = true;\n                        geo.elementsNeedUpdate = true;\n                        geo.normalsNeedUpdate = true;\n                        geo.colorsNeedUpdate = true;\n                        geo.buffersNeedUpdate = true;\n                        geo.boundingSphere = null;\n                        surfArr[n].mat.needsUpdate = true;\n                        if (surfArr[n].done)\n                            surfArr[n].finished = true;\n                        // remove partially rendered surface\n                        if (surfArr[n].lastGL)\n                            this.modelGroup.remove(surfArr[n].lastGL);\n                        // create new surface\n                        var smesh = null;\n                        if (surfArr[n].mat instanceof _WebGL__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial) {\n                            //special case line meshes\n                            smesh = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Line(geo, surfArr[n].mat);\n                        }\n                        else {\n                            smesh = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(geo, surfArr[n].mat);\n                        }\n                        if (surfArr[n].mat.transparent && surfArr[n].mat.opacity == 0) {\n                            //don't bother with hidden surfaces\n                            smesh.visible = false;\n                        }\n                        else {\n                            smesh.visible = true;\n                        }\n                        if (surfArr[n].symmetries.length > 1 ||\n                            (surfArr[n].symmetries.length == 1 &&\n                                !(surfArr[n].symmetries[n].isIdentity()))) {\n                            var j;\n                            var tmeshes = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D(); //transformed meshes\n                            for (j = 0; j < surfArr[n].symmetries.length; j++) {\n                                var tmesh = smesh.clone();\n                                tmesh.matrix = surfArr[n].symmetries[j];\n                                tmesh.matrixAutoUpdate = false;\n                                tmeshes.add(tmesh);\n                            }\n                            surfArr[n].lastGL = tmeshes;\n                            this.modelGroup.add(tmeshes);\n                        }\n                        else {\n                            surfArr[n].lastGL = smesh;\n                            this.modelGroup.add(smesh);\n                        }\n                    } // else final surface already there\n                }\n            }\n        }\n        this.setView(view); // Calls show() => renderer render\n        if (typeof callback === 'function') {\n            callback(this);\n        }\n        return this;\n    }\n    ;\n    /* @param {AtomSelectionSpec|any} sel\n     * @return list of models specified by sel\n     */\n    getModelList(sel) {\n        let ms = [];\n        if (typeof sel === 'undefined' || typeof sel.model === \"undefined\") {\n            for (let i = 0; i < this.models.length; i++) {\n                if (this.models[i])\n                    ms.push(this.models[i]);\n            }\n        }\n        else { // specific to some models\n            let selm = sel.model;\n            if (!Array.isArray(selm))\n                selm = [selm];\n            for (let i = 0; i < selm.length; i++) {\n                //allow referencing models by order of creation\n                if (typeof selm[i] === 'number') {\n                    var index = selm[i];\n                    //support python backward indexing\n                    if (index < 0)\n                        index += this.models.length;\n                    ms.push(this.models[index]);\n                }\n                else {\n                    ms.push(selm[i]);\n                }\n            }\n        }\n        return ms;\n    }\n    /**\n     *\n     * @param {AtomSelectionSpec}\n     *            sel\n     * @return {AtomSpec[]}\n     */\n    getAtomsFromSel(sel) {\n        var atoms = [];\n        if (typeof (sel) === \"undefined\")\n            sel = {};\n        var ms = this.getModelList(sel);\n        for (let i = 0; i < ms.length; i++) {\n            atoms = atoms.concat(ms[i].selectedAtoms(sel));\n        }\n        return atoms;\n    }\n    /**\n     *\n     * @param {AtomSpec}\n     *            atom\n     * @param {AtomSelectionSpec}\n     *            sel\n     * @return {boolean}\n     */\n    atomIsSelected(atom, sel) {\n        if (typeof (sel) === \"undefined\")\n            sel = {};\n        var ms = this.getModelList(sel);\n        for (var i = 0; i < ms.length; i++) {\n            if (ms[i].atomIsSelected(atom, sel))\n                return true;\n        }\n        return false;\n    }\n    /** return list of atoms selected by sel\n     *\n     * @param {AtomSelectionSpec} sel\n     * @return {AtomSpec[]}\n     */\n    selectedAtoms(sel) {\n        return this.getAtomsFromSel(sel);\n    }\n    ;\n    /**\n    * Returns valid values for the specified attribute in the given selection\n    * @param {string} attribute\n    * @param {AtomSelectionSpec} sel\n    * @return {Array.<Object>}\n    *\n    */\n    getUniqueValues(attribute, sel) {\n        if (typeof (sel) === \"undefined\")\n            sel = {};\n        var atoms = this.getAtomsFromSel(sel);\n        var values = {};\n        for (var atom in atoms) {\n            if (atoms[atom].hasOwnProperty(attribute)) {\n                var value = atoms[atom][attribute];\n                values[value] = true;\n            }\n        }\n        return Object.keys(values);\n    }\n    ;\n    /**\n     * Return pdb output of selected atoms (if atoms from pdb input)\n     *\n     * @param {AtomSelectionSpec} sel - Selection specification specifying model and atom properties to select.  Default: all atoms in viewer\n     * @return {string} PDB string of selected atoms\n     */\n    pdbData(sel) {\n        var atoms = this.getAtomsFromSel(sel);\n        var ret = \"\";\n        for (var i = 0, n = atoms.length; i < n; ++i) {\n            ret += atoms[i].pdbline + \"\\n\";\n        }\n        return ret;\n    }\n    ;\n    /**\n     * Zoom current view by a constant factor\n     *\n     * @param {number}\n     *            [factor] - Magnification factor. Values greater than 1\n     *            will zoom in, less than one will zoom out. Default 2.\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation\n     * @example\n    $3Dmol.get('data/4csv.pdb', function(data) {\n    viewer.addModel(data,'pdb');\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.zoomTo()\n    viewer.zoom(2,1000);\n    viewer.render();\n    });\n\n         */\n    zoom(factor = 2, animationDuration = 0, fixedPath = false) {\n        var scale = (this.CAMERA_Z - this.rotationGroup.position.z) / factor;\n        var final_z = this.CAMERA_Z - scale;\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath, this.modelGroup.position, this.adjustZoomToLimits(final_z), this.rotationGroup.quaternion, this.lookingAt);\n        }\n        else { //no animation\n            this.rotationGroup.position.z = this.adjustZoomToLimits(final_z);\n            this.show();\n        }\n        return this;\n    }\n    ;\n    /**\n     * Translate current view by x,y screen coordinates\n     * This pans the camera rather than translating the model.\n     *\n     * @param {number} x Relative change in view coordinates of camera\n     * @param {number} y Relative change in view coordinates of camera\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n     * @example     $3Dmol.get('data/4csv.pdb', function(data) {\n    viewer.addModel(data,'pdb');\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.zoomTo();\n    viewer.translate(200,50);\n    viewer.rotate(90,'z');\n    viewer.render(callback);\n    });\n     */\n    translate(x, y, animationDuration = 0, fixedPath = false) {\n        var dx = x / this.WIDTH;\n        var dy = y / this.HEIGHT;\n        var v = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, -this.CAMERA_Z);\n        this.projector.projectVector(v, this.camera);\n        v.x -= dx;\n        v.y -= dy;\n        this.projector.unprojectVector(v, this.camera);\n        v.z = 0;\n        var final_position = this.lookingAt.clone().add(v);\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, final_position);\n        }\n        else { //no animation\n            this.lookingAt = final_position;\n            this.camera.lookAt(this.lookingAt);\n            this.show();\n        }\n        return this;\n    }\n    ;\n    /**\n     * Translate current models by x,y screen coordinates\n     * This translates the models relative to the current view. It does\n     * not change the center of rotation.\n     *\n     * @param {number} x Relative change in x screen coordinate\n     * @param {number} y Relative change in y screen coordinate\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n     * @example     $3Dmol.get('data/4csv.pdb', function(data) {\n    viewer.addModel(data,'pdb');\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.zoomTo();\n    viewer.translateScene(200,50);\n    viewer.rotate(90,'z'); // will no longer be around model center\n    viewer.render(callback);\n    });\n     */\n    translateScene(x, y, animationDuration = 0, fixedPath = false) {\n        var t = this.screenOffsetToModel(x, y);\n        var final_position = this.modelGroup.position.clone().add(t);\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt);\n        }\n        else { //no animation\n            this.modelGroup.position = final_position;\n            this.show();\n        }\n        return this;\n    }\n    ;\n    /**\n     * Adjust slab to fully enclose selection (default everything).\n     *\n     * @param {AtomSelectionSpec} sel\n     *            Selection specification specifying model and atom\n     *            properties to select. Default: all atoms in viewer\n     */\n    fitSlab(sel) {\n        sel = sel || {};\n        var atoms = this.getAtomsFromSel(sel);\n        var tmp = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(atoms);\n        // fit to bounding box\n        var x = tmp[1][0] - tmp[0][0], y = tmp[1][1] - tmp[0][1], z = tmp[1][2] - tmp[0][2];\n        var maxD = Math.hypot(x, y, z);\n        if (maxD < 5)\n            maxD = 5;\n        // use full bounding box for slab/fog\n        this.slabNear = -maxD / 1.9;\n        this.slabFar = maxD / 2;\n        return this;\n    }\n    ;\n    /**\n     * Re-center the viewer around the provided selection (unlike zoomTo, does not zoom).\n     *\n     * @param {AtomSelectionSpec}\n     *            [sel] - Selection specification specifying model and atom\n     *            properties to select. Default: all atoms in viewer\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n     * @example // if the user were to pass the animationDuration value to\n     *           // the function like so viewer.zoomTo({resn:'STI'},1000);\n     *         //   the program would center on resn 'STI' over the course\n     *         //   of 1 second(1000 milleseconds).\n     *  // Reposition to centroid of all atoms of all models in this\n     * //viewer glviewer.center();\n    $3Dmol.get('data/4csv.pdb', function(data) {\n    viewer.addModel(data,'pdb');\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.center();\n    viewer.render(callback);\n    });\n     */\n    center(sel = {}, animationDuration = 0, fixedPath = false) {\n        var allatoms, alltmp;\n        var atoms = this.getAtomsFromSel(sel);\n        var tmp = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(atoms);\n        if ((0,_utilities__WEBPACK_IMPORTED_MODULE_3__.isEmptyObject)(sel)) {\n            //include shapes when zooming to full scene\n            //TODO: figure out a good way to specify shapes as part of a selection\n            this.shapes.forEach((shape) => {\n                if (shape && shape.boundingSphere && shape.boundingSphere.center) {\n                    var c = shape.boundingSphere.center;\n                    var r = shape.boundingSphere.radius;\n                    if (r > 0) {\n                        //make sure full shape is visible\n                        atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x + r, c.y, c.z));\n                        atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x - r, c.y, c.z));\n                        atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x, c.y + r, c.z));\n                        atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x, c.y - r, c.z));\n                        atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x, c.y, c.z + r));\n                        atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x, c.y, c.z - r));\n                    }\n                    else {\n                        atoms.push(c);\n                    }\n                }\n            });\n            tmp = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(atoms);\n            allatoms = atoms;\n            alltmp = tmp;\n        }\n        else {\n            allatoms = this.getAtomsFromSel({});\n            alltmp = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(allatoms);\n        }\n        // use selection for center\n        var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(tmp[2][0], tmp[2][1], tmp[2][2]);\n        // but all for bounding box\n        var x = alltmp[1][0] - alltmp[0][0], y = alltmp[1][1] -\n            alltmp[0][1], z = alltmp[1][2] - alltmp[0][2];\n        var maxD = Math.hypot(x, y, z);\n        if (maxD < 5)\n            maxD = 5;\n        // use full bounding box for slab/fog\n        this.slabNear = -maxD / 1.9;\n        this.slabFar = maxD / 2;\n        // for zoom, use selection box\n        x = tmp[1][0] - tmp[0][0];\n        y = tmp[1][1] - tmp[0][1];\n        z = tmp[1][2] - tmp[0][2];\n        maxD = Math.hypot(x, y, z);\n        if (maxD < 5)\n            maxD = 5;\n        //find the farthest atom from center to get max distance needed for view\n        var maxDsq = 25;\n        for (var i = 0; i < atoms.length; i++) {\n            if (atoms[i]) {\n                var dsq = center.distanceToSquared(atoms[i]);\n                if (dsq > maxDsq)\n                    maxDsq = dsq;\n            }\n        }\n        maxD = Math.sqrt(maxDsq) * 2;\n        var finalpos = center.clone().multiplyScalar(-1);\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath, finalpos, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt);\n        }\n        else { //no animation\n            this.modelGroup.position = finalpos;\n            this.show();\n        }\n        return this;\n    }\n    ;\n    /**\n     * Zoom to center of atom selection.  The slab will be set appropriately for\n     * the selection, unless an empty selection is provided, in which case there will be no slab.\n     *\n     * @param {Object}\n     *            [sel] - Selection specification specifying model and atom\n     *            properties to select. Default: all atoms in viewer\n     * @param {number}\n     *            [animationDuration] - an optional parameter that denotes\n     *            the duration of a zoom animation\n     * @param {Boolean} [fixedPath] - if true animation is constrained to\n     *      requested motion, overriding updates that happen during the animation         *\n      * @example\n\n\n          $3Dmol.get('data/1fas.pqr', function(data){\n              viewer.addModel(data, \"pqr\");\n          viewer.zoomTo();\n              $3Dmol.get(\"data/1fas.cube\",function(volumedata){\n                  viewer.addSurface($3Dmol.SurfaceType.VDW, {\n                      opacity:0.85,\n                      voldata: new $3Dmol.VolumeData(volumedata, \"cube\"),\n                      volscheme: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'charge'))\n                  },{});\n\n              viewer.render();\n              });\n            });\n     */\n    zoomTo(sel = {}, animationDuration = 0, fixedPath = false) {\n        let atoms = this.getAtomsFromSel(sel);\n        let atombox = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(atoms);\n        let allbox = atombox;\n        if ((0,_utilities__WEBPACK_IMPORTED_MODULE_3__.isEmptyObject)(sel)) {\n            //include shapes when zooming to full scene\n            //TODO: figure out a good way to specify shapes as part of a selection\n            let natoms = atoms && atoms.length;\n            this.shapes.forEach((shape) => {\n                if (shape && shape.boundingSphere) {\n                    if (shape.boundingSphere.box) {\n                        let box = shape.boundingSphere.box;\n                        atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(box.min.x, box.min.y, box.min.z));\n                        atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(box.max.x, box.max.y, box.max.z));\n                    }\n                    else if (shape.boundingSphere.center) {\n                        var c = shape.boundingSphere.center;\n                        var r = shape.boundingSphere.radius;\n                        if (r > 0) {\n                            //make sure full shape is visible\n                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x + r, c.y, c.z));\n                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x - r, c.y, c.z));\n                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x, c.y + r, c.z));\n                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x, c.y - r, c.z));\n                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x, c.y, c.z + r));\n                            atoms.push(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(c.x, c.y, c.z - r));\n                        }\n                        else {\n                            atoms.push(c);\n                        }\n                    }\n                }\n            });\n            allbox = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(atoms);\n            if (!natoms) { //if no atoms, use shapes for center\n                for (let i = 0; i < 3; i++) { //center of bounding box\n                    atombox[2][i] = (allbox[0][i] + allbox[1][i]) / 2;\n                }\n            }\n        }\n        else { //include all atoms in slab calculation\n            let allatoms = this.getAtomsFromSel({});\n            allbox = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(allatoms);\n        }\n        // use selection for center\n        var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(atombox[2][0], atombox[2][1], atombox[2][2]);\n        // but all for bounding box\n        var x = allbox[1][0] - allbox[0][0], y = allbox[1][1]\n            - allbox[0][1], z = allbox[1][2] - allbox[0][2];\n        var maxD = Math.hypot(x, y, z);\n        if (maxD < 5)\n            maxD = 5;\n        // use full bounding box for slab/fog\n        this.slabNear = -maxD / 1.9;\n        this.slabFar = maxD / 2;\n        //if we are selecting everything, have ver permissive slab\n        //can't do \"infinity\" size since this will break orthographic\n        if (Object.keys(sel).length === 0) {\n            this.slabNear = Math.min(-maxD * 2, -50);\n            this.slabFar = Math.max(maxD * 2, 50);\n        }\n        // keep at least this much space in view\n        var MAXD = this.config.minimumZoomToDistance || 5;\n        // for zoom, use selection box\n        x = atombox[1][0] - atombox[0][0];\n        y = atombox[1][1] - atombox[0][1];\n        z = atombox[1][2] - atombox[0][2];\n        maxD = Math.hypot(x, y, z);\n        if (maxD < MAXD)\n            maxD = MAXD;\n        //find the farthest atom from center to get max distance needed for view\n        var maxDsq = MAXD * MAXD;\n        for (var i = 0; i < atoms.length; i++) {\n            if (atoms[i]) {\n                var dsq = center.distanceToSquared(atoms[i]);\n                if (dsq > maxDsq)\n                    maxDsq = dsq;\n            }\n        }\n        maxD = Math.sqrt(maxDsq) * 2;\n        var finalpos = center.clone().multiplyScalar(-1);\n        var finalz = -(maxD * 0.5\n            / Math.tan(Math.PI / 180.0 * this.camera.fov / 2) - this.CAMERA_Z);\n        finalz = this.adjustZoomToLimits(finalz);\n        if (animationDuration > 0) {\n            this.animateMotion(animationDuration, fixedPath, finalpos, finalz, this.rotationGroup.quaternion, this.lookingAt);\n        }\n        else {\n            this.modelGroup.position = finalpos;\n            this.rotationGroup.position.z = finalz;\n            this.show();\n        }\n        return this;\n    }\n    ;\n    /**\n     * Set slab of view (contents outside of slab are clipped).\n     * Must call render to update.\n     *\n     * @param {number} near near clipping plane distance\n     * @param {number} far far clipping plane distance\n     */\n    setSlab(near, far) {\n        this.slabNear = near;\n        this.slabFar = far;\n    }\n    ;\n    /**\n     * Get slab of view (contents outside of slab are clipped).\n     *\n     * @return {Object}\n     *      @property {number} near - near clipping plane distance\n     *      @property {number} far - far clipping plane distance\n     */\n    getSlab() {\n        return { near: this.slabNear, far: this.slabFar };\n    }\n    ;\n    /**\n     * Add label to viewer\n     *\n     * @param {string}\n     *            text - Label text\n     * @param {LabelSpec}\n     *            options - Label style specification\n      @param {AtomSelection}\n     *            sel - Set position of label to center of this selection\n     * @param {boolean} noshow - if true, do not immediately display label - when adding multiple labels this is more efficient\n     * @return {Label}\n     *\n     * @example\n     *  $3Dmol.download(\"pdb:2EJ0\",viewer,{},function(){\n\n              viewer.addLabel(\"Aromatic\", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});\n              viewer.addLabel(\"Label\",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,\n                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,\n                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});\n              viewer.setStyle({chain:'A'},{cross:{hidden:true}});\n              viewer.setStyle({chain:'B'},{cross:{hidden:false,\n                                                  linewidth:1.0,\n                                                  colorscheme:'greenCarbon'}});\n              viewer.setStyle({chain:'C'},{cross:{hidden:false,\n                                                  linewidth:1.0,\n                                                  radius:0.5}});\n              viewer.setStyle({chain:'D'},{cross:{hidden:false,\n                                                  linewidth:10.0}});\n              viewer.setStyle({chain:'E'},{cross:{hidden:false,\n                                                  linewidth:1.0,\n                                                  color:'black'}});\n\n              viewer.render();\n\n\n            });\n\n     */\n    addLabel(text, options = {}, sel, noshow = false) {\n        if (sel) {\n            var extent = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(this.getAtomsFromSel(sel));\n            options.position = { x: extent[2][0], y: extent[2][1], z: extent[2][2] };\n        }\n        var label = new _Label__WEBPACK_IMPORTED_MODULE_6__.Label(text, options);\n        label.setContext();\n        this.modelGroup.add(label.sprite);\n        this.labels.push(label);\n        if (!noshow)\n            this.show();\n        return label;\n    }\n    ;\n    /** Add residue labels.  This will generate one label per a\n     * residue within the selected atoms.  The label will be at the\n     * centroid of the atoms and styled according to the passed style.\n     * The label text will be [resn][resi]\n     *\n     * @param {AtomSelectionSpec} sel\n     * @param {AtomStyleSpec} style\n     * @param {boolean} byframe - if true, create labels for every individual frame, not just current\n     *\n     * @example\n         $3Dmol.download(\"mmtf:2ll5\",viewer,{},function(){\n              viewer.setStyle({stick:{radius:0.15},cartoon:{}});\n              viewer.addResLabels({hetflag:false}, {font: 'Arial', fontColor:'black',showBackground:false, screenOffset: {x:0,y:0}});\n              viewer.zoomTo();\n              viewer.render();\n            });\n     */\n    addResLabels(sel, style, byframe = false) {\n        let start = this.labels.length;\n        this.applyToModels(\"addResLabels\", sel, this, style, byframe);\n        this.show();\n        return this.labels.slice(start);\n    }\n    ;\n    /** Add property labels.  This will generate one label per a selected\n     * atom at the atom's coordinates with the property value as the label text.\n     *\n     * @param {string} prop - property name\n     * @param {AtomSelectionSpec} sel\n     * @param {AtomStyleSpec} style\n     *\n     * * @example\n         $3Dmol.download(\"cid:5291\",viewer,{},function(){\n              viewer.setStyle({stick: {radius:.2}});\n              viewer.addPropertyLabels(\"index\",{not:{elem:'H'}}, {fontColor:'black',font: 'sans-serif', fontSize: 28, showBackground:false,alignment:'center'});\n              viewer.zoomTo();\n              viewer.render();\n            });\n     */\n    addPropertyLabels(prop, sel, style) {\n        this.applyToModels(\"addPropertyLabels\", prop, sel, this, style);\n        this.show();\n        return this;\n    }\n    ;\n    /**\n     * Remove label from viewer\n     *\n     * @param {Label} label - $3Dmol label\n     *\n     * @example // Remove labels created in\n     $3Dmol.download(\"pdb:2EJ0\",viewer,{},function(){\n              var toremove = viewer.addLabel(\"Aromatic\", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});\n              viewer.addLabel(\"Label\",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,\n                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,\n                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});\n              viewer.removeLabel(toremove);\n              viewer.render();\n\n\n            });\n\n     */\n    removeLabel(label) {\n        //todo: don't do the linear search\n        for (var i = 0; i < this.labels.length; i++) {\n            if (this.labels[i] == label) {\n                this.labels.splice(i, 1);\n                label.dispose();\n                this.modelGroup.remove(label.sprite);\n                break;\n            }\n        }\n        this.show();\n        return this;\n    }\n    ;\n    /**\n     * Remove all labels from viewer\n     *\n     *         @example\n    $3Dmol.download(\"pdb:1ubq\",viewer,{},function(){\n\n           viewer.addResLabels();\n           viewer.setStyle({},{stick:{}});\n           viewer.render( ); //show labels\n\n           viewer.removeAllLabels();\n           viewer.render(); //hide labels\n    });\n     */\n    removeAllLabels() {\n        for (var i = 0; i < this.labels.length; i++) {\n            if (this.labels[i] && this.labels[i].sprite) {\n                this.modelGroup.remove(this.labels[i].sprite);\n            }\n        }\n        this.labels.splice(0, this.labels.length); //don't overwrite in case linked\n        this.show();\n        return this;\n    }\n    ;\n    // Modify label style\n    /**\n     * Modify existing label's style\n     *\n     * @param {Label} label - $3Dmol label\n     * @param {LabelSpec}\n     *            stylespec - Label style specification\n     * @return {Label}\n     */\n    setLabelStyle(label, stylespec) {\n        this.modelGroup.remove(label.sprite);\n        label.dispose();\n        label.stylespec = stylespec;\n        label.setContext();\n        this.modelGroup.add(label.sprite);\n        this.show();\n        return label;\n    }\n    ;\n    // Change label text\n    /**\n     * Modify existing label's text\n     *\n     * @param {Label}  label - $3Dmol label\n     * @param {String}\n     *            text - Label text\n     * @return {Label}\n     */\n    setLabelText(label, text) {\n        this.modelGroup.remove(label.sprite);\n        label.dispose();\n        label.text = text;\n        label.setContext();\n        this.modelGroup.add(label.sprite);\n        this.show();\n        return label;\n    }\n    ;\n    /**\n     * Add shape object to viewer\n     * @see {GLShape}\n     *\n     * @param {ShapeSpec} shapeSpec - style specification for label\n     * @return {GLShape}\n     */\n    addShape(shapeSpec) {\n        shapeSpec = shapeSpec || {};\n        var shape = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(shapeSpec);\n        shape.shapePosition = this.shapes.length;\n        this.shapes.push(shape);\n        return shape;\n    }\n    ;\n    /**\n     * Remove shape object from viewer\n     *\n     * @param {GLShape} shape - Reference to shape object to remove\n     */\n    removeShape(shape) {\n        if (!shape)\n            return this;\n        shape.removegl(this.modelGroup);\n        delete this.shapes[shape.shapePosition];\n        // clear off back of model array\n        while (this.shapes.length > 0\n            && typeof (this.shapes[this.shapes.length - 1]) === \"undefined\")\n            this.shapes.pop();\n        return this;\n    }\n    ;\n    /**\n     * Remove all shape objects from viewer\n     */\n    removeAllShapes() {\n        for (var i = 0; i < this.shapes.length; i++) {\n            var shape = this.shapes[i];\n            if (shape)\n                shape.removegl(this.modelGroup);\n        }\n        this.shapes.splice(0, this.shapes.length);\n        return this;\n    }\n    ;\n    //gets the center of the selection\n    getSelectionCenter(spec) {\n        if (spec.hasOwnProperty(\"x\") && spec.hasOwnProperty(\"y\") && spec.hasOwnProperty(\"z\"))\n            return spec;\n        var atoms = this.getAtomsFromSel(spec);\n        if (atoms.length == 0)\n            return { x: 0, y: 0, z: 0 };\n        var extent = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(atoms);\n        return { x: extent[0][0] + (extent[1][0] - extent[0][0]) / 2, y: extent[0][1] + (extent[1][1] - extent[0][1]) / 2, z: extent[0][2] + (extent[1][2] - extent[0][2]) / 2 };\n    }\n    ;\n    /**\n     * Create and add sphere shape. This method provides a shorthand\n     * way to create a spherical shape object\n     *\n     * @param {SphereShapeSpec} spec - Sphere shape style specification\n     * @return {GLShape}\n     @example\n\n     viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});\n\n     viewer.render();\n     */\n    addSphere(spec) {\n        spec = spec || {};\n        spec.center = this.getSelectionCenter(spec.center);\n        var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addSphere(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    }\n    ;\n    /**\n     * Create and add box shape. This method provides a shorthand\n     * way to create a box shape object\n     *\n     * @param {BoxSpec} spec - Box shape style specification\n     * @return {GLShape}\n     @example\n\n     viewer.addLine({color:'red',start:{x:0,y:0,z:0},end:{x:5,y:0,z:0}});\n     viewer.addLine({color:'blue',start:{x:0,y:0,z:0},end:{x:0,y:5,z:0}});\n     viewer.addLine({color:'green',start:{x:0,y:0,z:0},end:{x:0,y:0,z:5}});\n\n     viewer.addBox({center:{x:0,y:0,z:0},dimensions: {w:3,h:4,d:2},color:'magenta'});\n     viewer.zoomTo();\n     viewer.rotate(45, {x:1,y:1,z:1});\n     viewer.render();\n     */\n    addBox(spec = {}) {\n        if (spec.corner != undefined) {\n            spec.corner = this.getSelectionCenter(spec.corner);\n        }\n        if (spec.center != undefined) {\n            spec.center = this.getSelectionCenter(spec.center);\n        }\n        var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addBox(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    }\n    ;\n    /**\n     * Create and add arrow shape\n     *\n     * @param {ArrowSpec} spec - Style specification\n     * @return {GLShape}\n     @example\n    $3Dmol.download(\"pdb:4DM7\",viewer,{},function(){\n\n              viewer.setBackgroundColor(0xffffffff);\n              viewer.addArrow({\n                  start: {x:-10.0, y:0.0, z:0.0},\n                  end: {x:0.0, y:-10.0, z:0.0},\n                  radius: 1.0,\n                  radiusRadio:1.0,\n                  mid:1.0,\n                  clickable:true,\n                  callback:function(){\n                      this.color.setHex(0xFF0000FF);\n                      viewer.render( );\n                  }\n              });\n              viewer.render();\n            });\n     */\n    addArrow(spec = {}) {\n        spec.start = this.getSelectionCenter(spec.start);\n        spec.end = this.getSelectionCenter(spec.end);\n        var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addArrow(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    }\n    ;\n    /**\n     * Create and add cylinder shape\n     *\n     * @param {CylinderSpec} spec - Style specification\n     * @return {GLShape}\n\n      @example\n     viewer.setBackgroundColor(0xffffffff);\n          viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},\n                              end:{x:10.0,y:0.0,z:0.0},\n                              radius:1.0,\n                              fromCap:1,\n                              toCap:2,\n                              color:'red',\n                              hoverable:true,\n                              clickable:true,\n                              callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},\n                              hover_callback: function(){ viewer.render( );},\n                              unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}\n                             });\n          viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},\n                              end:{x:0.0,y:10.0,z:0.0},\n                              radius:0.5,\n                              fromCap:false,\n                              toCap:true,\n                              color:'teal'});\n          viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},\n                              end:{x:20.0,y:0.0,z:0.0},\n                              radius:1.0,\n                              color:'black',\n                              fromCap:false,\n                              toCap:false});\n          viewer.render();\n     */\n    addCylinder(spec = {}) {\n        spec.start = this.getSelectionCenter(spec.start);\n        spec.end = this.getSelectionCenter(spec.end);\n        var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        if (spec.dashed)\n            s.addDashedCylinder(spec);\n        else\n            s.addCylinder(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    }\n    ;\n    /**\n     * Create and add Curve shape\n     *\n     * @param {CurveSpec} spec - Style specification\n     * @return {GLShape}\n\n     @example\n          viewer.addCurve({points: [{x:0.0,y:0.0,z:0.0}, {x:5.0,y:3.0,z:0.0}, {x:5.0,y:7.0,z:0.0}, {x:0.0,y:10.0,z:0.0}],\n                              radius:0.5,\n                              smooth: 10,\n                              fromArrow:false,\n                              toArrow: true,\n                              color:'orange',\n                              });\n          viewer.addCurve({points: [{x:-1,y:0.0,z:0.0}, {x:-5.0,y:5.0,z:0.0}, {x:-2,y:10.0,z:0.0}],\n                              radius:1,\n                              fromArrow:true,\n                              toArrow: false,\n                              color:'purple',\n                              });\n          viewer.zoomTo();\n          viewer.render();\n     */\n    addCurve(spec = {}) {\n        var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addCurve(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    }\n    ;\n    /**\n     * Create and add line shape\n     *\n     * @param {LineSpec} spec - Style specification, can specify dashed, dashLength, and gapLength\n     * @return {GLShape}\n     @example\n     $3Dmol.download(\"pdb:2ABJ\",viewer,{},function(){\n\n              viewer.setViewStyle({style:\"outline\"});\n              viewer.setStyle({chain:'A'},{sphere:{hidden:true}});\n              viewer.setStyle({chain:'D'},{sphere:{radius:3.0}});\n              viewer.setStyle({chain:'G'},{sphere:{colorscheme:'greenCarbon'}});\n              viewer.setStyle({chain:'J'},{sphere:{color:'blue'}});\n              viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});\n              viewer.render();\n          });\n\n     */\n    addLine(spec = {}) {\n        spec.start = this.getSelectionCenter(spec.start);\n        spec.end = this.getSelectionCenter(spec.end);\n        spec.wireframe = true;\n        var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        if (spec.dashed)\n            s = this.addLineDashed(spec, s);\n        else\n            s.addLine(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    }\n    ;\n    /**\n     * Create and add unit cell visualization.\n     *\n     * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.\n     * @param {UnitCellStyleSpec} spec - visualization style\n       @example\n\n            $3Dmol.get('data/1jpy.cif', function(data) {\n              let m = viewer.addModel(data);\n              viewer.addUnitCell(m, {box:{color:'purple'},alabel:'X',blabel:'Y',clabel:'Z',alabelstyle: {fontColor: 'black',backgroundColor:'white',inFront:true,fontSize:40},astyle:{color:'darkred', radius:5,midpos: -10}});\n              viewer.zoomTo();\n              viewer.render();\n    });\n     */\n    addUnitCell(model, spec) {\n        model = this.getModel(model);\n        spec = spec || { alabel: 'a', blabel: 'b', clabel: 'c' };\n        spec.box = spec.box || {};\n        spec.astyle = spec.astyle || { color: 'red', radius: 0.1, midpos: -1 };\n        spec.bstyle = spec.bstyle || { color: 'green', radius: 0.1, midpos: -1 };\n        spec.cstyle = spec.cstyle || { color: 'blue', radius: 0.1, midpos: -1 };\n        spec.alabelstyle = spec.alabelstyle || { fontColor: 'red', showBackground: false, alignment: 'center', inFront: false };\n        spec.blabelstyle = spec.blabelstyle || { fontColor: 'green', showBackground: false, alignment: 'center', inFront: false };\n        spec.clabelstyle = spec.clabelstyle || { fontColor: 'blue', showBackground: false, alignment: 'center', inFront: false };\n        //clear any previous box\n        if (model.unitCellObjects) {\n            this.removeUnitCell(model);\n        }\n        model.unitCellObjects = { shapes: [], labels: [] };\n        //calculate points\n        var data = model.getCrystData();\n        var matrix = null;\n        if (data) {\n            if (data.matrix) {\n                matrix = data.matrix;\n            }\n            else {\n                var a = data.a, b = data.b, c = data.c, alpha = data.alpha, beta = data.beta, gamma = data.gamma;\n                alpha = alpha * Math.PI / 180.0;\n                beta = beta * Math.PI / 180.0;\n                gamma = gamma * Math.PI / 180.0;\n                var u, v, w;\n                u = Math.cos(beta);\n                v = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);\n                w = Math.sqrt(Math.max(0, 1 - u * u - v * v));\n                matrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix3(a, b * Math.cos(gamma), c * u, 0, b * Math.sin(gamma), c * v, 0, 0, c * w);\n            }\n            var points = [new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0),\n                new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 0, 0),\n                new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0),\n                new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 1),\n                new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 0),\n                new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 1),\n                new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 0, 1),\n                new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1)];\n            // console.log('Matrix4', data.matrix4, data.matrix);\n            if (data.matrix4) {\n                for (let i = 0; i < points.length; i++) {\n                    if (data.size)\n                        points[i].multiplyVectors(points[i], data.size); //matrix is for unit vectors, not whole box\n                    points[i] = points[i].applyMatrix4(data.matrix4);\n                }\n            }\n            else {\n                for (let i = 0; i < points.length; i++) {\n                    points[i] = points[i].applyMatrix3(matrix);\n                }\n            }\n            //draw box\n            if (spec.box && !spec.box.hidden) {\n                spec.box.wireframe = true;\n                var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec.box);\n                s.shapePosition = this.shapes.length;\n                s.addLine({ start: points[0], end: points[1] });\n                s.addLine({ start: points[0], end: points[2] });\n                s.addLine({ start: points[1], end: points[4] });\n                s.addLine({ start: points[2], end: points[4] });\n                s.addLine({ start: points[0], end: points[3] });\n                s.addLine({ start: points[3], end: points[5] });\n                s.addLine({ start: points[2], end: points[5] });\n                s.addLine({ start: points[1], end: points[6] });\n                s.addLine({ start: points[4], end: points[7] });\n                s.addLine({ start: points[6], end: points[7] });\n                s.addLine({ start: points[3], end: points[6] });\n                s.addLine({ start: points[5], end: points[7] });\n                this.shapes.push(s);\n                model.unitCellObjects.shapes.push(s);\n                s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n            }\n            //draw arrows\n            if (!spec.astyle.hidden) {\n                spec.astyle.start = points[0];\n                spec.astyle.end = points[1];\n                let arrow = this.addArrow(spec.astyle);\n                model.unitCellObjects.shapes.push(arrow);\n            }\n            if (!spec.bstyle.hidden) {\n                spec.bstyle.start = points[0];\n                spec.bstyle.end = points[2];\n                let arrow = this.addArrow(spec.bstyle);\n                model.unitCellObjects.shapes.push(arrow);\n            }\n            if (!spec.cstyle.hidden) {\n                spec.cstyle.start = points[0];\n                spec.cstyle.end = points[3];\n                let arrow = this.addArrow(spec.cstyle);\n                model.unitCellObjects.shapes.push(arrow);\n            }\n            if (spec.alabel) {\n                spec.alabelstyle.position = points[1];\n                let label = this.addLabel(spec.alabel, spec.alabelstyle);\n                model.unitCellObjects.labels.push(label);\n            }\n            if (spec.blabel) {\n                spec.blabelstyle.position = points[2];\n                let label = this.addLabel(spec.blabel, spec.blabelstyle);\n                model.unitCellObjects.labels.push(label);\n            }\n            if (spec.clabel) {\n                spec.clabelstyle.position = points[3];\n                let label = this.addLabel(spec.clabel, spec.clabelstyle);\n                model.unitCellObjects.labels.push(label);\n            }\n        }\n    }\n    ;\n    /**\n    * Remove unit cell visualization from model.\n    *\n    * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.\n      @example\n           $3Dmol.get('data/icsd_200866.cif', function(data) {\n             let m = viewer.addModel(data);\n             viewer.setStyle({sphere:{}})\n             viewer.addUnitCell();\n             viewer.zoomTo();\n             viewer.removeUnitCell();\n             viewer.render();\n       });\n    */\n    removeUnitCell(model) {\n        model = this.getModel(model);\n        if (model.unitCellObjects) {\n            let viewer = this;\n            model.unitCellObjects.shapes.forEach(function (s) { viewer.removeShape(s); });\n            model.unitCellObjects.labels.forEach(function (l) { viewer.removeLabel(l); });\n        }\n        delete model.unitCellObjects;\n    }\n    ;\n    /**\n    * Replicate atoms in model to form a super cell of the specified dimensions.\n    * Original cell will be centered as much as possible.\n    *\n    * @param {integer} A - number of times to replicate cell in X dimension.\n    * @param {integer} B - number of times to replicate cell in Y dimension.  If absent, X value is used.\n    * @param {integer} C - number of times to replicate cell in Z dimension.  If absent, Y value is used.\n    * @param {GLModel} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.\n    * @param {boolean} addBonds - Create bonds between unit cells based on distances.\n    * @param {boolean} prune - Keep only atoms that are within the original unit cell (i.e., on edges).  Alternatively, call replicateUnitCell(1).\n      @example\n           $3Dmol.get('data/icsd_200866.cif', function(data) {\n             let m = viewer.addModel(data);\n             viewer.setStyle({sphere:{scale:.25}})\n             viewer.addUnitCell();\n             viewer.zoomTo();\n             viewer.replicateUnitCell(3,2,1,m);\n             viewer.render();\n       });\n    */\n    replicateUnitCell(A = 3, B = A, C = B, model, addBonds, prune) {\n        model = this.getModel(model);\n        let cryst = model.getCrystData();\n        if (cryst) {\n            const atoms = model.selectedAtoms({});\n            const matrix = cryst.matrix;\n            let makeoff = function (I) {\n                //alternate around zero: 1,-1,2,-2...\n                if (I % 2 == 0)\n                    return -I / 2;\n                else\n                    return Math.ceil(I / 2);\n            };\n            if (A <= 1 && B <= 1 && C <= 1) {\n                prune = true;\n                A = B = C = 3;\n            }\n            let omitPosition = function (x, y, z) { return false; };\n            if (prune) {\n                const invmatrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix3().getInverse3(matrix);\n                omitPosition = function (x, y, z) {\n                    //must reside within unit cell\n                    let pos = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(x, y, z).applyMatrix3(invmatrix);\n                    if (pos.x > -0.0001 && pos.x < 1.0001 &&\n                        pos.y > -0.0001 && pos.y < 1.0001 &&\n                        pos.z > -0.0001 && pos.z < 1.0001) {\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                };\n            }\n            for (let i = 0; i < A; i++) {\n                for (let j = 0; j < B; j++) {\n                    for (let k = 0; k < C; k++) {\n                        if (i == 0 && j == 0 && k == 0)\n                            continue; //actual unit cell\n                        let offset = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(makeoff(i), makeoff(j), makeoff(k));\n                        offset.applyMatrix3(matrix);\n                        let newatoms = [];\n                        for (let a = 0; a < atoms.length; a++) {\n                            let newx = atoms[a].x + offset.x, newy = atoms[a].y + offset.y, newz = atoms[a].z + offset.z;\n                            if (omitPosition(newx, newy, newz)) {\n                                continue;\n                            }\n                            let newAtom = {};\n                            for (let p in atoms[a]) {\n                                newAtom[p] = atoms[a][p];\n                            }\n                            newAtom.x = newx;\n                            newAtom.y = newy;\n                            newAtom.z = newz;\n                            newatoms.push(newAtom);\n                        }\n                        model.addAtoms(newatoms);\n                    }\n                }\n            }\n            if (addBonds) {\n                model.assignBonds();\n            }\n        }\n    }\n    ;\n    /** Add dashed line to shape */\n    addLineDashed(spec, s) {\n        spec.dashLength = spec.dashLength || 0.5;\n        spec.gapLength = spec.gapLength || 0.5;\n        var p1;\n        if (!spec.start) {\n            p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n        }\n        else {\n            p1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(spec.start.x || 0, spec.start.y || 0, spec.start.z || 0);\n        }\n        var p2;\n        if (!spec.end)\n            p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n        else\n            p2 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(spec.end.x, spec.end.y || 0, spec.end.z || 0);\n        var dir = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        var dash = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        var gap = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        var length, dashAmt, gapAmt;\n        var temp = p1.clone();\n        var drawn = 0;\n        dir.subVectors(p2, p1);\n        length = dir.length();\n        dir.normalize();\n        dash = dir.clone();\n        gap = dir.clone();\n        dash.multiplyScalar(spec.dashLength);\n        gap.multiplyScalar(spec.gapLength);\n        dashAmt = dash.length();\n        gapAmt = gap.length();\n        while (drawn < length) {\n            if ((drawn + dashAmt) > length) {\n                spec.start = p1;\n                spec.end = p2;\n                s.addLine(spec);\n                break;\n            }\n            temp.addVectors(p1, dash);\n            spec.start = p1;\n            spec.end = temp;\n            s.addLine(spec);\n            p1 = temp.clone();\n            drawn += dashAmt;\n            temp.addVectors(p1, gap);\n            p1 = temp.clone();\n            drawn += gapAmt;\n        }\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    }\n    /**\n     * Add custom shape component from user supplied function\n     *\n     * @param {CustomSpec} spec - Style specification\n     * @return {GLShape}\n     @example\n     function triangle(viewer) {\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var r = 20;\n        //triangle\n        vertices.push(new $3Dmol.Vector3(0,0,0));\n        vertices.push(new $3Dmol.Vector3(r,0,0));\n        vertices.push(new $3Dmol.Vector3(0,r,0));\n\n        normals.push(new $3Dmol.Vector3(0,0,1));\n        normals.push(new $3Dmol.Vector3(0,0,1));\n        normals.push(new $3Dmol.Vector3(0,0,1));\n\n        colors.push({r:1,g:0,b:0});\n        colors.push({r:0,g:1,b:0});\n        colors.push({r:0,g:0,b:1});\n\n        var faces = [ 0,1,2 ];\n\n        var spec = {vertexArr:vertices, normalArr: normals, faceArr:faces,color:colors};\n        viewer.addCustom(spec);\n    }\n    triangle(viewer);\n    viewer.render();\n     */\n    addCustom(spec) {\n        spec = spec || {};\n        var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addCustom(spec);\n        this.shapes.push(s);\n        s.finalize(); //finalize shape for memory efficiency, assume shape won't be extended\n        return s;\n    }\n    ;\n    /**\n     * Construct isosurface from volumetric data in gaussian cube format\n     * @param {String} data - Input file contents\n     * @param {String} format - Input file format\n     * @param {VolumetricRendererSpec|IsoSurfaceSpec} spec - Shape style specification\n     * @return {GLShape}\n     *\n     * @example\n\n\n    $3Dmol.get('data/bohr.cube', function(data) {\n\n    viewer.addVolumetricData(data, \"cube\", {isoval: -0.01, color: \"red\", opacity: 0.95});\n    viewer.setStyle({cartoon:{},stick:{}});\n    viewer.zoomTo();\n    viewer.render();\n    });\n\n\n     */\n    addVolumetricData(data, format, spec = {}) {\n        var voldata = new _VolumeData__WEBPACK_IMPORTED_MODULE_8__.VolumeData(data, format);\n        if (spec.hasOwnProperty('transferfn')) { //volumetric rendering\n            return this.addVolumetricRender(voldata, spec);\n        }\n        else {\n            return this.addIsosurface(voldata, spec);\n        }\n    }\n    ;\n    /**\n     * Construct isosurface from volumetric data.  This is more flexible\n    * than addVolumetricData, but can not be used with py3Dmol.\n     * @param {VolumeData} data - volumetric data\n     * @param {IsoSurfaceSpec} spec - Shape style specification\n     * @return {GLShape}\n     *\n     @example\n     $3Dmol.get('../test_structs/benzene-homo.cube', function(data){\n              var voldata = new $3Dmol.VolumeData(data, \"cube\");\n              viewer.addIsosurface(voldata, {isoval: 0.01,\n                                             color: \"blue\"});\n              viewer.addIsosurface(voldata, {isoval: -0.01,\n                                             color: \"red\"});\n              viewer.zoomTo();\n              viewer.render();\n            });\n     */\n    addIsosurface(data, spec = {}, callback) {\n        var s = new _GLShape__WEBPACK_IMPORTED_MODULE_7__.GLShape(spec);\n        s.shapePosition = this.shapes.length;\n        s.addIsosurface(data, spec, callback, this);\n        this.shapes.push(s);\n        return s;\n    }\n    ;\n    /**\n     * Create volumetric renderer for volumetricData\n     * @param {VolumeData} data - volumetric data\n     * @param {VolumetricRenderSpec} spec - specification of volumetric render\n     *\n     * @return {GLShape}\n     *\n     */\n    addVolumetricRender(data, spec) {\n        spec = spec || {};\n        var s = new _VolumetricRender__WEBPACK_IMPORTED_MODULE_10__.GLVolumetricRender(data, spec, this);\n        s.shapePosition = this.shapes.length;\n        this.shapes.push(s);\n        return s;\n    }\n    ;\n    /**\n     * Return true if volumetric rendering is supported (WebGL 2.0 required)\n     *\n     * @return {boolean}\n     */\n    hasVolumetricRender() {\n        return this.renderer.supportsVolumetric();\n    }\n    ;\n    /**\n     * Enable/disable fog for content far from the camera\n     *\n     * @param {boolean} fog whether to enable or disable the fog\n     */\n    enableFog(fog) {\n        if (fog) {\n            this.scene.fog = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Fog(this.bgColor, 100, 200);\n        }\n        else {\n            this.config.disableFog = true;\n            this.show();\n        }\n    }\n    ;\n    /**\n     * Sets the atomlists of all models in the viewer to specified frame.\n     * Shapes and labels can also be displayed by frame.\n     * Sets to last frame if framenum out of range\n     *\n     * @param {number} framenum - fame index to use, starts at zero\n     * @return {Promise}\n     */\n    setFrame(framenum) {\n        this.viewer_frame = framenum;\n        let viewer = this;\n        return new Promise(function (resolve) {\n            var modelMap = viewer.models.map(function (model) {\n                return model.setFrame(framenum, viewer);\n            });\n            Promise.all(modelMap)\n                .then(function () { resolve(); });\n        });\n    }\n    ;\n    /**\n     * Gets the current viewer frame.\n     *\n     */\n    getFrame() {\n        return this.viewer_frame;\n    }\n    ;\n    /**\n     * Returns the number of frames that the model with the most frames in the viewer has\n     *\n     * @return {number}\n     */\n    getNumFrames() {\n        var mostFrames = 0;\n        for (let i = 0; i < this.models.length; i++) {\n            if (this.models[i].getNumFrames() > mostFrames) {\n                mostFrames = this.models[i].getNumFrames();\n            }\n        }\n        for (let i = 0; i < this.shapes.length; i++) {\n            if (this.shapes[i].frame && this.shapes[i].frame >= mostFrames) {\n                mostFrames = this.shapes[i].frame + 1;\n            }\n        }\n        for (let i = 0; i < this.labels.length; i++) {\n            if (this.labels[i].frame && this.labels[i].frame >= mostFrames) {\n                mostFrames = this.labels[i].frame + 1;\n            }\n        }\n        return mostFrames;\n    }\n    ;\n    /**\n     * Animate all models in viewer from their respective frames\n     * @param {Object} options - can specify interval (speed of animation), loop (direction\n     * of looping, 'backward', 'forward' or 'backAndForth'), step interval between frames ('step'), startFrame, and reps (numer of repetitions, 0 indicates infinite loop)\n     *\n     */\n    animate(options) {\n        this.incAnim();\n        var interval = 100;\n        var loop = \"forward\";\n        var reps = Infinity;\n        options = options || {};\n        if (options.interval) {\n            interval = options.interval;\n        }\n        if (options.loop) {\n            ``;\n            loop = options.loop;\n        }\n        if (options.reps) {\n            reps = options.reps;\n        }\n        var mostFrames = this.getNumFrames();\n        var self = this;\n        var currFrame = 0;\n        if (options.startFrame) {\n            currFrame = options.startFrame % mostFrames;\n        }\n        var inc = 1;\n        if (options.step) {\n            inc = options.step;\n            reps /= inc;\n        }\n        var displayCount = 0;\n        var displayMax = mostFrames * reps;\n        var time = new Date();\n        var resolve, timer;\n        var display = function (direction) {\n            time = new Date();\n            if (direction == \"forward\") {\n                self.setFrame(currFrame)\n                    .then(function () {\n                    currFrame = (currFrame + inc) % mostFrames;\n                    resolve();\n                });\n            }\n            else if (direction == \"backward\") {\n                self.setFrame((mostFrames - 1) - currFrame)\n                    .then(function () {\n                    currFrame = (currFrame + inc) % mostFrames;\n                    resolve();\n                });\n            }\n            else { //back and forth\n                self.setFrame(currFrame)\n                    .then(function () {\n                    currFrame += inc;\n                    inc *= (((currFrame % (mostFrames - 1)) == 0) ? -1 : 1);\n                    resolve();\n                });\n            }\n        };\n        resolve = function () {\n            self.render();\n            if (!self.getCanvas().isConnected) {\n                //we no longer exist as part of the DOM\n                self.stopAnimate();\n            }\n            else if (++displayCount >= displayMax || !self.isAnimated()) {\n                timer.cancel();\n                self.animationTimers.delete(timer);\n                self.decAnim();\n            }\n            else {\n                var newInterval = interval - (new Date().getTime() - time.getTime());\n                newInterval = (newInterval > 0) ? newInterval : 0;\n                self.animationTimers.delete(timer);\n                timer = new _utilities__WEBPACK_IMPORTED_MODULE_3__.PausableTimer(display, newInterval, loop);\n                self.animationTimers.add(timer);\n            }\n        };\n        timer = new _utilities__WEBPACK_IMPORTED_MODULE_3__.PausableTimer(display, 0, loop);\n        this.animationTimers.add(timer);\n        return this;\n    }\n    ;\n    /**\n     * Stop animation of all models in viewer\n     */\n    stopAnimate() {\n        this.animated = 0;\n        this.animationTimers.forEach(function (timer) { timer.cancel(); });\n        this.animationTimers = new Set();\n        return this;\n    }\n    ;\n    /**\n     * Pause animation of all models in viewer\n     */\n    pauseAnimate() {\n        this.animationTimers.forEach(function (timer) { timer.pause(); });\n        return this;\n    }\n    ;\n    /**\n     * Resume animation of all models in viewer\n     */\n    resumeAnimate() {\n        this.animationTimers.forEach(function (timer) { timer.resume(); });\n        return this;\n    }\n    ;\n    /**\n     * Return true if viewer is currently being animated, false otherwise\n     * @return {boolean}\n     */\n    isAnimated() {\n        return this.animated > 0;\n    }\n    ;\n    //setup options dict\n    getModelOpt(options) {\n        if (options && !options.defaultcolors) {\n            options.defaultcolors = this.defaultcolors;\n            options.cartoonQuality = options.cartoonQuality || this.config.cartoonQuality;\n        }\n        else if (typeof (options) === 'undefined') {\n            options = { defaultcolors: this.defaultcolors, cartoonQuality: this.config.cartoonQuality };\n        }\n        return options;\n    }\n    /**\n     * Create and add model to viewer, given molecular data and its format\n     *\n     * @param {string} data - Input data\n     * @param {string} format - Input format ('pdb', 'sdf', 'xyz', 'pqr', or 'mol2')\n     * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input file format.\n     * @example\n\n\n          viewer.setViewStyle({style:\"outline\"});\n          $3Dmol.get('data/1fas.pqr', function(data){\n              viewer.addModel(data, \"pqr\");\n              $3Dmol.get(\"data/1fas.cube\",function(volumedata){\n                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, \"cube\"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});\n\n              viewer.render();\n              });\n              viewer.zoomTo();\n          });\n     *\n     * @return {GLModel}\n     */\n    addModel(data, format = \"\", options) {\n        options = this.getModelOpt(options);\n        var m = new _GLModel__WEBPACK_IMPORTED_MODULE_5__.GLModel(this.models.length, options);\n        m.addMolData(data, format, options);\n        this.models.push(m);\n        return m;\n    }\n    ;\n    /**\n     * Given multimodel file and its format, add atom data to the viewer as separate models\n     * and return list of these models\n     *\n     * @param {string} data - Input data\n     * @param {string} format - Input format (see {@link FileFormats})\n     * @return {Array<GLModel>}\n     */\n    addModels(data, format, options) {\n        options = this.getModelOpt(options);\n        options.multimodel = true;\n        options.frames = true;\n        var modelatoms = _GLModel__WEBPACK_IMPORTED_MODULE_5__.GLModel.parseMolData(data, format, options);\n        for (var i = 0; i < modelatoms.length; i++) {\n            var newModel = new _GLModel__WEBPACK_IMPORTED_MODULE_5__.GLModel(this.models.length, options);\n            newModel.setAtomDefaults(modelatoms[i]);\n            newModel.addFrame(modelatoms[i]);\n            newModel.setFrame(0);\n            if (modelatoms.modelData)\n                newModel.setModelData(modelatoms.modelData[i]);\n            newModel.setDontDuplicateAtoms(!options.duplicateAssemblyAtoms);\n            this.models.push(newModel);\n        }\n        return this.models;\n    }\n    ;\n    /**\n     * Create and add model to viewer. Given multimodel file and its format,\n     * different atomlists are stored in model's frame\n     * property and model's atoms are set to the 0th frame\n     *\n     * @param {string} data - Input data\n     * @param {string} format - Input format (see {@link FileFormats})\n     * @return {GLModel}\n     *\n     * @example\n            $3Dmol.get('../test_structs/multiple2.xyz', function(data){\n              viewer.addModelsAsFrames(data, \"xyz\");\n              viewer.animate({loop: \"forward\",reps: 1});\n              viewer.setStyle({stick:{colorscheme:'magentaCarbon'}});\n              viewer.zoomTo();\n              viewer.render();\n          });\n     */\n    addModelsAsFrames(data, format, options) {\n        options = this.getModelOpt(options);\n        options.multimodel = true;\n        options.frames = true;\n        var m = new _GLModel__WEBPACK_IMPORTED_MODULE_5__.GLModel(this.models.length, options);\n        m.addMolData(data, format, options);\n        this.models.push(m);\n        return m;\n    }\n    ;\n    /**\n     * Create and add model to viewer. Given multimodel file and its format,\n     * all atoms are added to one model\n     *\n     * @param {string} data - Input data\n     * @param {string} format - Input format (see {@link FileFormats})\n     * @return {GLModel}\n     @example\n\n\n          $3Dmol.get('../test_structs/multiple.sdf', function(data){\n              viewer.addAsOneMolecule(data, \"sdf\");\n              viewer.zoomTo();\n              viewer.render();\n          });\n     */\n    addAsOneMolecule(data, format, options) {\n        options = this.getModelOpt(options);\n        options.multimodel = true;\n        options.onemol = true;\n        var m = new _GLModel__WEBPACK_IMPORTED_MODULE_5__.GLModel(this.models.length, options);\n        m.addMolData(data, format, options);\n        this.models.push(m);\n        return m;\n    }\n    ;\n    /**\n     * Delete specified model from viewer\n     *\n     * @param {GLModel|number} model\n     */\n    removeModel(model) {\n        model = this.getModel(model);\n        if (!model)\n            return;\n        model.removegl(this.modelGroup);\n        delete this.models[model.getID()];\n        // clear off back of model array\n        while (this.models.length > 0\n            && typeof (this.models[this.models.length - 1]) === \"undefined\")\n            this.models.pop();\n        return this;\n    }\n    ;\n    /**\n     * Delete all existing models\n     */\n    removeAllModels() {\n        for (var i = 0; i < this.models.length; i++) {\n            var model = this.models[i];\n            if (model)\n                model.removegl(this.modelGroup);\n        }\n        this.models.splice(0, this.models.length); //don't simply overwrite array in case linked\n        return this;\n    }\n    ;\n    /**\n     * Export one or all of the loaded models into ChemDoodle compatible JSON.\n     * @param {boolean} includeStyles - Whether or not to include style information.\n     * @param {number} modelID - Optional parameter for which model to export. If left out, export all of them.\n     * @return {string}\n     */\n    exportJSON(includeStyles, modelID) {\n        var object = {};\n        if (modelID === undefined) {\n            object.m = this.models.map(function (model) {\n                return model.toCDObject(includeStyles);\n            });\n        }\n        else {\n            object.m = [this.models[modelID].toCDObject()];\n        }\n        return JSON.stringify(object);\n    }\n    ;\n    /** return a VRML string representation of the scene.  Include VRML header information\n     * @return VRML\n     */\n    exportVRML() {\n        var savedmodelGroup = this.modelGroup;\n        this.applyToModels(\"removegl\", this.modelGroup); //cleanup\n        this.modelGroup = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n        //rendering with plain mesh\n        this.render(null, { supportsImposters: false, supportsAIA: false, regen: true });\n        var ret = '#VRML V2.0 utf8\\n' + this.modelGroup.vrml() + '\\n';\n        this.applyToModels(\"removegl\", this.modelGroup); //cleanup\n        this.modelGroup = savedmodelGroup;\n        return ret;\n    }\n    ;\n    /**\n     * Create a new model from atoms specified by sel.\n     * If extract, removes selected atoms from existing models\n     *\n     * @param {AtomSelectionSpec} sel - Atom selection specification\n     * @param {boolean=} extract - If true, remove selected atoms from existing models\n     * @return {GLModel}\n     */\n    createModelFrom(sel, extract = false) {\n        var m = new _GLModel__WEBPACK_IMPORTED_MODULE_5__.GLModel(this.models.length, this.defaultcolors);\n        for (var i = 0; i < this.models.length; i++) {\n            if (this.models[i]) {\n                var atoms = this.models[i].selectedAtoms(sel);\n                m.addAtoms(atoms);\n                if (extract)\n                    this.models[i].removeAtoms(atoms);\n            }\n        }\n        this.models.push(m);\n        return m;\n    }\n    ;\n    applyToModels(func, sel, value1, value2, value3, value4, value5) {\n        //apply func to all models that are selected by sel with value1 and 2\n        //sel might not be a selection, in which case getModelList returns everything\n        var ms = this.getModelList(sel);\n        for (var i = 0; i < ms.length; i++) {\n            ms[i][func](sel, value1, value2, value3, value4, value5);\n        }\n    }\n    setStyle(sel, style) {\n        if (typeof (style) === 'undefined') {\n            //if a single argument is provided, assume it is a style and select all\n            style = sel;\n            sel = {};\n        }\n        this.applyToModels(\"setStyle\", sel, style, false);\n        return this;\n    }\n    ;\n    addStyle(sel, style) {\n        if (typeof (style) === 'undefined') {\n            //if a single argument is provided, assume it is a style and select all\n            style = sel;\n            sel = {};\n        }\n        this.applyToModels(\"setStyle\", sel, style, true);\n        return this;\n    }\n    ;\n    /**\n     * Set click-handling properties to all selected atoms. *Important*: render must be called for this to take effect.\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to\n     * @param {boolean} clickable - whether click-handling is enabled for the selection\n     * @param {function} callback - function called when an atom in the selection is clicked. The function is passed\n     * the selected (foremost) object, the viewer, the triggering event, the associated container, and a list\n     * of all intersecting objects with their distances from the viewer.\n     *\n     * @example\n        $3Dmol.download(\"cid:307900\",viewer,{},function(){\n\n               viewer.setStyle({},{sphere:{}});\n               viewer.setClickable({},true,function(atom,viewer,event,container) {\n                   viewer.addLabel(atom.resn+\":\"+atom.atom,{position: atom, backgroundColor: 'darkgreen', backgroundOpacity: 0.8});\n               });\n               viewer.render();\n    });\n     */\n    setClickable(sel, clickable, callback) {\n        this.applyToModels(\"setClickable\", sel, clickable, callback);\n        return this;\n    }\n    ;\n    /** Set hoverable and callback of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to\n     * @param {boolean} hoverable - whether hover-handling is enabled for the selection\n     * @param {function} hover_callback - function called when an atom in the selection is hovered over.  The function has the same signature as a click handler.\n     * @param {function} unhover_callback - function called when the mouse moves out of the hover area\n    @example\n    $3Dmol.download(\"pdb:1ubq\",viewer,{},function(){\n\n           viewer.setHoverable({},true,function(atom,viewer,event,container) {\n               if(!atom.label) {\n                atom.label = viewer.addLabel(atom.resn+\":\"+atom.atom,{position: atom, backgroundColor: 'mintcream', fontColor:'black'});\n               }\n           },\n           function(atom) {\n               if(atom.label) {\n                viewer.removeLabel(atom.label);\n                delete atom.label;\n               }\n            }\n           );\n           viewer.setStyle({},{stick:{}});\n           viewer.render();\n    });\n\n     */\n    setHoverable(sel, hoverable, hover_callback, unhover_callback) {\n        this.applyToModels(\"setHoverable\", sel, hoverable, hover_callback, unhover_callback);\n        return this;\n    }\n    ;\n    /** enable context menu and callback of selected atoms\n     *\n     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to\n     * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection\n\n     */\n    enableContextMenu(sel, contextMenuEnabled) {\n        this.applyToModels(\"enableContextMenu\", sel, contextMenuEnabled);\n        return this;\n    }\n    ;\n    /**\n     * If  atoms have dx, dy, dz properties (in some xyz files), vibrate populates each model's frame property based on parameters.\n     * Models can then be animated\n     *\n     * @param {number} numFrames - number of frames to be created, default to 10\n     * @param {number} amplitude - amplitude of distortion, default to 1 (full)\n     * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames\n     * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.\n     */\n    vibrate(numFrames, amplitude, bothways, arrowSpec) {\n        this.applyToModels(\"vibrate\", numFrames, amplitude, bothways, this, arrowSpec);\n        return this;\n    }\n    ;\n    /**\n     * @param {AtomSelectionSpec} sel\n     * @param {string} prop\n     * @param {Gradient|string} scheme\n     * @param {object} range\n     */\n    setColorByProperty(sel, prop, scheme, range) {\n        this.applyToModels(\"setColorByProperty\", sel, prop, scheme, range);\n        return this;\n    }\n    ;\n    /**\n     * @param {AtomSelectionSpec} sel\n     * @param {object} colors\n     */\n    setColorByElement(sel, colors) {\n        this.applyToModels(\"setColorByElement\", sel, colors);\n        return this;\n    }\n    ;\n    /**\n     *\n     * @param {AtomSpec[]} atomlist\n     * @param {Array}\n     *            extent\n     * @return {Array}\n     */\n    static getAtomsWithin(atomlist, extent) {\n        var ret = [];\n        for (let i = 0; i < atomlist.length; i++) {\n            var atom = atomlist[i];\n            if (typeof (atom) == \"undefined\")\n                continue;\n            if (atom.x < extent[0][0] || atom.x > extent[1][0])\n                continue;\n            if (atom.y < extent[0][1] || atom.y > extent[1][1])\n                continue;\n            if (atom.z < extent[0][2] || atom.z > extent[1][2])\n                continue;\n            ret.push(atom);\n        }\n        return ret;\n    }\n    ;\n    // return volume of extent\n    static volume(extent) {\n        var w = extent[1][0] - extent[0][0];\n        var h = extent[1][1] - extent[0][1];\n        var d = extent[1][2] - extent[0][2];\n        return w * h * d;\n    }\n    ; // volume\n    /*\n     * Break up bounding box/atoms into smaller pieces so we can parallelize\n     * with webworkers and also limit the size of the working memory Returns\n     * a list of bounding boxes with the corresponding atoms. These extents\n     * are expanded by 4 angstroms on each side.\n     */\n    /**\n     *\n     * @param {Array}\n     *            extent\n     * @param {AtomSpec[]} atomlist\n     * @param {AtomSpec[]} atomstoshow\n     * @return {Array}\n     */\n    carveUpExtent(extent, atomlist, atomstoshow) {\n        let ret = [];\n        let index2atomlist = {}; //map from atom.index to position in atomlist\n        for (let i = 0, n = atomlist.length; i < n; i++) {\n            index2atomlist[atomlist[i].index] = i;\n        }\n        let atomsToListIndex = function (atoms) {\n            //return a list of indices into atomlist\n            let ret = [];\n            for (let i = 0, n = atoms.length; i < n; i++) {\n                if (atoms[i].index in index2atomlist)\n                    ret.push(index2atomlist[atoms[i].index]);\n            }\n            return ret;\n        };\n        let copyExtent = function (extent) {\n            // copy just the dimensions\n            let ret = [];\n            ret[0] = [extent[0][0], extent[0][1], extent[0][2]];\n            ret[1] = [extent[1][0], extent[1][1], extent[1][2]];\n            return ret;\n        }; // copyExtent\n        let splitExtentR = function (extent) {\n            // recursively split until volume is below maxVol\n            if (GLViewer.volume(extent) < GLViewer.maxVolume) {\n                return [extent];\n            }\n            else {\n                // find longest edge\n                var w = extent[1][0] - extent[0][0];\n                var h = extent[1][1] - extent[0][1];\n                var d = extent[1][2] - extent[0][2];\n                var index;\n                if (w > h && w > d) {\n                    index = 0;\n                }\n                else if (h > w && h > d) {\n                    index = 1;\n                }\n                else {\n                    index = 2;\n                }\n                // create two halves, splitting at index\n                var a = copyExtent(extent);\n                var b = copyExtent(extent);\n                var mid = (extent[1][index] - extent[0][index]) / 2\n                    + extent[0][index];\n                a[1][index] = mid;\n                b[0][index] = mid;\n                var alist = splitExtentR(a);\n                var blist = splitExtentR(b);\n                return alist.concat(blist);\n            }\n        }; // splitExtentR\n        // divide up extent\n        let splits = splitExtentR(extent);\n        // now compute atoms within expanded (this could be more efficient)\n        let off = 6; // enough for water and 2*r, also depends on scale\n        // factor\n        for (let i = 0, n = splits.length; i < n; i++) {\n            let e = copyExtent(splits[i]);\n            e[0][0] -= off;\n            e[0][1] -= off;\n            e[0][2] -= off;\n            e[1][0] += off;\n            e[1][1] += off;\n            e[1][2] += off;\n            let atoms = GLViewer.getAtomsWithin(atomlist, e);\n            let toshow = GLViewer.getAtomsWithin(atomstoshow, splits[i]);\n            // ultimately, divide up by atom for best meshing\n            ret.push({\n                extent: splits[i],\n                atoms: atomsToListIndex(atoms),\n                toshow: atomsToListIndex(toshow)\n            });\n        }\n        return ret;\n    }\n    ;\n    // create a mesh defined from the passed vertices and faces and material\n    // Just create a single geometry chunk - broken up whether sync or not\n    /**\n     *\n     * @param {AtomSpec[]} atoms\n     * @param {{vertices:number,faces:number}}\n     *            VandF\n     * @param {MeshLambertMaterial}\n     *            mat\n     * @return {Mesh}\n     */\n    static generateSurfaceMesh(atoms, VandF, mat) {\n        var geo = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true);\n        // Only one group per call to generate surface mesh (addSurface\n        // should split up mesh render)\n        var geoGroup = geo.updateGeoGroup(0);\n        // set colors for vertices\n        var colors = [];\n        for (let i = 0, il = atoms.length; i < il; i++) {\n            var atom = atoms[i];\n            if (atom) {\n                if (typeof (atom.surfaceColor) != \"undefined\") {\n                    colors[i] = atom.surfaceColor;\n                }\n                else if (atom.color) // map from atom\n                    colors[i] = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(atom.color);\n            }\n        }\n        var vertexArray = geoGroup.vertexArray;\n        // reconstruct vertices and faces\n        var v = VandF.vertices;\n        for (let i = 0, il = v.length; i < il; i++) {\n            let offset = geoGroup.vertices * 3;\n            vertexArray[offset] = v[i].x;\n            vertexArray[offset + 1] = v[i].y;\n            vertexArray[offset + 2] = v[i].z;\n            geoGroup.vertices++;\n        }\n        //set colorArray of there are per-atom colors\n        var colorArray = geoGroup.colorArray;\n        if (mat.voldata && mat.volscheme) {\n            //convert volumetric data into colors\n            var scheme = mat.volscheme;\n            var voldata = mat.voldata;\n            var range = scheme.range() || [-1, 1];\n            for (let i = 0, il = v.length; i < il; i++) {\n                let val = voldata.getVal(v[i].x, v[i].y, v[i].z);\n                let col = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(scheme.valueToHex(val, range));\n                let offset = i * 3;\n                colorArray[offset] = col.r;\n                colorArray[offset + 1] = col.g;\n                colorArray[offset + 2] = col.b;\n            }\n        }\n        else if (colors.length > 0) { //have atom colors\n            for (let i = 0, il = v.length; i < il; i++) {\n                let A = v[i].atomid;\n                let offsetA = i * 3;\n                colorArray[offsetA] = colors[A].r;\n                colorArray[offsetA + 1] = colors[A].g;\n                colorArray[offsetA + 2] = colors[A].b;\n            }\n        }\n        var faces = VandF.faces;\n        geoGroup.faceidx = faces.length; // *3;\n        geo.initTypedArrays();\n        var verts = geoGroup.vertexArray;\n        var normalArray = geoGroup.normalArray;\n        var vA, vB, vC, norm;\n        // Setup colors, faces, and normals\n        for (let i = 0, il = faces.length; i < il; i += 3) {\n            // var a = faces[i].a, b = faces[i].b, c = faces[i].c;\n            var a = faces[i], b = faces[i + 1], c = faces[i + 2];\n            var offsetA = a * 3, offsetB = b * 3, offsetC = c * 3;\n            // setup Normals\n            // todo - calculate normals in parallel code\n            vA = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(verts[offsetA], verts[offsetA + 1], verts[offsetA + 2]);\n            vB = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(verts[offsetB], verts[offsetB + 1], verts[offsetB + 2]);\n            vC = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(verts[offsetC], verts[offsetC + 1], verts[offsetC + 2]);\n            vC.subVectors(vC, vB);\n            vA.subVectors(vA, vB);\n            vC.cross(vA);\n            // face normal\n            norm = vC;\n            norm.normalize();\n            normalArray[offsetA] += norm.x;\n            normalArray[offsetB] += norm.x;\n            normalArray[offsetC] += norm.x;\n            normalArray[offsetA + 1] += norm.y;\n            normalArray[offsetB + 1] += norm.y;\n            normalArray[offsetC + 1] += norm.y;\n            normalArray[offsetA + 2] += norm.z;\n            normalArray[offsetB + 2] += norm.z;\n            normalArray[offsetC + 2] += norm.z;\n        }\n        geoGroup.faceArray = new Uint16Array(faces);\n        var mesh = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Mesh(geo, mat);\n        return mesh;\n    }\n    ;\n    // do same thing as worker in main thread\n    /**\n     *\n     * @param {SurfaceType}\n     *            type\n     * @param {Array}\n     *            expandedExtent\n     * @param {AtomSpec[]}\n     *            extendedAtoms\n     * @param {AtomSpec[]}\n     *            atomsToShow\n     * @param {AtomSpec[]} atoms\n     * @param {number}\n     *            vol\n     * @return {Object}\n     */\n    static generateMeshSyncHelper(type, expandedExtent, extendedAtoms, atomsToShow, atoms, vol) {\n        //            var time = new Date();\n        var ps = new _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.ProteinSurface();\n        ps.initparm(expandedExtent, (type === 1) ? false : true, vol);\n        //            var time2 = new Date();\n        //console.log(\"initialize \" + (time2 - time) + \"ms\");\n        ps.fillvoxels(atoms, extendedAtoms);\n        //            var time3 = new Date();\n        //console.log(\"fillvoxels \" + (time3 - time2) + \"  \" + (time3 - time) + \"ms\");\n        ps.buildboundary();\n        if (type == _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.SurfaceType.SES || type == _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.SurfaceType.MS) {\n            ps.fastdistancemap();\n            ps.boundingatom(false);\n            ps.fillvoxelswaals(atoms, extendedAtoms);\n        }\n        //            var time4 = new Date();\n        //console.log(\"buildboundaryetc \" + (time4 - time3) + \"  \" + (time4 - time) + \"ms\");\n        ps.marchingcube(type);\n        //            var time5 = new Date();\n        //console.log(\"marching cube \" + (time5 - time4) + \"  \"+ (time5 - time) + \"ms\");\n        return ps.getFacesAndVertices(atomsToShow);\n    }\n    ;\n    /*\n     *\n     * @param {SurfaceStyleSpec}\n     *            style\n     * @return {MeshLambertMaterial}\n     */\n    static getMatWithStyle(style) {\n        let mat = null;\n        if (style.onesided) {\n            mat = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial();\n        }\n        else {\n            mat = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.MeshDoubleLambertMaterial();\n        }\n        mat.vertexColors = _WebGL__WEBPACK_IMPORTED_MODULE_0__.Coloring.VertexColors;\n        for (var prop in style) {\n            if (prop === \"color\" || prop === \"map\") {\n                // ignore\n            }\n            else if (style.hasOwnProperty(prop))\n                mat[prop] = style[prop];\n        }\n        if (style.opacity !== undefined) {\n            if (style.opacity === 1)\n                mat.transparent = false;\n            else\n                mat.transparent = true;\n        }\n        return mat;\n    }\n    /**\n     * Adds an explicit mesh as a surface object.\n     * @param {Mesh}\n     *            mesh\n     * @param {Object}\n     *            style\n     * @returns {number} surfid\n     */\n    addMesh(mesh) {\n        var surfobj = {\n            geo: mesh.geometry,\n            mat: mesh.material,\n            done: true,\n            finished: false //the rendered finishes surfaces when they are done\n        };\n        var surfid = this.nextSurfID();\n        this.surfaces[surfid] = surfobj;\n        return surfid;\n    }\n    ;\n    //return a shallow copy of list l, e.g., for atoms so we can\n    //ignore superficial changes (ie surfacecolor, position) that happen\n    //while we're surface building\n    static shallowCopy(l) {\n        var ret = [];\n        let length = l.length;\n        for (let i = 0; i < length; i++) {\n            ret[i] = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.extend)({}, l[i]);\n        }\n        return ret;\n    }\n    ;\n    /**\n     * Add surface representation to atoms\n     * @param {SurfaceType|string} type - Surface type (VDW, MS, SAS, or SES)\n     * @param {SurfaceStyleSpec} style - optional style specification for surface material (e.g. for different coloring scheme, etc)\n     * @param {AtomSelectionSpec} atomsel - Show surface for atoms in this selection\n     * @param {AtomSelectionSpec} allsel - Use atoms in this selection to calculate surface; may be larger group than 'atomsel'\n     * @param {AtomSelectionSpec} focus - Optionally begin rendering surface specified atoms\n     * @param {function} surfacecallback - function to be called after setting the surface\n     * @return {Promise} promise - Returns a promise that ultimately resovles to the surfid.  Returns surfid immediately if surfacecallback is specified.  Returned promise has a [surfid, GLViewer, style, atomsel, allsel, focus] fields for immediate access.\n     */\n    addSurface(stype, style = {}, atomsel = {}, allsel, focus, surfacecallback) {\n        // type 1: VDW 3: SAS 4: MS 2: SES\n        // if sync is true, does all work in main thread, otherwise uses\n        // workers\n        // with workers, must ensure group is the actual modelgroup since\n        // surface\n        // will get added asynchronously\n        // all atoms in atomlist are used to compute surfaces, but only the\n        // surfaces\n        // of atomsToShow are displayed (e.g., for showing cavities)\n        // if focusSele is specified, will start rending surface around the\n        //surfacecallback gets called when done\n        let surfid = this.nextSurfID();\n        let mat = null;\n        let self = this;\n        let type = _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.SurfaceType.VDW;\n        if (typeof stype == \"string\") {\n            if (GLViewer.surfaceTypeMap[stype.toUpperCase()] !== undefined)\n                type = GLViewer.surfaceTypeMap[stype];\n            else {\n                console.log(\"Surface type : \" + stype + \" is not recognized\");\n            }\n        }\n        else if (typeof stype == \"number\") {\n            type = stype;\n        }\n        // atoms specified by this selection\n        var atomlist = null, focusSele = null;\n        //TODO: currently generating a shallow copy to avoid problems when atoms are chagned\n        //during surface generation - come up with a better solution\n        var atomsToShow = GLViewer.shallowCopy(this.getAtomsFromSel(atomsel));\n        if (!allsel) {\n            atomlist = atomsToShow;\n        }\n        else {\n            atomlist = GLViewer.shallowCopy(this.getAtomsFromSel(allsel));\n        }\n        (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.adjustVolumeStyle)(style);\n        var symmetries = false;\n        var n;\n        for (n = 0; n < this.models.length; n++) {\n            if (this.models[n]) {\n                var symMatrices = this.models[n].getSymmetries();\n                if (symMatrices.length > 1 || (symMatrices.length == 1 && !(symMatrices[0].isIdentity()))) {\n                    symmetries = true;\n                    break;\n                }\n            }\n        }\n        var addSurfaceHelper = function addSurfaceHelper(surfobj, atomlist, atomsToShow) {\n            //function returns promise with surfid resolved\n            if (!focus) {\n                focusSele = atomsToShow;\n            }\n            else {\n                focusSele = GLViewer.shallowCopy(self.getAtomsFromSel(focus));\n            }\n            var atom;\n            //                var time = new Date();\n            var extent = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(atomsToShow, true);\n            if (style.map && style.map.prop) {\n                // map color space using already set atom properties\n                var prop = style.map.prop;\n                let scheme = (0,_Gradient__WEBPACK_IMPORTED_MODULE_4__.getGradient)(style.map.scheme || style.map.gradient || new _Gradient__WEBPACK_IMPORTED_MODULE_4__.Gradient.RWB());\n                let range = scheme.range();\n                if (!range) {\n                    range = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getPropertyRange)(atomsToShow, prop);\n                }\n                style.colorscheme = { prop: prop, gradient: scheme };\n            }\n            //cache surface color on each atom\n            for (let i = 0, il = atomlist.length; i < il; i++) {\n                atom = atomlist[i];\n                atom.surfaceColor = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getColorFromStyle)(atom, style);\n            }\n            var totalVol = GLViewer.volume(extent); // used to scale resolution\n            var extents = self.carveUpExtent(extent, atomlist, atomsToShow);\n            if (focusSele && focusSele.length && focusSele.length > 0) {\n                var seleExtent = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getExtent)(focusSele, true);\n                // sort by how close to center of seleExtent\n                var sortFunc = function (a, b) {\n                    var distSq = function (ex, sele) {\n                        // distance from e (which has no center of mass) and\n                        // sele which does\n                        var e = ex.extent;\n                        var x = e[1][0] - e[0][0];\n                        var y = e[1][1] - e[0][1];\n                        var z = e[1][2] - e[0][2];\n                        var dx = (x - sele[2][0]);\n                        dx *= dx;\n                        var dy = (y - sele[2][1]);\n                        dy *= dy;\n                        var dz = (z - sele[2][2]);\n                        dz *= dz;\n                        return dx + dy + dz;\n                    };\n                    var d1 = distSq(a, seleExtent);\n                    var d2 = distSq(b, seleExtent);\n                    return d1 - d2;\n                };\n                extents.sort(sortFunc);\n            }\n            var reducedAtoms = [];\n            // to reduce amount data transfered, just pass x,y,z,serial and elem\n            for (let i = 0, il = atomlist.length; i < il; i++) {\n                atom = atomlist[i];\n                reducedAtoms[i] = {\n                    x: atom.x,\n                    y: atom.y,\n                    z: atom.z,\n                    serial: i,\n                    elem: atom.elem\n                };\n            }\n            var sync = !!(_ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.syncSurface);\n            if (sync) { // don't use worker, still break up for memory purposes\n                // to keep the browser from locking up, call through setTimeout\n                var callSyncHelper = function callSyncHelper(i) {\n                    return new Promise(function (resolve) {\n                        var VandF = GLViewer.generateMeshSyncHelper(type, extents[i].extent, extents[i].atoms, extents[i].toshow, reducedAtoms, totalVol);\n                        //complicated surfaces sometimes have > 2^16 vertices\n                        var VandFs = (0,_GLShape__WEBPACK_IMPORTED_MODULE_7__.splitMesh)({ vertexArr: VandF.vertices, faceArr: VandF.faces });\n                        for (var vi = 0, vl = VandFs.length; vi < vl; vi++) {\n                            VandF = {\n                                vertices: VandFs[vi].vertexArr,\n                                faces: VandFs[vi].faceArr\n                            };\n                            var mesh = GLViewer.generateSurfaceMesh(atomlist, VandF, mat);\n                            (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.mergeGeos)(surfobj.geo, mesh);\n                        }\n                        self.render();\n                        resolve();\n                    });\n                };\n                var promises = [];\n                for (let i = 0; i < extents.length; i++) {\n                    promises.push(callSyncHelper(i));\n                }\n                return Promise.all(promises)\n                    .then(function () {\n                    surfobj.done = true;\n                    return Promise.resolve(surfid);\n                });\n                // TODO: Asynchronously generate geometryGroups (not separate\n                // meshes) and merge them into a single geometry\n            }\n            else { // use worker\n                var workers = [];\n                if (type < 0)\n                    type = 0; // negative reserved for atom data\n                for (let i = 0, il = GLViewer.numWorkers; i < il; i++) {\n                    var w = new Worker($3Dmol.SurfaceWorker);\n                    workers.push(w);\n                    w.postMessage({\n                        'type': -1,\n                        'atoms': reducedAtoms,\n                        'volume': totalVol\n                    });\n                }\n                return new Promise(function (resolve, reject) {\n                    var cnt = 0;\n                    var releaseMemory = function () {\n                        if (!workers || !workers.length)\n                            return;\n                        workers.forEach(function (worker) {\n                            if (worker && worker.terminate) {\n                                worker.terminate();\n                            }\n                        });\n                    };\n                    var rfunction = function (event) {\n                        var VandFs = (0,_GLShape__WEBPACK_IMPORTED_MODULE_7__.splitMesh)({\n                            vertexArr: event.data.vertices,\n                            faceArr: event.data.faces\n                        });\n                        for (var i = 0, vl = VandFs.length; i < vl; i++) {\n                            var VandF = {\n                                vertices: VandFs[i].vertexArr,\n                                faces: VandFs[i].faceArr\n                            };\n                            var mesh = GLViewer.generateSurfaceMesh(atomlist, VandF, mat);\n                            (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.mergeGeos)(surfobj.geo, mesh);\n                        }\n                        self.render();\n                        //    console.log(\"async mesh generation \" + (+new Date() - time) + \"ms\");\n                        cnt++;\n                        if (cnt == extents.length) {\n                            surfobj.done = true;\n                            releaseMemory();\n                            resolve(surfid); //caller of helper will resolve callback if present\n                        }\n                    };\n                    var efunction = function (event) {\n                        releaseMemory();\n                        console.log(event.message + \" (\" + event.filename + \":\" + event.lineno + \")\");\n                        reject(event);\n                    };\n                    for (let i = 0; i < extents.length; i++) {\n                        var worker = workers[i % workers.length];\n                        worker.onmessage = rfunction;\n                        worker.onerror = efunction;\n                        worker.postMessage({\n                            'type': type,\n                            'expandedExtent': extents[i].extent,\n                            'extendedAtoms': extents[i].atoms,\n                            'atomsToShow': extents[i].toshow\n                        });\n                    }\n                });\n            }\n        };\n        style = style || {};\n        mat = GLViewer.getMatWithStyle(style);\n        var surfobj = [];\n        //save configuration of surface\n        surfobj.style = style;\n        surfobj.atomsel = atomsel;\n        surfobj.allsel = allsel;\n        surfobj.focus = focus;\n        var promise = null;\n        if (symmetries) { //do preprocessing\n            var modelsAtomList = {};\n            var modelsAtomsToShow = {};\n            for (n = 0; n < this.models.length; n++) {\n                modelsAtomList[n] = [];\n                modelsAtomsToShow[n] = [];\n            }\n            for (n = 0; n < atomlist.length; n++) {\n                modelsAtomList[atomlist[n].model].push(atomlist[n]);\n            }\n            for (n = 0; n < atomsToShow.length; n++) {\n                modelsAtomsToShow[atomsToShow[n].model].push(atomsToShow[n]);\n            }\n            var promises = [];\n            for (n = 0; n < this.models.length; n++) {\n                if (modelsAtomsToShow[n].length > 0) {\n                    surfobj.push({\n                        geo: new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true),\n                        mat: mat,\n                        done: false,\n                        finished: false,\n                        symmetries: this.models[n].getSymmetries()\n                        // also webgl initialized\n                    });\n                    promises.push(addSurfaceHelper(surfobj[surfobj.length - 1], modelsAtomList[n], modelsAtomsToShow[n]));\n                }\n            }\n            promise = Promise.all(promises);\n        }\n        else {\n            surfobj.push({\n                geo: new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Geometry(true),\n                mat: mat,\n                done: false,\n                finished: false,\n                symmetries: [new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4()]\n            });\n            promise = addSurfaceHelper(surfobj[surfobj.length - 1], atomlist, atomsToShow);\n        }\n        this.surfaces[surfid] = surfobj;\n        promise.surfid = surfid;\n        if (surfacecallback && typeof (surfacecallback) == \"function\") {\n            promise.then(function (surfid) {\n                surfacecallback(surfid);\n            });\n            return surfid;\n        }\n        else {\n            return promise;\n        }\n    }\n    ;\n    /**\n     * Set the surface material to something else, must render change\n     * @param {number} surf - Surface ID to apply changes to\n     * @param {SurfaceStyleSpec} style - new material style specification\n     @example\n     $3Dmol.get(\"data/9002806.cif\",function(data){\n        viewer.addModel(data);\n        viewer.setStyle({stick:{}});\n        let surf = viewer.addSurface(\"SAS\");\n        surf.then(function() {\n            viewer.setSurfaceMaterialStyle(surf.surfid, {color:'blue',opacity:0.5});\n            viewer.render();\n            });\n       });\n     */\n    setSurfaceMaterialStyle(surf, style) {\n        (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.adjustVolumeStyle)(style);\n        if (this.surfaces[surf]) {\n            var surfArr = this.surfaces[surf];\n            surfArr.style = style;\n            for (var i = 0; i < surfArr.length; i++) {\n                var mat = surfArr[i].mat = GLViewer.getMatWithStyle(style);\n                surfArr[i].mat.side = _WebGL__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n                if (style.color) {\n                    surfArr[i].mat.color = style.color;\n                    surfArr[i].geo.colorsNeedUpdate = true;\n                    const c = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(style.color);\n                    surfArr[i].geo.setColors(function () { return c; });\n                }\n                else if (mat.voldata && mat.volscheme) {\n                    //convert volumetric data into colors\n                    const scheme = mat.volscheme;\n                    const voldata = mat.voldata;\n                    const cc = _colors__WEBPACK_IMPORTED_MODULE_2__.CC;\n                    const range = scheme.range() || [-1, 1];\n                    surfArr[i].geo.setColors(function (x, y, z) {\n                        let val = voldata.getVal(x, y, z);\n                        let col = cc.color(scheme.valueToHex(val, range));\n                        return col;\n                    });\n                }\n                surfArr[i].finished = false; // trigger redraw\n            }\n        }\n        return this;\n    }\n    ;\n    /**\n     * Return surface object\n     * @param {number} surf - surface id\n     */\n    getSurface(surf) {\n        return this.surfaces[surf];\n    }\n    ;\n    /**\n     * Remove surface with given ID\n     * @param {number} surf - surface id\n     */\n    removeSurface(surf) {\n        var surfArr = this.surfaces[surf];\n        for (var i = 0; i < surfArr.length; i++) {\n            if (surfArr[i] && surfArr[i].lastGL) {\n                if (surfArr[i].geo !== undefined)\n                    surfArr[i].geo.dispose();\n                if (surfArr[i].mat !== undefined)\n                    surfArr[i].mat.dispose();\n                this.modelGroup.remove(surfArr[i].lastGL); // remove from scene\n            }\n        }\n        delete this.surfaces[surf];\n        this.show();\n        return this;\n    }\n    ;\n    /** Remove all surfaces.\n     **/\n    removeAllSurfaces() {\n        for (var n in this.surfaces) {\n            if (!this.surfaces.hasOwnProperty(n))\n                continue;\n            var surfArr = this.surfaces[n];\n            for (var i = 0; i < surfArr.length; i++) {\n                if (surfArr[i] && surfArr[i].lastGL) {\n                    if (surfArr[i].geo !== undefined)\n                        surfArr[i].geo.dispose();\n                    if (surfArr[i].mat !== undefined)\n                        surfArr[i].mat.dispose();\n                    this.modelGroup.remove(surfArr[i].lastGL); // remove from scene\n                }\n            }\n            delete this.surfaces[n];\n        }\n        this.show();\n        return this;\n    }\n    ;\n    /** return Jmol moveto command to position this scene */\n    jmolMoveTo() {\n        var pos = this.modelGroup.position;\n        // center on same position\n        var ret = \"center { \" + (-pos.x) + \" \" + (-pos.y) + \" \" + (-pos.z)\n            + \" }; \";\n        // apply rotation\n        var q = this.rotationGroup.quaternion;\n        ret += \"moveto .5 quaternion { \" + q.x + \" \" + q.y + \" \" + q.z\n            + \" \" + q.w + \" };\";\n        // zoom is tricky.. maybe i would be best to let callee zoom on\n        // selection?\n        // can either do a bunch of math, or maybe zoom to the center with a\n        // fixed\n        // but reasonable percentage\n        return ret;\n    }\n    ;\n    /** Clear scene of all objects\n     * */\n    clear() {\n        this.removeAllSurfaces();\n        this.removeAllModels();\n        this.removeAllLabels();\n        this.removeAllShapes();\n        this.show();\n        return this;\n    }\n    ;\n    // props is a list of objects that select certain atoms and enumerate\n    // properties for those atoms\n    /**\n     * Add specified properties to all atoms matching input argument\n     * @param {Object} props, either array of atom selectors with associated props, or function that takes atom and sets its properties\n     * @param {AtomSelectionSpec} sel  - subset of atoms to work on - model selection must be specified here\n         @example\n         $3Dmol.get('../test_structs/b.sdf', function(data){\n                  viewer.addModel(data,'sdf');\n                  let props = [];\n                  //make the atom index a property x\n                  for(let i = 0; i < 8; i++) {\n                    props.push({index:i,props:{'x':i}});\n                  }\n                  viewer.mapAtomProperties(props);\n                  viewer.setStyle({sphere:{colorscheme:{gradient:'roygb',prop:'x',min:0,max:8}}});\n                  viewer.zoomTo();\n                  viewer.render();\n                });\n     */\n    mapAtomProperties(props, sel) {\n        sel = sel || {};\n        var atoms = this.getAtomsFromSel(sel);\n        if (typeof (props) == \"function\") {\n            for (let a = 0, numa = atoms.length; a < numa; a++) {\n                let atom = atoms[a];\n                props(atom);\n            }\n        }\n        else {\n            for (let a = 0, numa = atoms.length; a < numa; a++) {\n                var atom = atoms[a];\n                for (let i = 0, n = props.length; i < n; i++) {\n                    let prop = props[i];\n                    if (prop.props) {\n                        for (var p in prop.props) {\n                            if (prop.props.hasOwnProperty(p)) {\n                                // check the atom\n                                if (this.atomIsSelected(atom, prop)) {\n                                    if (!atom.properties)\n                                        atom.properties = {};\n                                    atom.properties[p] = prop.props[p];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return this;\n    }\n    ;\n    /**\n     * Synchronize this view matrix of this viewer to the passed viewer.\n     * When the viewpoint of this viewer changes, the other viewer will\n     * be set to this viewer's view.\n     * @param {$3Dmol.GLViewer} otherview\n     */\n    linkViewer(otherviewer) {\n        this.linkedViewers.push(otherviewer);\n        return this;\n    }\n    ;\n    /**\n     * Return the z distance between the model and the camera\n     * @return {number} distance\n     */\n    getPerceivedDistance() {\n        return this.CAMERA_Z - this.rotationGroup.position.z;\n    }\n    ;\n    /**\n     * Set the distance between the model and the camera\n     * Essentially zooming. Useful while stereo rendering.\n     */\n    setPerceivedDistance(dist) {\n        this.rotationGroup.position.z = this.CAMERA_Z - dist;\n    }\n    ;\n    /**\n     * Used for setting an approx value of eyeSeparation. Created for calling by StereoViewer object\n     * @return {number} camera x position\n     */\n    setAutoEyeSeparation(isright, x) {\n        var dist = this.getPerceivedDistance();\n        if (!x)\n            x = 5.0;\n        if (isright || this.camera.position.x > 0) //setting a value of dist*tan(x)\n            this.camera.position.x = dist * Math.tan(Math.PI / 180.0 * x);\n        else\n            this.camera.position.x = -dist * Math.tan(Math.PI / 180.0 * x);\n        this.camera.lookAt(new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, this.rotationGroup.position.z));\n        return this.camera.position.x;\n    }\n    ;\n    /**\n     * Set the default cartoon quality for newly created models.  Default is 5.\n     * Current models are not affected.\n     * @number quality, higher results in higher resolution renders\n     */\n    setDefaultCartoonQuality(val) {\n        this.config.cartoonQuality = val;\n    }\n    ;\n}\n// private class variables\nGLViewer.numWorkers = 4; // number of threads for surface generation\nGLViewer.maxVolume = 64000; // how much to break up surface calculations\nGLViewer.surfaceTypeMap = {\n    \"VDW\": _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.SurfaceType.VDW,\n    \"MS\": _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.SurfaceType.MS,\n    \"SAS\": _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.SurfaceType.SAS,\n    \"SES\": _ProteinSurface4__WEBPACK_IMPORTED_MODULE_9__.SurfaceType.SES\n};\n/**\n * Create and initialize an appropriate viewer at supplied HTML element using specification in config\n * @param {Object | string} element - Either HTML element or string identifier\n * @param {ViewerSpec} [config] Viewer configuration\n * @return {GLViewer} GLViewer, null if unable to instantiate WebGL\n * @example\n   var viewer = $3Dmol.createViewer(\n     'gldiv', //id of div to create canvas in\n     {\n       defaultcolors: $3Dmol.elementColors.rasmol,\n       backgroundColor: 'black'\n     }\n   );\n *\n */\nfunction createViewer(element, config) {\n    element = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getElement)(element);\n    if (!element)\n        return;\n    config = config || {};\n    //try to create the  viewer\n    try {\n        var viewer = new GLViewer(element, config);\n        return viewer;\n    }\n    catch (e) {\n        throw \"error creating viewer: \" + e;\n    }\n}\n;\n/**\n * Create and initialize an appropriate a grid of viewers that share a WebGL canvas\n * @param {Object | string} element - Either HTML element or string identifier\n * @param {GridSpec} [config] - grid configuration\n * @param {ViewerGridSpec} [viewer_config] - Viewer specification to apply to all subviewers\n * @return [[GLViewer]] 2D array of GLViewers\n * @example\n   var viewers = $3Dmol.createViewerGrid(\n     'gldiv', //id of div to create canvas in\n     {\n       rows: 2,\n       cols: 2,\n       control_all: true  //mouse controls all viewers\n     },\n     { backgroundColor: 'lightgrey' }\n   );\n   $3Dmol.get('data/1jpy.cif', function(data) {\n     var viewer = viewers[0][0];\n     viewer.addModel(data,'cif');\n     viewer.setStyle({sphere:{}});\n     viewer.zoomTo();\n     viewer.render( );\n\n     viewer = viewers[0][1];\n     viewer.addModel(data,'cif');\n     viewer.setStyle({stick:{}});\n     viewer.zoomTo();\n     viewer.render( );\n\n     viewer = viewers[1][0];\n     viewer.addModel(data,'cif');\n     viewer.setStyle({cartoon:{color:'spectrum'}});\n     viewer.zoomTo();\n     viewer.render( );\n\n     viewer = viewers[1][1];\n     viewer.addModel(data,'cif');\n     viewer.setStyle({cartoon:{colorscheme:'chain'}});\n     viewer.zoomTo();\n     viewer.render();\n\n\n   });\n\n */\nfunction createViewerGrid(element, config = {}, viewer_config = {}) {\n    element = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getElement)(element);\n    if (!element)\n        return;\n    var viewers = [];\n    //create canvas\n    var canvas = document.createElement('canvas');\n    viewer_config.rows = config.rows;\n    viewer_config.cols = config.cols;\n    viewer_config.control_all = config.control_all != undefined ? config.control_all : false;\n    element.appendChild(canvas);\n    //try to create the  viewer\n    try {\n        for (var r = 0; r < config.rows; r++) {\n            var row = [];\n            for (var c = 0; c < config.cols; c++) {\n                viewer_config.row = r;\n                viewer_config.col = c;\n                viewer_config.canvas = canvas;\n                viewer_config.viewers = viewers;\n                viewer_config.control_all = config.control_all;\n                var viewer = createViewer(element, (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.extend)({}, viewer_config));\n                row.push(viewer);\n            }\n            viewers.unshift(row); //compensate for weird ordering in renderer\n        }\n    }\n    catch (e) {\n        throw \"error creating viewer grid: \" + e;\n    }\n    return viewers;\n}\n;\n/* StereoViewer for stereoscopic viewing\n* @param {Object | string} element - Either HTML element or string identifier\n*\n*/\nfunction createStereoViewer(element) {\n    var that = this;\n    element = (0,_utilities__WEBPACK_IMPORTED_MODULE_3__.getElement)(element);\n    if (!element)\n        return;\n    var viewers = createViewerGrid(element, { rows: 1, cols: 2, control_all: true });\n    this.glviewer1 = viewers[0][0];\n    this.glviewer2 = viewers[0][1];\n    this.glviewer1.setAutoEyeSeparation(false);\n    this.glviewer2.setAutoEyeSeparation(true);\n    this.glviewer1.linkViewer(this.glviewer2);\n    this.glviewer2.linkViewer(this.glviewer1);\n    var methods = Object.getOwnPropertyNames(this.glviewer1.__proto__) //get all methods of glviewer object\n        .filter(function (property) {\n        return typeof that.glviewer1[property] == 'function';\n    });\n    for (var i = 0; i < methods.length; i++) { //create methods of the same name\n        this[methods[i]] = (function (method) {\n            return function () {\n                var m1 = this.glviewer1[method].apply(this.glviewer1, arguments);\n                var m2 = this.glviewer2[method].apply(this.glviewer2, arguments);\n                return [m1, m2];\n            };\n        })(methods[i]);\n    }\n    //special cased methods\n    this.setCoordinates = function (models, data, format) {\n        for (var i = 0; i < models.length; i++) {\n            models[i].setCoordinates(data, format);\n        }\n    };\n    this.surfacesFinished = function () {\n        return this.glviewer1.surfacesFinished() && this.glviewer2.surfacesFinished();\n    };\n    this.isAnimated = function () {\n        return this.glviewer1.isAnimated() || this.glviewer2.isAnimated();\n    };\n    this.render = function (callback) {\n        this.glviewer1.render();\n        this.glviewer2.render();\n        if (callback) {\n            callback(this); //call only once\n        }\n    };\n    this.getCanvas = function () {\n        return this.glviewer1.getCanvas(); //same for both\n    };\n}\n;\n;\n;\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/GLViewer.ts?");

/***/ }),

/***/ "./src/Gradient.ts":
/*!*************************!*\
  !*** ./src/Gradient.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomLinear: () => (/* binding */ CustomLinear),\n/* harmony export */   Gradient: () => (/* binding */ Gradient),\n/* harmony export */   GradientType: () => (/* binding */ GradientType),\n/* harmony export */   ROYGB: () => (/* binding */ ROYGB),\n/* harmony export */   RWB: () => (/* binding */ RWB),\n/* harmony export */   Sinebow: () => (/* binding */ Sinebow),\n/* harmony export */   builtinGradients: () => (/* binding */ builtinGradients),\n/* harmony export */   getGradient: () => (/* binding */ getGradient),\n/* harmony export */   normalizeValue: () => (/* binding */ normalizeValue)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n\nclass GradientType {\n}\nfunction normalizeValue(lo, hi, val) {\n    if (hi >= lo) {\n        if (val < lo)\n            val = lo;\n        if (val > hi)\n            val = hi;\n        return { lo: lo, hi: hi, val: val };\n    }\n    else {\n        if (val > lo)\n            val = lo;\n        if (val < hi)\n            val = hi;\n        //flip the meaning of val, lo, hi\n        val = lo - val + hi;\n        return { lo: hi, hi: lo, val: val };\n    }\n}\n//return a Gradient object, even if what is specified is descriptive\nfunction getGradient(grad) {\n    if (grad instanceof GradientType) {\n        return grad;\n    }\n    else if (grad.gradient !== undefined && builtinGradients[grad.gradient]) {\n        let min = grad.min === undefined ? -1 : grad.min;\n        let max = grad.max === undefined ? 1 : grad.max;\n        if (grad.mid === undefined) {\n            if (grad.colors === undefined) {\n                return new builtinGradients[grad.gradient](min, max);\n            }\n            else {\n                return new builtinGradients[grad.gradient](min, max, grad.colors);\n            }\n        }\n        else {\n            return new builtinGradients[grad.gradient](min, max, grad.mid);\n        }\n    }\n    else if (typeof (grad.gradient) == \"string\" && grad.gradient.startsWith('linear_')) {\n        let colors = grad.gradient.split('_');\n        colors.shift();\n        let min = grad.min === undefined ? -1 : grad.min;\n        let max = grad.max === undefined ? 1 : grad.max;\n        return new CustomLinear(min, max, colors);\n    }\n    return grad;\n}\n/**\n * Color scheme red to white to blue, for charges\n * Reverse gradients are supported when min>max so that the colors are displayed in reverse order.\n * @subcategory Gradients\n */\nclass RWB extends GradientType {\n    constructor(min, max, mid) {\n        super();\n        this.gradient = \"RWB\";\n        this.mult = 1.0;\n        this.mid = mid;\n        this.min = min;\n        this.max = max;\n        if (typeof max == \"undefined\" && Array.isArray(min) && min.length >= 2) {\n            //we were passed a single range\n            this.max = min[1];\n            this.min = min[0];\n        }\n        else if (!!min && !!max && !Array.isArray(min)) {\n            this.min = min;\n            this.max = max;\n        }\n    }\n    //return range used for color mapping, null if none set\n    range() {\n        if (typeof this.min != \"undefined\" && typeof this.max != \"undefined\") {\n            return [this.min, this.max];\n        }\n        return null;\n    }\n    //map value to hex color, range is provided\n    valueToHex(val, range) {\n        var lo, hi;\n        val = this.mult * val; //reverse if necessary\n        if (range) {\n            lo = range[0];\n            hi = range[1];\n        }\n        else {\n            lo = this.min;\n            hi = this.max;\n        }\n        if (val === undefined)\n            return 0xffffff;\n        var norm = normalizeValue(lo, hi, val);\n        lo = norm.lo;\n        hi = norm.hi;\n        val = norm.val;\n        var middle = (hi + lo) / 2;\n        if (range && typeof range[2] != \"undefined\")\n            middle = range[2];\n        else if (typeof this.mid != \"undefined\")\n            middle = this.mid; //allow user to specify midpoint\n        else\n            middle = (lo + hi) / 2;\n        var scale, color;\n        //scale bottom from red to white\n        if (val < middle) {\n            scale = Math.floor(255 * Math.sqrt((val - lo) / (middle - lo)));\n            color = 0xff0000 + 0x100 * scale + scale;\n            return color;\n        }\n        else if (val > middle) {\n            //form white to blue\n            scale = Math.floor(255 * Math.sqrt(1 - (val - middle) / (hi - middle)));\n            color = 0x10000 * scale + 0x100 * scale + 0xff;\n            return color;\n        }\n        else {\n            //val == middle\n            return 0xffffff;\n        }\n    }\n}\n/**\n * rainbow gradient, but without purple to match jmol\n * Reverse gradients are supported when min>max so that the colors are displayed in reverse order.\n * @subcategory Gradients\n */\nclass ROYGB extends GradientType {\n    constructor(min, max) {\n        super();\n        this.gradient = \"ROYGB\";\n        this.mult = 1.0;\n        this.min = min;\n        this.max = max;\n        if (typeof max == \"undefined\" && Array.isArray(min) && min.length >= 2) {\n            //we were passed a single range\n            this.max = min[1];\n            this.min = min[0];\n        }\n        else if (!!min && !!max && !Array.isArray(min)) {\n            this.min = min;\n            this.max = max;\n        }\n    }\n    ;\n    //map value to hex color, range is provided\n    valueToHex(val, range) {\n        var lo, hi;\n        val = this.mult * val;\n        if (range) {\n            lo = range[0];\n            hi = range[1];\n        }\n        else {\n            lo = this.min;\n            hi = this.max;\n        }\n        if (typeof val == \"undefined\")\n            return 0xffffff;\n        var norm = normalizeValue(lo, hi, val);\n        lo = norm.lo;\n        hi = norm.hi;\n        val = norm.val;\n        var mid = (lo + hi) / 2;\n        var q1 = (lo + mid) / 2;\n        var q3 = (mid + hi) / 2;\n        var scale, color;\n        if (val < q1) {\n            //scale green up, red up, blue down\n            scale = Math.floor(255 * Math.sqrt((val - lo) / (q1 - lo)));\n            color = 0xff0000 + 0x100 * scale + 0;\n            return color;\n        }\n        else if (val < mid) {\n            //scale red down, green up, blue down\n            scale = Math.floor(255 * Math.sqrt(1 - (val - q1) / (mid - q1)));\n            color = 0x010000 * scale + 0xff00 + 0x0;\n            return color;\n        }\n        else if (val < q3) {\n            //scale blue up, red down, green up\n            scale = Math.floor(255 * Math.sqrt((val - mid) / (q3 - mid)));\n            color = 0x000000 + 0xff00 + 0x1 * scale;\n            return color;\n        }\n        else {\n            //scale green down, blue up, red down\n            scale = Math.floor(255 * Math.sqrt(1 - (val - q3) / (hi - q3)));\n            color = 0x000000 + 0x0100 * scale + 0xff;\n            return color;\n        }\n    }\n    ;\n    //return range used for color mapping, null if none set\n    range() {\n        if (typeof this.min != \"undefined\" && typeof this.max != \"undefined\") {\n            return [this.min, this.max];\n        }\n        return null;\n    }\n    ;\n}\n/**\n * rainbow gradient with constant saturation, all the way to purple!\n * Reverse gradients are supported when min>max so that the colors are displayed in reverse order.\n  * @subcategory Gradients\n *\n * @example $.get('data/1fas.pqr', function(data){\n      viewer.addModel(data, \"pqr\");\n      $.get(\"data/1fas.cube\",function(volumedata){\n          viewer.addSurface($3Dmol.SurfaceType.VDW, {\n              opacity:0.85,\n              voldata: new $3Dmol.VolumeData(volumedata, \"cube\"),\n              volscheme: new $3Dmol.Gradient.Sinebow(2,0,1)\n          },{});\n          \n      viewer.render();\n      });\n      viewer.zoomTo();\n  });\n */\nclass Sinebow extends GradientType {\n    constructor(min, max) {\n        super();\n        this.gradient = \"Sinebow\";\n        this.mult = 1.0;\n        this.min = min;\n        this.max = max;\n        if (typeof max == \"undefined\" && Array.isArray(min) && min.length >= 2) {\n            //we were passed a single range\n            this.max = min[1];\n            this.min = min[0];\n        }\n        if (max < min) {\n            //reverse the order\n            this.mult = -1.0;\n            this.min *= -1.0;\n            this.max *= -1.0;\n        }\n    }\n    ;\n    //map value to hex color, range is provided\n    valueToHex(val, range) {\n        var lo, hi;\n        val = this.mult * val;\n        if (range) {\n            lo = range[0];\n            hi = range[1];\n        }\n        else {\n            lo = this.min;\n            hi = this.max;\n        }\n        if (typeof val == \"undefined\")\n            return 0xffffff;\n        var norm = Gradient.normalizeValue(lo, hi, val);\n        lo = norm.lo;\n        hi = norm.hi;\n        val = norm.val;\n        var scale = (val - lo) / (hi - lo);\n        var h = (5 * scale) / 6.0 + 0.5;\n        var r = Math.sin(Math.PI * h);\n        r *= r * 255;\n        var g = Math.sin(Math.PI * (h + 1 / 3.0));\n        g *= g * 255;\n        var b = Math.sin(Math.PI * (h + 2 / 3.0));\n        b *= b * 255;\n        return (0x10000 * Math.floor(r) + 0x100 * Math.floor(b) + 0x1 * Math.floor(g));\n    }\n    ;\n    //return range used for color mapping, null if none set\n    range() {\n        if (typeof this.min != \"undefined\" && typeof this.max != \"undefined\") {\n            return [this.min, this.max];\n        }\n        return null;\n    }\n    ;\n}\n/**\n * Custom linear gradient using user supplied colors.\n * Reverse gradients are supported when min>max so that the colors are displayed in reverse order.\n * Midpoints are not supported - color map should be specified to get desired middle color.\n *\n * @param {number} min\n * @param {number} max\n * @param {Array} colors  Array of colors that will be linearly interpolated between from min to max values.\n * @subcategory Gradients\n *\n * @example\n       $3Dmol.get('../test_structs/af.pdb', function(data){\n              viewer.addModel(data);\n              viewer.setStyle({cartoon:{colorscheme:{prop: 'b', gradient:'linear', min: 70, max: 100, colors: [\"blue\",\"yellow\",\"green\"]}}});\n              viewer.zoomTo();\n              viewer.render();\n            });\n */\nclass CustomLinear extends GradientType {\n    constructor(min, max, colors) {\n        super();\n        this.gradient = \"linear\";\n        this.colors = new Array();\n        var carr;\n        if (Array.isArray(min) && min.length >= 2) {\n            //we were passed a single range\n            this.max = min[1];\n            this.min = min[0];\n            carr = max;\n        }\n        else {\n            this.min = min;\n            this.max = max;\n            carr = colors;\n        }\n        //convert colors\n        if (carr) {\n            for (let c of carr) {\n                this.colors.push(_colors__WEBPACK_IMPORTED_MODULE_0__.CC.color(c));\n            }\n        }\n        else {\n            this.colors.push(_colors__WEBPACK_IMPORTED_MODULE_0__.CC.color(0));\n        }\n    }\n    //return range used for color mapping, null if none set\n    range() {\n        if (typeof this.min != \"undefined\" && typeof this.max != \"undefined\") {\n            return [this.min, this.max];\n        }\n        return null;\n    }\n    //map value to hex color, range is provided\n    valueToHex(val, range) {\n        var lo, hi;\n        if (range) {\n            lo = range[0];\n            hi = range[1];\n        }\n        else {\n            lo = this.min;\n            hi = this.max;\n        }\n        if (val === undefined)\n            return 0xffffff;\n        var norm = normalizeValue(lo, hi, val);\n        lo = norm.lo;\n        hi = norm.hi;\n        val = norm.val;\n        let nsteps = this.colors.length;\n        let stepsize = (hi - lo) / nsteps;\n        let startpos = Math.min(Math.floor((val - lo) / stepsize), nsteps - 1);\n        let endpos = Math.min(startpos + 1, nsteps - 1);\n        let frac = (val - lo - (startpos * stepsize)) / stepsize;\n        let startcol = this.colors[startpos];\n        let endcol = this.colors[endpos];\n        let col = new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(startcol.r + frac * (endcol.r - startcol.r), startcol.g + frac * (endcol.g - startcol.g), startcol.b + frac * (endcol.b - startcol.b));\n        return col.getHex();\n    }\n}\n/**\n * built in gradient schemes\n * The user can pass these strings directly as the gradient\n * @prop rwb - red/white/blue, supports setting a mid point for white\n * @prop roygb - rainbow\n * @prop sinebow - rainbow with better saturation properties\n * @prop linear  - linearly maps between provided colors\n *\n  */\nconst builtinGradients = {\n    \"rwb\": RWB,\n    \"RWB\": RWB,\n    \"roygb\": ROYGB,\n    \"ROYGB\": ROYGB,\n    \"sinebow\": Sinebow,\n    \"linear\": CustomLinear\n};\nclass Gradient extends GradientType {\n    valueToHex(_value, _range) { return 0; }\n    range() { return null; }\n}\nGradient.RWB = RWB;\nGradient.ROYGB = ROYGB;\nGradient.Sinebow = Sinebow;\nGradient.CustomLinear = CustomLinear;\nGradient.builtinGradients = builtinGradients;\nGradient.normalizeValue = normalizeValue;\nGradient.getGradient = getGradient;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/Gradient.ts?");

/***/ }),

/***/ "./src/Label.ts":
/*!**********************!*\
  !*** ./src/Label.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Label: () => (/* binding */ Label),\n/* harmony export */   LabelCount: () => (/* binding */ LabelCount)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _Gradient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Gradient */ \"./src/Gradient.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n\n\n\n// Adapted from the text sprite example from http://stemkoski.github.io/Three.js/index.html\nlet LabelCount = 0;\n// Function for drawing rounded rectangles - for Label drawing\nfunction roundRect(ctx, x, y, w, h, r, drawBorder) {\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + w - r, y);\n    ctx.quadraticCurveTo(x + w, y, x + w, y + r);\n    ctx.lineTo(x + w, y + h - r);\n    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);\n    ctx.lineTo(x + r, y + h);\n    ctx.quadraticCurveTo(x, y + h, x, y + h - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    ctx.closePath();\n    ctx.fill();\n    if (drawBorder)\n        ctx.stroke();\n}\n//do all the checks to figure out what color is desired\nfunction getColor(style, stylealpha, init) {\n    var ret = init;\n    if (typeof style != \"undefined\") {\n        //convet regular colors\n        if (style instanceof _colors__WEBPACK_IMPORTED_MODULE_2__.Color)\n            ret = style.scaled();\n        else {\n            //hex or name\n            ret = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(style);\n            if (typeof ret.scaled != \"undefined\") {\n                ret = ret.scaled(); //not already scaled to 255\n            }\n        }\n    }\n    if (typeof stylealpha != \"undefined\") {\n        ret.a = parseFloat(stylealpha);\n    }\n    return ret;\n}\n/**\n * Renderable labels\n * @constructor $3Dmol.Label\n * @param {string} tag - Label text\n * @param {LabelSpec} parameters Label style and font specifications\n */\nclass Label {\n    constructor(text, parameters) {\n        this.id = LabelCount++;\n        this.stylespec = parameters || {};\n        this.canvas = document.createElement(\"canvas\");\n        //todo: implement resizing canvas..\n        this.canvas.width = 134;\n        this.canvas.height = 35;\n        this.context = this.canvas.getContext(\"2d\");\n        this.sprite = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Sprite();\n        this.text = text;\n        this.frame = this.stylespec.frame;\n    }\n    getStyle() {\n        return this.stylespec;\n    }\n    setContext() {\n        var style = this.stylespec;\n        var useScreen = typeof style.useScreen == \"undefined\" ? false : style.useScreen;\n        var showBackground = style.showBackground;\n        if (showBackground === \"0\" || showBackground === \"false\")\n            showBackground = false;\n        if (typeof showBackground == \"undefined\")\n            showBackground = true; //default\n        var font = style.font ? style.font : \"sans-serif\";\n        var fontSize = parseInt(style.fontSize) ? parseInt(style.fontSize) : 18;\n        var fontColor = getColor(style.fontColor, style.fontOpacity, {\n            r: 255,\n            g: 255,\n            b: 255,\n            a: 1.0,\n        });\n        var padding = style.padding ? style.padding : 4;\n        var borderThickness = style.borderThickness ? style.borderThickness : 0;\n        var backgroundColor = getColor(style.backgroundColor, style.backgroundOpacity, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1.0,\n        });\n        var borderColor = getColor(style.borderColor, style.borderOpacity, backgroundColor);\n        var position = style.position\n            ? style.position\n            : {\n                x: -10,\n                y: 1,\n                z: 1,\n            };\n        // Should labels always be in front of model?\n        var inFront = style.inFront !== undefined ? style.inFront : true;\n        if (inFront === \"false\" || inFront === \"0\")\n            inFront = false;\n        // clear canvas\n        var spriteAlignment = style.alignment || _WebGL__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment.topLeft;\n        if (typeof spriteAlignment == \"string\" &&\n            spriteAlignment in _WebGL__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment) {\n            spriteAlignment = _WebGL__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment[spriteAlignment];\n        }\n        var bold = \"\";\n        if (style.bold)\n            bold = \"bold \";\n        this.context.font = bold + fontSize + \"px  \" + font;\n        var metrics = this.context.measureText(this.text);\n        var textWidth = metrics.width;\n        if (!showBackground)\n            borderThickness = 0;\n        var width = textWidth + 2.5 * borderThickness + 2 * padding;\n        var height = fontSize * 1.25 + 2 * borderThickness + 2 * padding; // 1.25 is extra height factor for text below baseline: g,j,p,q.\n        if (style.backgroundImage) {\n            //resize label to image\n            var img = style.backgroundImage;\n            var w = style.backgroundWidth ? style.backgroundWidth : img.width;\n            var h = style.backgroundHeight ? style.backgroundHeight : img.height;\n            if (w > width)\n                width = w;\n            if (h > height)\n                height = h;\n        }\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        bold = \"\";\n        if (style.bold)\n            bold = \"bold \";\n        this.context.font = bold + fontSize + \"px  \" + font;\n        // background color\n        this.context.fillStyle =\n            \"rgba(\" +\n                backgroundColor.r +\n                \",\" +\n                backgroundColor.g +\n                \",\" +\n                backgroundColor.b +\n                \",\" +\n                backgroundColor.a +\n                \")\";\n        // border color\n        this.context.strokeStyle =\n            \"rgba(\" +\n                borderColor.r +\n                \",\" +\n                borderColor.g +\n                \",\" +\n                borderColor.b +\n                \",\" +\n                borderColor.a +\n                \")\";\n        if (style.backgroundGradient) {\n            let gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);\n            let g = _Gradient__WEBPACK_IMPORTED_MODULE_1__.Gradient.getGradient(style.backgroundGradient);\n            let minmax = g.range();\n            let min = -1;\n            let max = 1;\n            if (minmax) {\n                min = minmax[0];\n                max = minmax[1];\n            }\n            let d = max - min;\n            for (let i = 0; i < 1.01; i += 0.1) {\n                let c = getColor(g.valueToHex(min + d * i));\n                let cname = \"rgba(\" + c.r + \",\" + c.g + \",\" + c.b + \",\" + c.a + \")\";\n                gradient.addColorStop(i, cname);\n            }\n            this.context.fillStyle = gradient;\n        }\n        this.context.lineWidth = borderThickness;\n        if (showBackground) {\n            roundRect(this.context, borderThickness, borderThickness, width - 2 * borderThickness, height - 2 * borderThickness, 6, borderThickness > 0);\n        }\n        if (style.backgroundImage) {\n            this.context.drawImage(img, 0, 0, width, height);\n        }\n        // text color\n        this.context.fillStyle =\n            \"rgba(\" +\n                fontColor.r +\n                \",\" +\n                fontColor.g +\n                \",\" +\n                fontColor.b +\n                \",\" +\n                fontColor.a +\n                \")\";\n        this.context.fillText(this.text, borderThickness + padding, fontSize + borderThickness + padding, textWidth);\n        // canvas contents will be used for a texture\n        var texture = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Texture(this.canvas);\n        texture.needsUpdate = true;\n        this.sprite.material = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.SpriteMaterial({\n            map: texture,\n            useScreenCoordinates: useScreen,\n            alignment: spriteAlignment,\n            depthTest: !inFront,\n            screenOffset: style.screenOffset || null,\n        });\n        this.sprite.scale.set(1, 1, 1);\n        this.sprite.position.set(position.x, position.y, position.z);\n    }\n    // clean up material and texture\n    dispose() {\n        if (this.sprite.material.map !== undefined)\n            this.sprite.material.map.dispose();\n        if (this.sprite.material !== undefined)\n            this.sprite.material.dispose();\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/Label.ts?");

/***/ }),

/***/ "./src/ProteinSurface4.ts":
/*!********************************!*\
  !*** ./src/ProteinSurface4.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MarchingCube: () => (/* binding */ MarchingCube),\n/* harmony export */   MarchingCubeInitializer: () => (/* binding */ MarchingCubeInitializer),\n/* harmony export */   PointGrid: () => (/* binding */ PointGrid),\n/* harmony export */   ProteinSurface: () => (/* binding */ ProteinSurface),\n/* harmony export */   SurfaceType: () => (/* binding */ SurfaceType),\n/* harmony export */   setSyncSurface: () => (/* binding */ setSyncSurface),\n/* harmony export */   syncSurface: () => (/* binding */ syncSurface)\n/* harmony export */ });\n/* harmony import */ var _WebGL_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGL/math */ \"./src/WebGL/math/index.ts\");\n/*  ProteinSurface.js by biochem_fan\n\nPorted and modified for Javascript based on EDTSurf,\n  whose license is as follows.\n\nPermission to use, copy, modify, and distribute this program for any\npurpose, with or without fee, is hereby granted, provided that this\ncopyright notice and the reference information appear in all copies or\nsubstantial portions of the Software. It is provided \"as is\" without\nexpress or implied warranty.\n\nReference:\nhttp://zhanglab.ccmb.med.umich.edu/EDTSurf/\nD. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular Surfaces\nby Euclidean Distance Transform. PLoS ONE 4(12): e8140.\n\n=======\n\n\n */\n\n/**\n * Surface types\n * @readonly\n * @enum {number}\n * @property VDW - van der Waals surface\n * @property MS - Molecular surface\n * @property SAS - Solvent accessible surface\n * @property SES - Solvent exposed surface\n */\nvar SurfaceType;\n(function (SurfaceType) {\n    SurfaceType[SurfaceType[\"VDW\"] = 1] = \"VDW\";\n    SurfaceType[SurfaceType[\"MS\"] = 2] = \"MS\";\n    SurfaceType[SurfaceType[\"SAS\"] = 3] = \"SAS\";\n    SurfaceType[SurfaceType[\"SES\"] = 4] = \"SES\";\n})(SurfaceType || (SurfaceType = {}));\n;\n/**\n * Render surface synchronously if true\n * @param {boolean} [$3Dmol.syncSurface=false]\n * @type {boolean} */\nvar syncSurface = false;\n/**\n *\n * @param {boolean} val - Whether surfaces should be rendered synchronously or in parallel.\n */\nfunction setSyncSurface(val) {\n    syncSurface = val;\n}\n// Internet Explorer refuses to allow webworkers in data blobs.  I can find\n// no way of checking for this feature directly, so must do a browser check\nif (window.navigator.userAgent.indexOf('MSIE ') >= 0 ||\n    window.navigator.userAgent.indexOf('Trident/') >= 0) {\n    syncSurface = true; // can't use webworkers\n}\n//Encapsulate marching cube algorithm for isosurface generation\n// (currently used by protein surface rendering and generic volumetric data reading)\nclass MarchingCubeInitializer {\n    constructor() {\n        //Marching cube algorithm - assume data has been pre-treated so isovalue is 0 \n        // (i.e. select points greater than 0)\n        //origin -  vector of origin of volumetric data (default is (0,0,0))\n        // nX, nY, nZ - specifies number of voxels in each dimension\n        // scale - cube diagonal unit vector scale (3Dmol vector) (specifying distance between data points); diagonal of cube\n        // - default is 1 - assumes unit cube (1,1,1) diag)\n        // fulltable - if true, use full marching cubes and tritables - else use trimmed table (e.g. surf render)\n        // voxel - if true, draws with a blocky voxel style (default false)\n        // verts, faces - vertex and face arrays to fill up\n        //to match with protein surface...\n        this.ISDONE = 2;\n        /*\n         * These tables are based off those by Paul Bourke and Geoffrey Heller:\n         * http://paulbourke.net/geometry/polygonise/\n         * http://paulbourke.net/geometry/polygonise/table2.txt\n         *\n         * However, they have been substantially modified to reflect a more\n         * sensible corner numbering scheme and the discrete nature of our voxel data\n         * (resulting in fewer faces).\n         */\n        this.edgeTable = new Uint32Array([0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n            0xb00, 0x0, 0x0, 0x0, 0x700, 0x0, 0xd00, 0xe00, 0xf00, 0x0, 0x0, 0x0,\n            0x8a, 0x0, 0x15, 0x0, 0x86, 0x0, 0x0, 0x0, 0x28c, 0x0, 0x813, 0xf19,\n            0xe10, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x126, 0x0, 0x0, 0x15, 0x1c,\n            0x0, 0xf23, 0x419, 0xd20, 0x0, 0xa8, 0xa2, 0xaa, 0x0, 0x285, 0x9ab,\n            0x8a2, 0x0, 0x2af, 0x125, 0xac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x0, 0x0,\n            0x0, 0x0, 0x0, 0x45, 0x0, 0x384, 0x0, 0x0, 0x0, 0x700, 0x8a, 0x83,\n            0x648, 0x780, 0x0, 0x51, 0x0, 0x81a, 0x54, 0x55, 0x54, 0x56, 0x0, 0x51,\n            0x0, 0xe5c, 0x14a, 0x451, 0x759, 0x650, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x45,\n            0x0, 0x1f6, 0x0, 0x0, 0x15, 0xdfc, 0x8a, 0x7f3, 0x4f9, 0x5f0, 0xb00,\n            0x68, 0x921, 0x6a, 0x348, 0x245, 0x16f, 0x66, 0xb00, 0xe6f, 0xd65,\n            0xc6c, 0x76a, 0x663, 0x569, 0x460, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n            0xf46, 0x0, 0x0, 0x45, 0x24c, 0x2a, 0x823, 0x29, 0xb40, 0x0, 0x0, 0x0,\n            0x6ba, 0x0, 0x8f5, 0xfff, 0xef6, 0x0, 0xff, 0x2f5, 0x2fc, 0x9ea, 0x8f3,\n            0xbf9, 0xaf0, 0x0, 0x0, 0x51, 0x152, 0x0, 0xf55, 0x45f, 0xd56, 0x54,\n            0x357, 0x55, 0x154, 0x852, 0xb53, 0x59, 0x950, 0x700, 0x2c8, 0xc2,\n            0x48a, 0xfc4, 0xec5, 0xdcf, 0xcc6, 0x2c4, 0x2cf, 0xc5, 0xcc, 0xbca,\n            0xac3, 0x9c9, 0x8c0, 0x0, 0x0, 0x0, 0x0, 0xa8, 0x1a4, 0xa8, 0x7a6,\n            0xa2, 0xa2, 0x2a4, 0xbac, 0xaa, 0xa3, 0x2a8, 0x3a0, 0xd00, 0xc18,\n            0xd00, 0xe3a, 0x34, 0x35, 0x73f, 0x636, 0x924, 0x83f, 0xb35, 0xa3c,\n            0x12a, 0x33, 0x339, 0x230, 0xe00, 0xe00, 0xc12, 0xd9a, 0x684, 0x795,\n            0x49f, 0x596, 0x92, 0xb9f, 0x815, 0x99c, 0x9a, 0x393, 0x99, 0x190,\n            0xf00, 0xe08, 0xd01, 0xc0a, 0x704, 0x605, 0x50f, 0x406, 0xb02, 0xa0f,\n            0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0]);\n        this.triTable = [[], [], [], [], [], [], [], [11, 9, 8], [], [], [],\n            [8, 10, 9], [], [10, 8, 11], [9, 11, 10],\n            [8, 10, 9, 8, 11, 10], [], [], [], [1, 7, 3], [], [4, 2, 0], [],\n            [2, 1, 7], [], [], [], [2, 7, 3, 2, 9, 7], [],\n            [1, 4, 11, 1, 0, 4], [3, 8, 0, 11, 9, 4, 11, 10, 9],\n            [4, 11, 9, 11, 10, 9], [], [], [], [5, 3, 1], [], [], [],\n            [2, 5, 8, 2, 1, 5], [], [], [2, 4, 0], [3, 2, 4], [],\n            [0, 9, 1, 8, 10, 5, 8, 11, 10], [3, 4, 0, 3, 10, 4],\n            [5, 8, 10, 8, 11, 10], [], [3, 5, 7], [7, 1, 5],\n            [1, 7, 3, 1, 5, 7], [], [9, 2, 0, 9, 7, 2],\n            [0, 3, 8, 1, 7, 11, 1, 5, 7], [11, 1, 7, 1, 5, 7], [],\n            [9, 1, 0, 5, 3, 2, 5, 7, 3], [8, 2, 5, 8, 0, 2],\n            [2, 5, 3, 5, 7, 3], [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],\n            [9, 1, 0, 10, 7, 11, 10, 5, 7], [3, 8, 0, 7, 10, 5, 7, 11, 10],\n            [11, 5, 7, 11, 10, 5], [], [], [], [], [], [0, 6, 2], [],\n            [7, 2, 9, 7, 9, 8], [], [], [], [8, 10, 9], [7, 1, 3],\n            [7, 1, 0], [6, 9, 3, 6, 10, 9], [7, 10, 8, 10, 9, 8], [],\n            [6, 0, 4], [], [11, 1, 4, 11, 3, 1], [2, 4, 6],\n            [2, 0, 4, 2, 4, 6], [2, 4, 6], [1, 4, 2, 4, 6, 2], [],\n            [6, 0, 4], [], [2, 11, 3, 6, 9, 4, 6, 10, 9], [8, 6, 1, 8, 1, 3],\n            [10, 0, 6, 0, 4, 6], [8, 0, 3, 9, 6, 10, 9, 4, 6],\n            [10, 4, 6, 10, 9, 4], [], [], [], [5, 3, 1], [], [0, 6, 2], [],\n            [7, 4, 8, 5, 2, 1, 5, 6, 2], [], [], [2, 4, 0],\n            [7, 4, 8, 2, 11, 3, 10, 5, 6], [7, 1, 3],\n            [5, 6, 10, 0, 9, 1, 8, 7, 4], [5, 6, 10, 7, 0, 3, 7, 4, 0],\n            [10, 5, 6, 4, 8, 7], [9, 11, 8], [3, 5, 6],\n            [0, 5, 11, 0, 11, 8], [6, 3, 5, 3, 1, 5], [3, 9, 6, 3, 8, 9],\n            [9, 6, 0, 6, 2, 0], [0, 3, 8, 2, 5, 6, 2, 1, 5],\n            [1, 6, 2, 1, 5, 6], [9, 11, 8], [1, 0, 9, 6, 10, 5, 11, 3, 2],\n            [6, 10, 5, 2, 8, 0, 2, 11, 8], [3, 2, 11, 10, 5, 6],\n            [10, 5, 6, 9, 3, 8, 9, 1, 3], [0, 9, 1, 5, 6, 10],\n            [8, 0, 3, 10, 5, 6], [10, 5, 6], [], [], [], [], [], [], [],\n            [1, 10, 2, 9, 11, 6, 9, 8, 11], [], [], [6, 0, 2],\n            [3, 6, 9, 3, 2, 6], [3, 5, 1], [0, 5, 1, 0, 11, 5], [0, 3, 5],\n            [6, 9, 11, 9, 8, 11], [], [], [], [4, 5, 9, 7, 1, 10, 7, 3, 1], [],\n            [11, 6, 7, 2, 4, 5, 2, 0, 4],\n            [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],\n            [6, 7, 11, 1, 10, 2, 9, 4, 5], [],\n            [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2], [9, 4, 5, 0, 6, 7, 0, 2, 6],\n            [4, 5, 9, 6, 3, 2, 6, 7, 3], [6, 7, 11, 5, 3, 8, 5, 1, 3],\n            [6, 7, 11, 4, 1, 0, 4, 5, 1], [4, 5, 9, 3, 8, 0, 11, 6, 7],\n            [9, 4, 5, 7, 11, 6], [], [], [0, 6, 4], [8, 6, 4, 8, 1, 6], [],\n            [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],\n            [10, 2, 1, 6, 0, 3, 6, 4, 0], [10, 2, 1, 11, 4, 8, 11, 6, 4],\n            [4, 2, 6], [1, 0, 9, 2, 4, 8, 2, 6, 4], [2, 4, 0, 2, 6, 4],\n            [8, 2, 4, 2, 6, 4], [11, 4, 1, 11, 6, 4],\n            [0, 9, 1, 4, 11, 6, 4, 8, 11], [3, 6, 0, 6, 4, 0],\n            [8, 6, 4, 8, 11, 6], [10, 8, 9], [6, 3, 9, 6, 7, 3], [6, 7, 1],\n            [10, 7, 1, 7, 3, 1], [7, 11, 6, 8, 10, 2, 8, 9, 10],\n            [11, 6, 7, 10, 0, 9, 10, 2, 0], [2, 1, 10, 7, 11, 6, 8, 0, 3],\n            [1, 10, 2, 6, 7, 11], [7, 2, 6, 7, 9, 2],\n            [1, 0, 9, 3, 6, 7, 3, 2, 6], [7, 0, 6, 0, 2, 6],\n            [2, 7, 3, 2, 6, 7], [7, 11, 6, 3, 9, 1, 3, 8, 9],\n            [9, 1, 0, 11, 6, 7], [0, 3, 8, 11, 6, 7], [11, 6, 7], [], [], [],\n            [], [5, 3, 7], [8, 5, 2, 8, 7, 5], [5, 3, 7],\n            [1, 10, 2, 5, 8, 7, 5, 9, 8], [1, 7, 5], [1, 7, 5],\n            [9, 2, 7, 9, 7, 5], [11, 3, 2, 8, 5, 9, 8, 7, 5],\n            [1, 3, 7, 1, 7, 5], [0, 7, 1, 7, 5, 1], [9, 3, 5, 3, 7, 5],\n            [9, 7, 5, 9, 8, 7], [8, 10, 11], [3, 4, 10, 3, 10, 11],\n            [8, 10, 11], [5, 9, 4, 1, 11, 3, 1, 10, 11], [2, 4, 5],\n            [5, 2, 4, 2, 0, 4], [0, 3, 8, 5, 9, 4, 10, 2, 1],\n            [2, 1, 10, 9, 4, 5], [2, 8, 5, 2, 11, 8],\n            [3, 2, 11, 1, 4, 5, 1, 0, 4], [9, 4, 5, 8, 2, 11, 8, 0, 2],\n            [11, 3, 2, 9, 4, 5], [8, 5, 3, 5, 1, 3], [5, 0, 4, 5, 1, 0],\n            [3, 8, 0, 4, 5, 9], [9, 4, 5], [11, 9, 10], [11, 9, 10],\n            [1, 11, 4, 1, 10, 11], [8, 7, 4, 11, 1, 10, 11, 3, 1],\n            [2, 7, 9, 2, 9, 10], [4, 8, 7, 0, 10, 2, 0, 9, 10],\n            [2, 1, 10, 0, 7, 4, 0, 3, 7], [10, 2, 1, 8, 7, 4], [1, 7, 4],\n            [3, 2, 11, 4, 8, 7, 9, 1, 0], [11, 4, 2, 4, 0, 2],\n            [2, 11, 3, 7, 4, 8], [4, 1, 7, 1, 3, 7], [1, 0, 9, 8, 7, 4],\n            [3, 4, 0, 3, 7, 4], [8, 7, 4], [8, 9, 10, 8, 10, 11],\n            [3, 9, 11, 9, 10, 11], [0, 10, 8, 10, 11, 8],\n            [10, 3, 1, 10, 11, 3], [2, 8, 10, 8, 9, 10], [9, 2, 0, 9, 10, 2],\n            [8, 0, 3, 1, 10, 2], [10, 2, 1], [1, 11, 9, 11, 8, 9],\n            [11, 3, 2, 0, 9, 1], [11, 0, 2, 11, 8, 0], [11, 3, 2],\n            [8, 1, 3, 8, 9, 1], [9, 1, 0], [8, 0, 3], []];\n        this.edgeTable2 = [0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f,\n            0xb06, 0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190,\n            0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96, 0x596, 0x49f, 0x795,\n            0x69c, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0xa3c,\n            0xb35, 0x83f, 0x936, 0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39,\n            0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6, 0x7a6,\n            0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x8c0, 0x9c9, 0xac3,\n            0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca,\n            0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f,\n            0x256, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650, 0xaf0,\n            0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6, 0xef6, 0xfff, 0xcf5,\n            0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0x36c,\n            0x265, 0x16f, 0x66, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569,\n            0x460, 0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x66,\n            0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3,\n            0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa,\n            0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f,\n            0xd56, 0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0,\n            0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0x3c6, 0x2cf, 0x1c5,\n            0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0, 0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac,\n            0x5a5, 0x6af, 0x7a6, 0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9,\n            0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636, 0x936,\n            0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93,\n            0xd9a, 0x69c, 0x795, 0x49f, 0x596, 0xa96, 0xb9f, 0x895, 0x99c, 0x29a,\n            0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f,\n            0x406, 0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0];\n        this.triTable2 = [[], [8, 3, 0], [9, 0, 1], [8, 3, 1, 8, 1, 9],\n            [11, 2, 3], [11, 2, 0, 11, 0, 8], [11, 2, 3, 0, 1, 9],\n            [2, 1, 11, 1, 9, 11, 11, 9, 8], [10, 1, 2], [8, 3, 0, 1, 2, 10],\n            [9, 0, 2, 9, 2, 10], [3, 2, 8, 2, 10, 8, 8, 10, 9],\n            [10, 1, 3, 10, 3, 11], [1, 0, 10, 0, 8, 10, 10, 8, 11],\n            [0, 3, 9, 3, 11, 9, 9, 11, 10], [8, 10, 9, 8, 11, 10], [8, 4, 7],\n            [3, 0, 4, 3, 4, 7], [1, 9, 0, 8, 4, 7],\n            [9, 4, 1, 4, 7, 1, 1, 7, 3], [2, 3, 11, 7, 8, 4],\n            [7, 11, 4, 11, 2, 4, 4, 2, 0], [3, 11, 2, 4, 7, 8, 9, 0, 1],\n            [2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4], [10, 1, 2, 8, 4, 7],\n            [2, 10, 1, 0, 4, 7, 0, 7, 3], [4, 7, 8, 0, 2, 10, 0, 10, 9],\n            [2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9],\n            [8, 4, 7, 11, 10, 1, 11, 1, 3],\n            [11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4],\n            [3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9],\n            [7, 11, 4, 4, 11, 9, 11, 10, 9], [9, 5, 4], [3, 0, 8, 4, 9, 5],\n            [5, 4, 0, 5, 0, 1], [4, 8, 5, 8, 3, 5, 5, 3, 1],\n            [11, 2, 3, 9, 5, 4], [9, 5, 4, 8, 11, 2, 8, 2, 0],\n            [3, 11, 2, 1, 5, 4, 1, 4, 0],\n            [8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5], [2, 10, 1, 9, 5, 4],\n            [0, 8, 3, 5, 4, 9, 10, 1, 2], [10, 5, 2, 5, 4, 2, 2, 4, 0],\n            [3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5],\n            [5, 4, 9, 1, 3, 11, 1, 11, 10],\n            [0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10],\n            [3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10],\n            [4, 8, 5, 5, 8, 10, 8, 11, 10], [9, 5, 7, 9, 7, 8],\n            [0, 9, 3, 9, 5, 3, 3, 5, 7], [8, 0, 7, 0, 1, 7, 7, 1, 5],\n            [1, 7, 3, 1, 5, 7], [11, 2, 3, 8, 9, 5, 8, 5, 7],\n            [9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7],\n            [0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7],\n            [2, 1, 11, 11, 1, 7, 1, 5, 7], [1, 2, 10, 5, 7, 8, 5, 8, 9],\n            [9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3],\n            [5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2],\n            [10, 5, 2, 2, 5, 3, 5, 7, 3],\n            [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],\n            [9, 1, 0, 10, 7, 11, 10, 5, 7], [3, 8, 0, 7, 10, 5, 7, 11, 10],\n            [11, 5, 7, 11, 10, 5], [11, 7, 6], [0, 8, 3, 11, 7, 6],\n            [9, 0, 1, 11, 7, 6], [7, 6, 11, 3, 1, 9, 3, 9, 8],\n            [2, 3, 7, 2, 7, 6], [8, 7, 0, 7, 6, 0, 0, 6, 2],\n            [1, 9, 0, 3, 7, 6, 3, 6, 2], [7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8],\n            [1, 2, 10, 6, 11, 7], [2, 10, 1, 7, 6, 11, 8, 3, 0],\n            [11, 7, 6, 10, 9, 0, 10, 0, 2],\n            [7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9],\n            [6, 10, 7, 10, 1, 7, 7, 1, 3],\n            [6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8],\n            [9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7],\n            [6, 10, 7, 7, 10, 8, 10, 9, 8], [8, 4, 6, 8, 6, 11],\n            [11, 3, 6, 3, 0, 6, 6, 0, 4], [0, 1, 9, 4, 6, 11, 4, 11, 8],\n            [1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6],\n            [3, 8, 2, 8, 4, 2, 2, 4, 6], [2, 0, 4, 2, 4, 6],\n            [1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6], [9, 4, 1, 1, 4, 2, 4, 6, 2],\n            [10, 1, 2, 11, 8, 4, 11, 4, 6],\n            [10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4],\n            [0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11],\n            [2, 11, 3, 6, 9, 4, 6, 10, 9],\n            [8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3],\n            [1, 0, 10, 10, 0, 6, 0, 4, 6], [8, 0, 3, 9, 6, 10, 9, 4, 6],\n            [10, 4, 6, 10, 9, 4], [9, 5, 4, 7, 6, 11],\n            [4, 9, 5, 3, 0, 8, 11, 7, 6], [6, 11, 7, 4, 0, 1, 4, 1, 5],\n            [6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1], [4, 9, 5, 6, 2, 3, 6, 3, 7],\n            [9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2],\n            [4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3], [7, 4, 8, 5, 2, 1, 5, 6, 2],\n            [6, 11, 7, 1, 2, 10, 9, 5, 4],\n            [11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4],\n            [11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0],\n            [7, 4, 8, 2, 11, 3, 10, 5, 6],\n            [4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3],\n            [5, 6, 10, 0, 9, 1, 8, 7, 4], [5, 6, 10, 7, 0, 3, 7, 4, 0],\n            [10, 5, 6, 4, 8, 7], [5, 6, 9, 6, 11, 9, 9, 11, 8],\n            [0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11],\n            [0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8],\n            [11, 3, 6, 6, 3, 5, 3, 1, 5], [9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2],\n            [5, 6, 9, 9, 6, 0, 6, 2, 0], [0, 3, 8, 2, 5, 6, 2, 1, 5],\n            [1, 6, 2, 1, 5, 6], [1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8],\n            [1, 0, 9, 6, 10, 5, 11, 3, 2], [6, 10, 5, 2, 8, 0, 2, 11, 8],\n            [3, 2, 11, 10, 5, 6], [10, 5, 6, 9, 3, 8, 9, 1, 3],\n            [0, 9, 1, 5, 6, 10], [8, 0, 3, 10, 5, 6], [10, 5, 6],\n            [10, 6, 5], [8, 3, 0, 10, 6, 5], [0, 1, 9, 5, 10, 6],\n            [10, 6, 5, 9, 8, 3, 9, 3, 1], [3, 11, 2, 10, 6, 5],\n            [6, 5, 10, 2, 0, 8, 2, 8, 11], [1, 9, 0, 6, 5, 10, 11, 2, 3],\n            [1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11], [1, 2, 6, 1, 6, 5],\n            [0, 8, 3, 2, 6, 5, 2, 5, 1], [5, 9, 6, 9, 0, 6, 6, 0, 2],\n            [9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6], [11, 6, 3, 6, 5, 3, 3, 5, 1],\n            [0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11],\n            [0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6],\n            [5, 9, 6, 6, 9, 11, 9, 8, 11], [10, 6, 5, 4, 7, 8],\n            [5, 10, 6, 7, 3, 0, 7, 0, 4], [5, 10, 6, 0, 1, 9, 8, 4, 7],\n            [4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1],\n            [7, 8, 4, 2, 3, 11, 10, 6, 5],\n            [11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4],\n            [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],\n            [6, 7, 11, 1, 10, 2, 9, 4, 5], [7, 8, 4, 5, 1, 2, 5, 2, 6],\n            [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],\n            [9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6], [4, 5, 9, 6, 3, 2, 6, 7, 3],\n            [6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3],\n            [6, 7, 11, 4, 1, 0, 4, 5, 1], [4, 5, 9, 3, 8, 0, 11, 6, 7],\n            [9, 4, 5, 7, 11, 6], [10, 6, 4, 10, 4, 9],\n            [8, 3, 0, 9, 10, 6, 9, 6, 4], [1, 10, 0, 10, 6, 0, 0, 6, 4],\n            [8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1],\n            [2, 3, 11, 6, 4, 9, 6, 9, 10],\n            [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],\n            [10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0],\n            [10, 2, 1, 11, 4, 8, 11, 6, 4], [9, 1, 4, 1, 2, 4, 4, 2, 6],\n            [1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4], [2, 4, 0, 2, 6, 4],\n            [3, 2, 8, 8, 2, 4, 2, 6, 4],\n            [1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4],\n            [0, 9, 1, 4, 11, 6, 4, 8, 11], [11, 6, 3, 3, 6, 0, 6, 4, 0],\n            [8, 6, 4, 8, 11, 6], [6, 7, 10, 7, 8, 10, 10, 8, 9],\n            [9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3],\n            [6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0],\n            [6, 7, 10, 10, 7, 1, 7, 3, 1],\n            [7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10],\n            [11, 6, 7, 10, 0, 9, 10, 2, 0], [2, 1, 10, 7, 11, 6, 8, 0, 3],\n            [1, 10, 2, 6, 7, 11], [7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9],\n            [1, 0, 9, 3, 6, 7, 3, 2, 6], [8, 0, 7, 7, 0, 6, 0, 2, 6],\n            [2, 7, 3, 2, 6, 7], [7, 11, 6, 3, 9, 1, 3, 8, 9],\n            [9, 1, 0, 11, 6, 7], [0, 3, 8, 11, 6, 7], [11, 6, 7],\n            [11, 7, 5, 11, 5, 10], [3, 0, 8, 7, 5, 10, 7, 10, 11],\n            [9, 0, 1, 10, 11, 7, 10, 7, 5],\n            [3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10],\n            [10, 2, 5, 2, 3, 5, 5, 3, 7],\n            [5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0],\n            [9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7],\n            [1, 10, 2, 5, 8, 7, 5, 9, 8], [2, 11, 1, 11, 7, 1, 1, 7, 5],\n            [0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5],\n            [9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5],\n            [11, 3, 2, 8, 5, 9, 8, 7, 5], [1, 3, 7, 1, 7, 5],\n            [8, 7, 0, 0, 7, 1, 7, 5, 1], [0, 3, 9, 9, 3, 5, 3, 7, 5],\n            [9, 7, 5, 9, 8, 7], [4, 5, 8, 5, 10, 8, 8, 10, 11],\n            [3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11],\n            [0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11],\n            [5, 9, 4, 1, 11, 3, 1, 10, 11],\n            [3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10],\n            [10, 2, 5, 5, 2, 4, 2, 0, 4], [0, 3, 8, 5, 9, 4, 10, 2, 1],\n            [2, 1, 10, 9, 4, 5], [8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1],\n            [3, 2, 11, 1, 4, 5, 1, 0, 4], [9, 4, 5, 8, 2, 11, 8, 0, 2],\n            [11, 3, 2, 9, 4, 5], [4, 5, 8, 8, 5, 3, 5, 1, 3],\n            [5, 0, 4, 5, 1, 0], [3, 8, 0, 4, 5, 9], [9, 4, 5],\n            [7, 4, 11, 4, 9, 11, 11, 9, 10],\n            [3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10],\n            [11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0],\n            [8, 7, 4, 11, 1, 10, 11, 3, 1],\n            [2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10],\n            [4, 8, 7, 0, 10, 2, 0, 9, 10], [2, 1, 10, 0, 7, 4, 0, 3, 7],\n            [10, 2, 1, 8, 7, 4], [2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9],\n            [3, 2, 11, 4, 8, 7, 9, 1, 0], [7, 4, 11, 11, 4, 2, 4, 0, 2],\n            [2, 11, 3, 7, 4, 8], [9, 1, 4, 4, 1, 7, 1, 3, 7],\n            [1, 0, 9, 8, 7, 4], [3, 4, 0, 3, 7, 4], [8, 7, 4],\n            [8, 9, 10, 8, 10, 11], [0, 9, 3, 3, 9, 11, 9, 10, 11],\n            [1, 10, 0, 0, 10, 8, 10, 11, 8], [10, 3, 1, 10, 11, 3],\n            [3, 8, 2, 2, 8, 10, 8, 9, 10], [9, 2, 0, 9, 10, 2],\n            [8, 0, 3, 1, 10, 2], [10, 2, 1], [2, 11, 1, 1, 11, 9, 11, 8, 9],\n            [11, 3, 2, 0, 9, 1], [11, 0, 2, 11, 8, 0], [11, 3, 2],\n            [8, 1, 3, 8, 9, 1], [9, 1, 0], [8, 0, 3], []];\n    }\n    march(data, verts, faces, spec) {\n        let fulltable = !!(spec.fulltable);\n        let origin = (spec.hasOwnProperty('origin') && spec.origin.hasOwnProperty('x')) ? spec.origin : { x: 0, y: 0, z: 0 };\n        let voxel = !!(spec.voxel);\n        let transform = spec.matrix; //if this is set, it overrides origin and unitCube\n        let nX = spec.nX || 0;\n        let nY = spec.nY || 0;\n        let nZ = spec.nZ || 0;\n        let scale = spec.scale || 1.0;\n        let unitCube = null;\n        if (spec.unitCube) {\n            unitCube = spec.unitCube;\n        }\n        else {\n            unitCube = { x: scale, y: scale, z: scale };\n        }\n        //keep track of calculated vertices to avoid repeats\n        let vertnums = new Int32Array(nX * nY * nZ);\n        let i, il;\n        for (i = 0, il = vertnums.length; i < il; ++i)\n            vertnums[i] = -1;\n        // create (or retrieve) a vertex at the appropriate point for\n        // the edge (p1,p2)\n        let getVertex = function (i, j, k, code, p1, p2) {\n            let pt = { x: 0, y: 0, z: 0 };\n            let val1 = !!(code & (1 << p1));\n            let val2 = !!(code & (1 << p2));\n            // p1 if they are the same or if !val1\n            let p = p1;\n            if (!val1 && val2)\n                p = p2;\n            // adjust i,j,k by p\n            if (p & 1)\n                k++;\n            if (p & 2)\n                j++;\n            if (p & 4)\n                i++;\n            if (transform) {\n                let vpt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(i, j, k);\n                vpt = vpt.applyMatrix4(transform);\n                pt = { x: vpt.x, y: vpt.y, z: vpt.z }; //remove vector gunk\n            }\n            else {\n                pt.x = origin.x + unitCube.x * i;\n                pt.y = origin.y + unitCube.y * j;\n                pt.z = origin.z + unitCube.z * k;\n            }\n            let index = ((nY * i) + j) * nZ + k;\n            //Have to add option to do voxels\n            if (!voxel) {\n                if (vertnums[index] < 0) // not created yet\n                 {\n                    vertnums[index] = verts.length;\n                    verts.push(pt);\n                }\n                return vertnums[index];\n            }\n            else {\n                verts.push(pt);\n                return verts.length - 1;\n            }\n        };\n        let intersects = new Int32Array(12);\n        let etable = (fulltable) ? this.edgeTable2 : this.edgeTable;\n        let tritable = (fulltable) ? this.triTable2 : this.triTable;\n        //Run marching cubes algorithm\n        for (i = 0; i < nX - 1; ++i) {\n            for (let j = 0; j < nY - 1; ++j) {\n                for (let k = 0; k < nZ - 1; ++k) {\n                    let code = 0;\n                    for (let p = 0; p < 8; ++p) {\n                        let index = ((nY * (i + ((p & 4) >> 2))) + j + ((p & 2) >> 1)) *\n                            nZ + k + (p & 1);\n                        //TODO: Need to fix vpBits in protein surface for this to work\n                        let val = !!(data[index] & this.ISDONE);\n                        //let val = !!(data[index] > 0);   \n                        code |= val << p;\n                    }\n                    if (code === 0 || code === 255)\n                        continue;\n                    let ecode = etable[code];\n                    if (ecode === 0)\n                        continue;\n                    let ttable = tritable[code];\n                    if (ecode & 1)\n                        intersects[0] = getVertex(i, j, k, code, 0, 1);\n                    if (ecode & 2)\n                        intersects[1] = getVertex(i, j, k, code, 1, 3);\n                    if (ecode & 4)\n                        intersects[2] = getVertex(i, j, k, code, 3, 2);\n                    if (ecode & 8)\n                        intersects[3] = getVertex(i, j, k, code, 2, 0);\n                    if (ecode & 16)\n                        intersects[4] = getVertex(i, j, k, code, 4, 5);\n                    if (ecode & 32)\n                        intersects[5] = getVertex(i, j, k, code, 5, 7);\n                    if (ecode & 64)\n                        intersects[6] = getVertex(i, j, k, code, 7, 6);\n                    if (ecode & 128)\n                        intersects[7] = getVertex(i, j, k, code, 6, 4);\n                    if (ecode & 256)\n                        intersects[8] = getVertex(i, j, k, code, 0, 4);\n                    if (ecode & 512)\n                        intersects[9] = getVertex(i, j, k, code, 1, 5);\n                    if (ecode & 1024)\n                        intersects[10] = getVertex(i, j, k, code, 3, 7);\n                    if (ecode & 2048)\n                        intersects[11] = getVertex(i, j, k, code, 2, 6);\n                    for (let t = 0; t < ttable.length; t += 3) {\n                        let a = intersects[ttable[t]], b = intersects[ttable[t + 1]], c = intersects[ttable[t + 2]];\n                        if (voxel && t >= 3) {\n                            verts.push(verts[a]);\n                            a = verts.length - 1;\n                            verts.push(verts[b]);\n                            b = verts.length - 1;\n                            verts.push(verts[c]);\n                            c = verts.length - 1;\n                        }\n                        faces.push(a);\n                        faces.push(b);\n                        faces.push(c);\n                    }\n                }\n            }\n        }\n    }\n    ;\n    laplacianSmooth(numiter, verts, faces) {\n        let tps = new Array(verts.length);\n        let i, il, j, jl, k;\n        for (i = 0, il = verts.length; i < il; i++)\n            tps[i] = {\n                x: 0,\n                y: 0,\n                z: 0\n            };\n        let vertdeg = new Array(20);\n        let flagvert;\n        for (i = 0; i < 20; i++)\n            vertdeg[i] = new Array(verts.length);\n        for (i = 0, il = verts.length; i < il; i++)\n            vertdeg[0][i] = 0;\n        for (i = 0, il = faces.length / 3; i < il; i++) {\n            let aoffset = i * 3, boffset = i * 3 + 1, coffset = i * 3 + 2;\n            flagvert = true;\n            for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {\n                if (faces[boffset] == vertdeg[j + 1][faces[aoffset]]) {\n                    flagvert = false;\n                    break;\n                }\n            }\n            if (flagvert) {\n                vertdeg[0][faces[aoffset]]++;\n                vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[boffset];\n            }\n            flagvert = true;\n            for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {\n                if (faces[coffset] == vertdeg[j + 1][faces[aoffset]]) {\n                    flagvert = false;\n                    break;\n                }\n            }\n            if (flagvert) {\n                vertdeg[0][faces[aoffset]]++;\n                vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[coffset];\n            }\n            // b\n            flagvert = true;\n            for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {\n                if (faces[aoffset] == vertdeg[j + 1][faces[boffset]]) {\n                    flagvert = false;\n                    break;\n                }\n            }\n            if (flagvert) {\n                vertdeg[0][faces[boffset]]++;\n                vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[aoffset];\n            }\n            flagvert = true;\n            for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {\n                if (faces[coffset] == vertdeg[j + 1][faces[boffset]]) {\n                    flagvert = false;\n                    break;\n                }\n            }\n            if (flagvert) {\n                vertdeg[0][faces[boffset]]++;\n                vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[coffset];\n            }\n            // c\n            flagvert = true;\n            for (j = 0; j < vertdeg[0][faces[coffset]]; j++) {\n                if (faces[aoffset] == vertdeg[j + 1][faces[coffset]]) {\n                    flagvert = false;\n                    break;\n                }\n            }\n            if (flagvert) {\n                vertdeg[0][faces[coffset]]++;\n                vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[aoffset];\n            }\n            flagvert = true;\n            for (j = 0, jl = vertdeg[0][faces[coffset]]; j < jl; j++) {\n                if (faces[boffset] == vertdeg[j + 1][faces[coffset]]) {\n                    flagvert = false;\n                    break;\n                }\n            }\n            if (flagvert) {\n                vertdeg[0][faces[coffset]]++;\n                vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[boffset];\n            }\n        }\n        let wt = 1.00;\n        let wt2 = 0.50;\n        for (k = 0; k < numiter; k++) {\n            for (i = 0, il = verts.length; i < il; i++) {\n                if (vertdeg[0][i] < 3) {\n                    tps[i].x = verts[i].x;\n                    tps[i].y = verts[i].y;\n                    tps[i].z = verts[i].z;\n                }\n                else if (vertdeg[0][i] == 3 || vertdeg[0][i] == 4) {\n                    tps[i].x = 0;\n                    tps[i].y = 0;\n                    tps[i].z = 0;\n                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {\n                        tps[i].x += verts[vertdeg[j + 1][i]].x;\n                        tps[i].y += verts[vertdeg[j + 1][i]].y;\n                        tps[i].z += verts[vertdeg[j + 1][i]].z;\n                    }\n                    tps[i].x += wt2 * verts[i].x;\n                    tps[i].y += wt2 * verts[i].y;\n                    tps[i].z += wt2 * verts[i].z;\n                    tps[i].x /= wt2 + vertdeg[0][i];\n                    tps[i].y /= wt2 + vertdeg[0][i];\n                    tps[i].z /= wt2 + vertdeg[0][i];\n                }\n                else {\n                    tps[i].x = 0;\n                    tps[i].y = 0;\n                    tps[i].z = 0;\n                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {\n                        tps[i].x += verts[vertdeg[j + 1][i]].x;\n                        tps[i].y += verts[vertdeg[j + 1][i]].y;\n                        tps[i].z += verts[vertdeg[j + 1][i]].z;\n                    }\n                    tps[i].x += wt * verts[i].x;\n                    tps[i].y += wt * verts[i].y;\n                    tps[i].z += wt * verts[i].z;\n                    tps[i].x /= wt + vertdeg[0][i];\n                    tps[i].y /= wt + vertdeg[0][i];\n                    tps[i].z /= wt + vertdeg[0][i];\n                }\n            }\n            for (i = 0, il = verts.length; i < il; i++) {\n                verts[i].x = tps[i].x;\n                verts[i].y = tps[i].y;\n                verts[i].z = tps[i].z;\n            }\n            /*\n             * computenorm(); for (let i = 0; i < vertnumber; i++) { if\n             * (verts[i].inout) ssign = 1; else ssign = -1; verts[i].x += ssign *\n             * outwt * verts[i].pn.x; verts[i].y += ssign * outwt *\n             * verts[i].pn.y; verts[i].z += ssign * outwt * verts[i].pn.z; }\n             */\n        }\n    }\n    ;\n}\n;\nlet MarchingCube = new MarchingCubeInitializer();\n//each webworker needs its own marching cube object\n// a little class for 3d array, should really generalize this and\n// use throughout...\nclass PointGrid {\n    constructor(length, width, height) {\n        // the standard says this is zero initialized\n        this.data = new Int32Array(length * width * height * 3);\n        this.width = width;\n        this.height = height;\n    }\n    // set position x,y,z to pt, which has ix,iy,and iz\n    set(x, y, z, pt) {\n        let index = ((((x * this.width) + y) * this.height) + z) * 3;\n        this.data[index] = pt.ix;\n        this.data[index + 1] = pt.iy;\n        this.data[index + 2] = pt.iz;\n    }\n    ;\n    // return point at x,y,z\n    get(x, y, z) {\n        let index = ((((x * this.width) + y) * this.height) + z) * 3;\n        return {\n            ix: this.data[index],\n            iy: this.data[index + 1],\n            iz: this.data[index + 2]\n        };\n    }\n    ;\n}\n;\n/*\n * @type Class\n*/\nclass ProteinSurface {\n    constructor() {\n        // constants for vpbits bitmasks\n        this.INOUT = 1;\n        this.ISDONE = 2;\n        this.ISBOUND = 4;\n        this.ptranx = 0;\n        this.ptrany = 0;\n        this.ptranz = 0;\n        this.probeRadius = 1.4;\n        this.defaultScaleFactor = 2;\n        this.scaleFactor = this.defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,\n        // also have to adjust offset used to find non-shown\n        // atoms\n        this.pHeight = 0;\n        this.pWidth = 0;\n        this.pLength = 0;\n        this.cutRadius = 0;\n        this.vpBits = null; // uint8 array of bitmasks\n        this.vpDistance = null; // floatarray of _squared_ distances\n        this.vpAtomID = null; // intarray\n        this.pminx = 0;\n        this.pminy = 0;\n        this.pminz = 0;\n        this.pmaxx = 0;\n        this.pmaxy = 0;\n        this.pmaxz = 0;\n        this.depty = {};\n        this.widxz = {};\n        this.faces = [];\n        this.verts = [];\n        this.vdwRadii = {\n            \"H\": 1.2,\n            \"Li\": 1.82,\n            \"Na\": 2.27,\n            \"K\": 2.75,\n            \"C\": 1.7,\n            \"N\": 1.55,\n            \"O\": 1.52,\n            \"F\": 1.47,\n            \"P\": 1.80,\n            \"S\": 1.80,\n            \"CL\": 1.75,\n            \"BR\": 1.85,\n            \"SE\": 1.90,\n            \"ZN\": 1.39,\n            \"CU\": 1.4,\n            \"NI\": 1.63,\n            \"X\": 2\n        };\n        this.nb = [new Int32Array([1, 0, 0]), new Int32Array([-1, 0, 0]),\n            new Int32Array([0, 1, 0]), new Int32Array([0, -1, 0]),\n            new Int32Array([0, 0, 1]),\n            new Int32Array([0, 0, -1]),\n            new Int32Array([1, 1, 0]),\n            new Int32Array([1, -1, 0]),\n            new Int32Array([-1, 1, 0]),\n            new Int32Array([-1, -1, 0]),\n            new Int32Array([1, 0, 1]),\n            new Int32Array([1, 0, -1]),\n            new Int32Array([-1, 0, 1]),\n            new Int32Array([-1, 0, -1]),\n            new Int32Array([0, 1, 1]),\n            new Int32Array([0, 1, -1]),\n            new Int32Array([0, -1, 1]),\n            new Int32Array([0, -1, -1]),\n            new Int32Array([1, 1, 1]),\n            new Int32Array([1, 1, -1]),\n            new Int32Array([1, -1, 1]),\n            new Int32Array([-1, 1, 1]),\n            new Int32Array([1, -1, -1]),\n            new Int32Array([-1, -1, 1]),\n            new Int32Array([-1, 1, -1]),\n            new Int32Array([-1, -1, -1])];\n        if (!ProteinSurface.MarchingCube) {\n            //this is needed by webworkers\n            ProteinSurface.MarchingCube = new MarchingCubeInitializer();\n        }\n    }\n    getVDWIndex(atom) {\n        if (!atom.elem || typeof (this.vdwRadii[atom.elem]) == \"undefined\") {\n            return \"X\";\n        }\n        return atom.elem;\n    }\n    ;\n    getFacesAndVertices(atomlist) {\n        let atomsToShow = {};\n        for (let i = 0, il = atomlist.length; i < il; i++)\n            atomsToShow[atomlist[i]] = true;\n        let vertices = this.verts;\n        for (let i = 0, il = vertices.length; i < il; i++) {\n            vertices[i].x = vertices[i].x / this.scaleFactor - this.ptranx;\n            vertices[i].y = vertices[i].y / this.scaleFactor - this.ptrany;\n            vertices[i].z = vertices[i].z / this.scaleFactor - this.ptranz;\n        }\n        let finalfaces = [];\n        for (let i = 0, il = this.faces.length; i < il; i += 3) {\n            //let f = faces[i];\n            let fa = this.faces[i], fb = this.faces[i + 1], fc = this.faces[i + 2];\n            let a = vertices[fa].atomid, b = vertices[fb].atomid, c = vertices[fc].atomid;\n            // must be a unique face for each atom\n            let which = a;\n            if (b < which)\n                which = b;\n            if (c < which)\n                which = c;\n            if (!atomsToShow[which]) {\n                continue;\n            }\n            if (fa !== fb && fb !== fc && fa !== fc) {\n                finalfaces.push(fa);\n                finalfaces.push(fb);\n                finalfaces.push(fc);\n            }\n        }\n        //try to help the garbage collector\n        this.vpBits = null; // uint8 array of bitmasks\n        this.vpDistance = null; // floatarray\n        this.vpAtomID = null; // intarray\n        return {\n            'vertices': vertices,\n            'faces': finalfaces\n        };\n    }\n    ;\n    initparm(extent, btype, volume) {\n        if (volume > 1000000) //heuristical decrease resolution to avoid large memory consumption\n            this.scaleFactor = this.defaultScaleFactor / 2;\n        let margin = (1 / this.scaleFactor) * 5.5; // need margin to avoid\n        // boundary/round off effects\n        this.pminx = extent[0][0];\n        this.pmaxx = extent[1][0];\n        this.pminy = extent[0][1];\n        this.pmaxy = extent[1][1];\n        this.pminz = extent[0][2];\n        this.pmaxz = extent[1][2];\n        if (!btype) {\n            this.pminx -= margin;\n            this.pminy -= margin;\n            this.pminz -= margin;\n            this.pmaxx += margin;\n            this.pmaxy += margin;\n            this.pmaxz += margin;\n        }\n        else {\n            this.pminx -= this.probeRadius + margin;\n            this.pminy -= this.probeRadius + margin;\n            this.pminz -= this.probeRadius + margin;\n            this.pmaxx += this.probeRadius + margin;\n            this.pmaxy += this.probeRadius + margin;\n            this.pmaxz += this.probeRadius + margin;\n        }\n        this.pminx = Math.floor(this.pminx * this.scaleFactor) / this.scaleFactor;\n        this.pminy = Math.floor(this.pminy * this.scaleFactor) / this.scaleFactor;\n        this.pminz = Math.floor(this.pminz * this.scaleFactor) / this.scaleFactor;\n        this.pmaxx = Math.ceil(this.pmaxx * this.scaleFactor) / this.scaleFactor;\n        this.pmaxy = Math.ceil(this.pmaxy * this.scaleFactor) / this.scaleFactor;\n        this.pmaxz = Math.ceil(this.pmaxz * this.scaleFactor) / this.scaleFactor;\n        this.ptranx = -this.pminx;\n        this.ptrany = -this.pminy;\n        this.ptranz = -this.pminz;\n        this.pLength = Math.ceil(this.scaleFactor * (this.pmaxx - this.pminx)) + 1;\n        this.pWidth = Math.ceil(this.scaleFactor * (this.pmaxy - this.pminy)) + 1;\n        this.pHeight = Math.ceil(this.scaleFactor * (this.pmaxz - this.pminz)) + 1;\n        this.boundingatom(btype);\n        this.cutRadius = this.probeRadius * this.scaleFactor;\n        this.vpBits = new Uint8Array(this.pLength * this.pWidth * this.pHeight);\n        this.vpDistance = new Float64Array(this.pLength * this.pWidth * this.pHeight); // float 32\n        // doesn't\n        // play\n        // nicely\n        // with\n        // native\n        // floats\n        this.vpAtomID = new Int32Array(this.pLength * this.pWidth * this.pHeight);\n    }\n    ;\n    boundingatom(btype) {\n        let tradius = {};\n        for (const i in this.vdwRadii) {\n            let r = this.vdwRadii[i];\n            if (!btype)\n                tradius[i] = r * this.scaleFactor + 0.5;\n            else\n                tradius[i] = (r + this.probeRadius) * this.scaleFactor + 0.5;\n            let sradius = tradius[i] * tradius[i];\n            this.widxz[i] = Math.floor(tradius[i]) + 1;\n            this.depty[i] = new Int32Array(this.widxz[i] * this.widxz[i]);\n            let indx = 0;\n            for (let j = 0; j < this.widxz[i]; j++) {\n                for (let k = 0; k < this.widxz[i]; k++) {\n                    let txz = j * j + k * k;\n                    if (txz > sradius)\n                        this.depty[i][indx] = -1; // outside\n                    else {\n                        let tdept = Math.sqrt(sradius - txz);\n                        this.depty[i][indx] = Math.floor(tdept);\n                    }\n                    indx++;\n                }\n            }\n        }\n    }\n    ;\n    fillvoxels(atoms, atomlist) {\n        // seqterm,bool\n        // atomtype,atom*\n        // proseq,bool bcolor)\n        for (let i = 0, il = this.vpBits.length; i < il; i++) {\n            this.vpBits[i] = 0;\n            this.vpDistance[i] = -1.0;\n            this.vpAtomID[i] = -1;\n        }\n        for (let i in atomlist) {\n            let atom = atoms[atomlist[i]];\n            if (atom === undefined)\n                continue;\n            this.fillAtom(atom, atoms);\n        }\n        for (let i = 0, il = this.vpBits.length; i < il; i++)\n            if (this.vpBits[i] & this.INOUT)\n                this.vpBits[i] |= this.ISDONE;\n    }\n    ;\n    fillAtom(atom, atoms) {\n        let cx = Math.floor(0.5 + this.scaleFactor * (atom.x + this.ptranx));\n        let cy = Math.floor(0.5 + this.scaleFactor * (atom.y + this.ptrany));\n        let cz = Math.floor(0.5 + this.scaleFactor * (atom.z + this.ptranz));\n        let at = this.getVDWIndex(atom);\n        let nind = 0;\n        let pWH = this.pWidth * this.pHeight;\n        for (let i = 0, n = this.widxz[at]; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (this.depty[at][nind] != -1) {\n                    for (let ii = -1; ii < 2; ii++) {\n                        for (let jj = -1; jj < 2; jj++) {\n                            for (let kk = -1; kk < 2; kk++) {\n                                if (ii !== 0 && jj !== 0 && kk !== 0) {\n                                    let mi = ii * i;\n                                    let mk = kk * j;\n                                    for (let k = 0; k <= this.depty[at][nind]; k++) {\n                                        let mj = k * jj;\n                                        let si = cx + mi;\n                                        let sj = cy + mj;\n                                        let sk = cz + mk;\n                                        if (si < 0 || sj < 0 ||\n                                            sk < 0 ||\n                                            si >= this.pLength ||\n                                            sj >= this.pWidth ||\n                                            sk >= this.pHeight)\n                                            continue;\n                                        let index = si * pWH + sj * this.pHeight + sk;\n                                        if (!(this.vpBits[index] & this.INOUT)) {\n                                            this.vpBits[index] |= this.INOUT;\n                                            this.vpAtomID[index] = atom.serial;\n                                        }\n                                        else {\n                                            let atom2 = atoms[this.vpAtomID[index]];\n                                            if (atom2.serial != atom.serial) {\n                                                let ox = cx + mi - Math.floor(0.5 + this.scaleFactor *\n                                                    (atom2.x + this.ptranx));\n                                                let oy = cy + mj - Math.floor(0.5 + this.scaleFactor *\n                                                    (atom2.y + this.ptrany));\n                                                let oz = cz + mk - Math.floor(0.5 + this.scaleFactor *\n                                                    (atom2.z + this.ptranz));\n                                                if (mi * mi + mj * mj + mk * mk < ox *\n                                                    ox + oy * oy + oz * oz)\n                                                    this.vpAtomID[index] = atom.serial;\n                                            }\n                                        }\n                                    } // k\n                                } // if\n                            } // kk\n                        } // jj\n                    } // ii\n                } // if\n                nind++;\n            } // j\n        } // i\n    }\n    ;\n    fillvoxelswaals(atoms, atomlist) {\n        for (let i = 0, il = this.vpBits.length; i < il; i++)\n            this.vpBits[i] &= ~this.ISDONE; // not isdone\n        for (let i in atomlist) {\n            let atom = atoms[atomlist[i]];\n            if (atom === undefined)\n                continue;\n            this.fillAtomWaals(atom, atoms);\n        }\n    }\n    ;\n    fillAtomWaals(atom, atoms) {\n        let nind = 0;\n        let cx = Math.floor(0.5 + this.scaleFactor * (atom.x + this.ptranx));\n        let cy = Math.floor(0.5 + this.scaleFactor * (atom.y + this.ptrany));\n        let cz = Math.floor(0.5 + this.scaleFactor * (atom.z + this.ptranz));\n        let at = this.getVDWIndex(atom);\n        let pWH = this.pWidth * this.pHeight;\n        for (let i = 0, n = this.widxz[at]; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (this.depty[at][nind] != -1) {\n                    for (let ii = -1; ii < 2; ii++) {\n                        for (let jj = -1; jj < 2; jj++) {\n                            for (let kk = -1; kk < 2; kk++) {\n                                if (ii !== 0 && jj !== 0 && kk !== 0) {\n                                    let mi = ii * i;\n                                    let mk = kk * j;\n                                    for (let k = 0; k <= this.depty[at][nind]; k++) {\n                                        let mj = k * jj;\n                                        let si = cx + mi;\n                                        let sj = cy + mj;\n                                        let sk = cz + mk;\n                                        if (si < 0 || sj < 0 ||\n                                            sk < 0 ||\n                                            si >= this.pLength ||\n                                            sj >= this.pWidth ||\n                                            sk >= this.pHeight)\n                                            continue;\n                                        let index = si * pWH + sj * this.pHeight + sk;\n                                        if (!(this.vpBits[index] & this.ISDONE)) {\n                                            this.vpBits[index] |= this.ISDONE;\n                                            this.vpAtomID[index] = atom.serial;\n                                        }\n                                        else {\n                                            let atom2 = atoms[this.vpAtomID[index]];\n                                            if (atom2.serial != atom.serial) {\n                                                let ox = cx + mi - Math.floor(0.5 + this.scaleFactor *\n                                                    (atom2.x + this.ptranx));\n                                                let oy = cy + mj - Math.floor(0.5 + this.scaleFactor *\n                                                    (atom2.y + this.ptrany));\n                                                let oz = cz + mk - Math.floor(0.5 + this.scaleFactor *\n                                                    (atom2.z + this.ptranz));\n                                                if (mi * mi + mj * mj + mk * mk < ox *\n                                                    ox + oy * oy + oz * oz)\n                                                    this.vpAtomID[index] = atom.serial;\n                                            }\n                                        }\n                                    } // k\n                                } // if\n                            } // kk\n                        } // jj\n                    } // ii\n                } // if\n                nind++;\n            } // j\n        } // i\n    }\n    ;\n    buildboundary() {\n        let pWH = this.pWidth * this.pHeight;\n        for (let i = 0; i < this.pLength; i++) {\n            for (let j = 0; j < this.pHeight; j++) {\n                for (let k = 0; k < this.pWidth; k++) {\n                    let index = i * pWH + k * this.pHeight + j;\n                    if (this.vpBits[index] & this.INOUT) {\n                        let ii = 0;\n                        while (ii < 26) {\n                            let ti = i + this.nb[ii][0], tj = j + this.nb[ii][2], tk = k +\n                                this.nb[ii][1];\n                            if (ti > -1 &&\n                                ti < this.pLength &&\n                                tk > -1 &&\n                                tk < this.pWidth &&\n                                tj > -1 &&\n                                tj < this.pHeight &&\n                                !(this.vpBits[ti * pWH + tk * this.pHeight + tj] & this.INOUT)) {\n                                this.vpBits[index] |= this.ISBOUND;\n                                break;\n                            }\n                            else\n                                ii++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ;\n    fastdistancemap() {\n        let boundPoint = new PointGrid(this.pLength, this.pWidth, this.pHeight);\n        let pWH = this.pWidth * this.pHeight;\n        let cutRSq = this.cutRadius * this.cutRadius;\n        let inarray = [];\n        let outarray = [];\n        let index;\n        for (let i = 0; i < this.pLength; i++) {\n            for (let j = 0; j < this.pWidth; j++) {\n                for (let k = 0; k < this.pHeight; k++) {\n                    index = i * pWH + j * this.pHeight + k;\n                    this.vpBits[index] &= ~this.ISDONE; // isdone = false\n                    if (this.vpBits[index] & this.INOUT) {\n                        if (this.vpBits[index] & this.ISBOUND) {\n                            let triple = {\n                                ix: i,\n                                iy: j,\n                                iz: k\n                            };\n                            boundPoint.set(i, j, k, triple);\n                            inarray.push(triple);\n                            this.vpDistance[index] = 0;\n                            this.vpBits[index] |= this.ISDONE;\n                            this.vpBits[index] &= ~this.ISBOUND;\n                        }\n                    }\n                }\n            }\n        }\n        do {\n            outarray = this.fastoneshell(inarray, boundPoint);\n            inarray = [];\n            for (let i = 0, n = outarray.length; i < n; i++) {\n                index = pWH * outarray[i].ix + this.pHeight *\n                    outarray[i].iy + outarray[i].iz;\n                this.vpBits[index] &= ~this.ISBOUND;\n                if (this.vpDistance[index] <= 1.0404 * cutRSq) {\n                    inarray.push({\n                        ix: outarray[i].ix,\n                        iy: outarray[i].iy,\n                        iz: outarray[i].iz\n                    });\n                }\n            }\n        } while (inarray.length !== 0);\n        inarray = [];\n        outarray = [];\n        boundPoint = null;\n        let cutsf = this.scaleFactor - 0.5;\n        if (cutsf < 0)\n            cutsf = 0;\n        let cutoff = cutRSq - 0.50 / (0.1 + cutsf);\n        for (let i = 0; i < this.pLength; i++) {\n            for (let j = 0; j < this.pWidth; j++) {\n                for (let k = 0; k < this.pHeight; k++) {\n                    index = i * pWH + j * this.pHeight + k;\n                    this.vpBits[index] &= ~this.ISBOUND;\n                    // ses solid\n                    if (this.vpBits[index] & this.INOUT) {\n                        if (!(this.vpBits[index] & this.ISDONE) ||\n                            ((this.vpBits[index] & this.ISDONE) && this.vpDistance[index] >= cutoff)) {\n                            this.vpBits[index] |= this.ISBOUND;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ;\n    fastoneshell(inarray, boundPoint) {\n        // *allocout,voxel2\n        // ***boundPoint, int*\n        // outnum, int *elimi)\n        let tx, ty, tz;\n        let dx, dy, dz;\n        let square;\n        let bp, index;\n        let outarray = [];\n        if (inarray.length === 0)\n            return outarray;\n        let tnv = {\n            ix: -1,\n            iy: -1,\n            iz: -1\n        };\n        let pWH = this.pWidth * this.pHeight;\n        for (let i = 0, n = inarray.length; i < n; i++) {\n            tx = inarray[i].ix;\n            ty = inarray[i].iy;\n            tz = inarray[i].iz;\n            bp = boundPoint.get(tx, ty, tz);\n            for (let j = 0; j < 6; j++) {\n                tnv.ix = tx + this.nb[j][0];\n                tnv.iy = ty + this.nb[j][1];\n                tnv.iz = tz + this.nb[j][2];\n                if (tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&\n                    tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {\n                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;\n                    if ((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {\n                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        this.vpDistance[index] = square;\n                        this.vpBits[index] |= this.ISDONE;\n                        this.vpBits[index] |= this.ISBOUND;\n                        outarray.push({\n                            ix: tnv.ix,\n                            iy: tnv.iy,\n                            iz: tnv.iz\n                        });\n                    }\n                    else if ((this.vpBits[index] & this.INOUT) && (this.vpBits[index] & this.ISDONE)) {\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        if (square < this.vpDistance[index]) {\n                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);\n                            this.vpDistance[index] = square;\n                            if (!(this.vpBits[index] & this.ISBOUND)) {\n                                this.vpBits[index] |= this.ISBOUND;\n                                outarray.push({\n                                    ix: tnv.ix,\n                                    iy: tnv.iy,\n                                    iz: tnv.iz\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (let i = 0, n = inarray.length; i < n; i++) {\n            tx = inarray[i].ix;\n            ty = inarray[i].iy;\n            tz = inarray[i].iz;\n            bp = boundPoint.get(tx, ty, tz);\n            for (let j = 6; j < 18; j++) {\n                tnv.ix = tx + this.nb[j][0];\n                tnv.iy = ty + this.nb[j][1];\n                tnv.iz = tz + this.nb[j][2];\n                if (tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&\n                    tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {\n                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;\n                    if ((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {\n                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        this.vpDistance[index] = square;\n                        this.vpBits[index] |= this.ISDONE;\n                        this.vpBits[index] |= this.ISBOUND;\n                        outarray.push({\n                            ix: tnv.ix,\n                            iy: tnv.iy,\n                            iz: tnv.iz\n                        });\n                    }\n                    else if ((this.vpBits[index] & this.INOUT) && (this.vpBits[index] & this.ISDONE)) {\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        if (square < this.vpDistance[index]) {\n                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);\n                            this.vpDistance[index] = square;\n                            if (!(this.vpBits[index] & this.ISBOUND)) {\n                                this.vpBits[index] |= this.ISBOUND;\n                                outarray.push({\n                                    ix: tnv.ix,\n                                    iy: tnv.iy,\n                                    iz: tnv.iz\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (let i = 0, n = inarray.length; i < n; i++) {\n            tx = inarray[i].ix;\n            ty = inarray[i].iy;\n            tz = inarray[i].iz;\n            bp = boundPoint.get(tx, ty, tz);\n            for (let j = 18; j < 26; j++) {\n                tnv.ix = tx + this.nb[j][0];\n                tnv.iy = ty + this.nb[j][1];\n                tnv.iz = tz + this.nb[j][2];\n                if (tnv.ix < this.pLength && tnv.ix > -1 && tnv.iy < this.pWidth &&\n                    tnv.iy > -1 && tnv.iz < this.pHeight && tnv.iz > -1) {\n                    index = tnv.ix * pWH + this.pHeight * tnv.iy + tnv.iz;\n                    if ((this.vpBits[index] & this.INOUT) && !(this.vpBits[index] & this.ISDONE)) {\n                        boundPoint.set(tnv.ix, tnv.iy, tz + this.nb[j][2], bp);\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        this.vpDistance[index] = square;\n                        this.vpBits[index] |= this.ISDONE;\n                        this.vpBits[index] |= this.ISBOUND;\n                        outarray.push({\n                            ix: tnv.ix,\n                            iy: tnv.iy,\n                            iz: tnv.iz\n                        });\n                    }\n                    else if ((this.vpBits[index] & this.INOUT) && (this.vpBits[index] & this.ISDONE)) {\n                        dx = tnv.ix - bp.ix;\n                        dy = tnv.iy - bp.iy;\n                        dz = tnv.iz - bp.iz;\n                        square = dx * dx + dy * dy + dz * dz;\n                        if (square < this.vpDistance[index]) {\n                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);\n                            this.vpDistance[index] = square;\n                            if (!(this.vpBits[index] & this.ISBOUND)) {\n                                this.vpBits[index] |= this.ISBOUND;\n                                outarray.push({\n                                    ix: tnv.ix,\n                                    iy: tnv.iy,\n                                    iz: tnv.iz\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return outarray;\n    }\n    ;\n    marchingcubeinit(stype) {\n        for (let i = 0, lim = this.vpBits.length; i < lim; i++) {\n            if (stype == 1) { // vdw\n                this.vpBits[i] &= ~this.ISBOUND;\n            }\n            else if (stype == 4) { // ses\n                this.vpBits[i] &= ~this.ISDONE;\n                if (this.vpBits[i] & this.ISBOUND)\n                    this.vpBits[i] |= this.ISDONE;\n                this.vpBits[i] &= ~this.ISBOUND;\n            }\n            else if (stype == 2) { // after vdw\n                if ((this.vpBits[i] & this.ISBOUND) && (this.vpBits[i] & this.ISDONE))\n                    this.vpBits[i] &= ~this.ISBOUND;\n                else if ((this.vpBits[i] & this.ISBOUND) && !(this.vpBits[i] & this.ISDONE))\n                    this.vpBits[i] |= this.ISDONE;\n            }\n            else if (stype == 3) { // sas\n                this.vpBits[i] &= ~this.ISBOUND;\n            }\n        }\n    }\n    ;\n    marchingcube(stype) {\n        this.marchingcubeinit(stype);\n        this.verts = [];\n        this.faces = [];\n        ProteinSurface.MarchingCube.march(this.vpBits, this.verts, this.faces, {\n            smooth: 1,\n            nX: this.pLength,\n            nY: this.pWidth,\n            nZ: this.pHeight\n        });\n        let pWH = this.pWidth * this.pHeight;\n        for (let i = 0, vlen = this.verts.length; i < vlen; i++) {\n            this.verts[i].atomid = this.vpAtomID[this.verts[i].x * pWH + this.pHeight *\n                this.verts[i].y + this.verts[i].z];\n        }\n        ProteinSurface.MarchingCube.laplacianSmooth(1, this.verts, this.faces);\n    }\n    ;\n}\nProteinSurface.MarchingCube = new MarchingCubeInitializer();\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/ProteinSurface4.ts?");

/***/ }),

/***/ "./src/VolumeData.ts":
/*!***************************!*\
  !*** ./src/VolumeData.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VolumeData: () => (/* binding */ VolumeData)\n/* harmony export */ });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.ts\");\n/* harmony import */ var _WebGL_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGL/math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _parsers_VASP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parsers/VASP */ \"./src/parsers/VASP.ts\");\n/* harmony import */ var _parsers_CUBE__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parsers/CUBE */ \"./src/parsers/CUBE.ts\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! pako */ \"./node_modules/pako/dist/pako.esm.mjs\");\n\n\n\n\n\n;\n/**\n * $3Dmol.VolumeData stores volumetric data. This includes file parsing\n * functionality.\n *\n * @class\n * @param {string} str - volumetric data\n * @param {string} format - format of supplied data (cube, dx, vasp); append .gz if compressed\n * @param {Object} options - normalize (zero mean, unit variance), negate\n */\nclass VolumeData {\n    constructor(str, format, options) {\n        this.unit = {\n            x: 1,\n            y: 1,\n            z: 1\n        }; // scale of each voxel\n        this.origin = {\n            x: 0,\n            y: 0,\n            z: 0\n        }; // origin (bottom \"left\", not center)\n        this.size = {\n            x: 0,\n            y: 0,\n            z: 0\n        }; // number of voxels in each direction\n        this.data = new Float32Array([]); // actual floating point data, arranged\n        // x->y->z\n        this.matrix = null; //if set must transform data\n        this.inversematrix = null;\n        this.isbinary = new Set(['ccp4', 'CCP4']);\n        this.getCoordinates = function (index) {\n            var x = index / (this.size.y * this.size.z);\n            var y = index % (this.size.y * this.size.z);\n            var z = index % this.size.z;\n            x *= this.unit.x;\n            y *= this.unit.y;\n            z *= this.unit.z;\n            x += this.origin.x;\n            y += this.origin.y;\n            z += this.origin.z;\n            return { x: x, y: y, z: z };\n        };\n        /*\n         * parse vasp data\n         * Essentially this parser converts the CHGCAR data into\n         * cube data. It has been adapted from 'chg2cube.pl' found in\n         * http://theory.cm.utexas.edu/vtsttools/\n         */\n        this.vasp = function (str) {\n            var lines = str.replace(/^\\s+/, \"\").split(/[\\n\\r]/);\n            var atomicData = (0,_parsers_VASP__WEBPACK_IMPORTED_MODULE_2__.VASP)(str)[0];\n            var natoms = atomicData.length;\n            if (natoms == 0) {\n                console.log(\"No good formating of CHG or CHGCAR file, not atomic information provided in the file.\");\n                this.data = [];\n                return;\n            }\n            // Assume atomic units\n            //    var unittype = \"bohr/hartree\";\n            var l_units = 1.889725992;\n            var e_units = 0.036749309;\n            // copied from $3Dmol.Parsers.vasp\n            var convFactor = parseFloat(lines[1]);\n            // This is how Vasp reads in the basis We need the l_units in order to\n            // compute the volume of the cell. Afterwards to obtain the axis for the\n            // voxels we have to remove this unit and divide by the number of voxels in\n            // each dimension\n            var v;\n            v = lines[2].replace(/^\\s+/, \"\").split(/\\s+/);\n            var xVec = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);\n            v = lines[3].replace(/^\\s+/, \"\").split(/\\s+/);\n            var yVec = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);\n            v = lines[4].replace(/^\\s+/, \"\").split(/\\s+/);\n            var zVec = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2])).multiplyScalar(convFactor * l_units);\n            // correct volume for non-orthognal box (expansion by minors)\n            var vol = xVec.x * (yVec.y * zVec.z - zVec.y * yVec.z) - yVec.x * (xVec.y * zVec.z - zVec.y * xVec.z) + zVec.x * (xVec.y * yVec.z - yVec.y * xVec.z);\n            vol = Math.abs(vol) / (Math.pow(l_units, 3));\n            var vol_scale = 1.0 / (vol); //This Only for CHGCAR files\n            // We splice the structure information\n            // 2 (header) + 3 (vectors) + 2 (atoms) + 1 (vaspMode) + natoms (coords) + 1 (blank line)\n            lines.splice(0, 2 + 3 + 2 + 1 + natoms + 1);\n            var lineArr = lines[0].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n            var nX = Math.abs(parseFloat(lineArr[0]));\n            var nY = Math.abs(parseFloat(lineArr[1]));\n            var nZ = Math.abs(parseFloat(lineArr[2]));\n            var origin = this.origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n            this.size = { x: nX, y: nY, z: nZ };\n            this.unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(xVec.x, yVec.y, zVec.z);\n            // resize the vectors accordingly\n            xVec = xVec.multiplyScalar(1 / (l_units * nX));\n            yVec = yVec.multiplyScalar(1 / (l_units * nY));\n            zVec = zVec.multiplyScalar(1 / (l_units * nZ));\n            if (xVec.y != 0 || xVec.z != 0 || yVec.x != 0 || yVec.z != 0 || zVec.x != 0\n                || zVec.y != 0) {\n                //need a transformation matrix\n                this.matrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4(xVec.x, yVec.x, zVec.x, 0, xVec.y, yVec.y, zVec.y, 0, xVec.z, yVec.z, zVec.z, 0, 0, 0, 0, 1);\n                //include translation in matrix\n                this.matrix = this.matrix.multiplyMatrices(this.matrix, new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().makeTranslation(origin.x, origin.y, origin.z));\n                //all translation and scaling done by matrix, so reset origin and unit\n                this.origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n                this.unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);\n            }\n            lines.splice(0, 1); // Remove the dimension line\n            var raw = lines.join(\" \");\n            raw = raw.replace(/^\\s+/, '');\n            var rawArray = raw.split(/[\\s\\r]+/);\n            rawArray.splice(nX * nY * nZ + 1);\n            var preConvertedData = Float32Array.from(rawArray, parseFloat); //We still have to format it to get the density\n            for (var i = 0; i < preConvertedData.length; i++) {\n                preConvertedData[i] = preConvertedData[i] * vol_scale * e_units;\n            }\n            this.data = preConvertedData;\n            //console.log(xVec);\n            //console.log(yVec);\n            //console.log(zVec);\n            //console.log(this.unit);\n            //console.log(this.origin);\n            //console.log(this.matrix);\n            //console.log(this.data);\n        };\n        // parse dx data - does not support all features of the file format\n        this.dx = function (str) {\n            var lines = str.split(/[\\n\\r]+/);\n            var m;\n            var recounts = /gridpositions\\s+counts\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)/;\n            var reorig = /^origin\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/;\n            var redelta = /^delta\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)/;\n            var follows = /data follows/;\n            var i = 0;\n            for (i = 0; i < lines.length; i++) {\n                var line = lines[i];\n                if ((m = recounts.exec(line))) {\n                    var nX = parseInt(m[1]);\n                    var nY = parseInt(m[2]);\n                    var nZ = parseInt(m[3]);\n                    this.size = { x: nX, y: nY, z: nZ };\n                }\n                else if ((m = redelta.exec(line))) {\n                    var xunit = parseFloat(m[1]);\n                    if (parseFloat(m[2]) != 0 || parseFloat(m[3]) != 0) {\n                        console.log(\"Non-orthogonal delta matrix not currently supported in dx format\");\n                    }\n                    i += 1;\n                    line = lines[i];\n                    m = redelta.exec(line);\n                    if (m == null) {\n                        console.log(\"Parse error in dx delta matrix\");\n                        return;\n                    }\n                    var yunit = parseFloat(m[2]);\n                    if (parseFloat(m[1]) != 0 || parseFloat(m[3]) != 0) {\n                        console.log(\"Non-orthogonal delta matrix not currently supported in dx format\");\n                    }\n                    i += 1;\n                    line = lines[i];\n                    m = redelta.exec(line);\n                    if (m == null) {\n                        console.log(\"Parse error in dx delta matrix\");\n                        return;\n                    }\n                    var zunit = parseFloat(m[3]);\n                    if (parseFloat(m[1]) != 0 || parseFloat(m[2]) != 0) {\n                        console.log(\"Non-orthogonal delta matrix not currently supported in dx format\");\n                    }\n                    this.unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(xunit, yunit, zunit);\n                }\n                else if ((m = reorig.exec(line))) {\n                    var xorig = parseFloat(m[1]);\n                    var yorig = parseFloat(m[2]);\n                    var zorig = parseFloat(m[3]);\n                    this.origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(xorig, yorig, zorig);\n                }\n                else if ((m = follows.exec(line))) {\n                    break;\n                }\n            }\n            i += 1;\n            if (!this.size || !this.origin || !this.unit || !this.size) {\n                console.log(\"Error parsing dx format\");\n                return;\n            }\n            var raw = lines.splice(i).join(\" \");\n            var rawArray = raw.split(/[\\s\\r]+/);\n            this.data = Float32Array.from(rawArray, parseFloat);\n        };\n        format = format.toLowerCase();\n        if (/\\.gz$/.test(format)) {\n            //unzip gzipped files\n            format = format.replace(/\\.gz$/, '');\n            try {\n                if (this[format] && this.isbinary.has(format)) {\n                    if (typeof (str) == \"string\") {\n                        //assume base64 encoded\n                        str = (0,_utilities__WEBPACK_IMPORTED_MODULE_0__.base64ToArray)(str);\n                    }\n                    str = (0,pako__WEBPACK_IMPORTED_MODULE_4__.inflate)(str);\n                }\n                else {\n                    str = new TextDecoder(\"utf-8\").decode((0,pako__WEBPACK_IMPORTED_MODULE_4__.inflate)(str));\n                }\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        if (this[format]) {\n            if (this.isbinary.has(format) && typeof (str) == \"string\") {\n                str = (0,_utilities__WEBPACK_IMPORTED_MODULE_0__.base64ToArray)(str);\n            }\n            this[format](str);\n        }\n        if (options) {\n            if (options.negate) {\n                for (let i = 0, n = this.data.length; i < n; i++) {\n                    this.data[i] = -this.data[i];\n                }\n            }\n            if (options.normalize) {\n                var total = 0.0;\n                for (let i = 0, n = this.data.length; i < n; i++) {\n                    total += this.data[i];\n                }\n                var mean = total / this.data.length;\n                total = 0;\n                for (let i = 0, n = this.data.length; i < n; i++) {\n                    var diff = this.data[i] - mean;\n                    total += diff * diff; //variance is ave of squared difference with mean\n                }\n                var variance = total / this.data.length;\n                //console.log(\"Computed variance: \"+variance);\n                //now normalize\n                for (let i = 0, n = this.data.length; i < n; i++) {\n                    this.data[i] = (this.data[i] - mean) / variance;\n                }\n            }\n        }\n    }\n    /**\n     * @function $3Dmol.VolumeData.getIndex\n     * @param {number} x,y,z - the coordinates\n     * @returns - index into flat array closest to provided coordinate; -1 if invalid\n     */\n    getIndex(x, y, z) {\n        if (this.matrix) {\n            //all transformation is done through matrix multiply\n            if (this.inversematrix == null) {\n                this.inversematrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().getInverse(this.matrix);\n            }\n            var pt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(x, y, z);\n            pt = pt.applyMatrix4(this.inversematrix);\n            x = pt.x;\n            y = pt.y;\n            z = pt.z;\n        }\n        else { //use simple origin/unit transform\n            x -= this.origin.x;\n            y -= this.origin.y;\n            z -= this.origin.z;\n            x /= this.unit.x;\n            y /= this.unit.y;\n            z /= this.unit.z;\n        }\n        x = Math.round(x);\n        y = Math.round(y);\n        z = Math.round(z);\n        if (x < 0 || x >= this.size.x)\n            return -1;\n        if (y < 0 || y >= this.size.y)\n            return -1;\n        if (z < 0 || z >= this.size.z)\n            return -1;\n        return x * this.size.y * this.size.z + y * this.size.z + z;\n    }\n    ;\n    /**\n     * @function $3Dmol.VolumeData.getVal\n     * @param {number} x,y,z - the coordinates\n     * @returns - value closest to provided coordinate; zero if coordinate invalid\n     */\n    getVal(x, y, z) {\n        let i = this.getIndex(x, y, z);\n        if (i < 0)\n            return 0;\n        return this.data[i];\n    }\n    ;\n    // parse cube data\n    cube(str) {\n        var lines = str.split(/\\r?\\n/);\n        if (lines.length < 6)\n            return;\n        var cryst = (0,_parsers_CUBE__WEBPACK_IMPORTED_MODULE_3__.CUBE)(str, {}).modelData[0].cryst;\n        var lineArr = lines[2].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n        var atomsnum = parseFloat(lineArr[0]); //includes sign, which indicates presence of oribital line in header\n        var natoms = Math.abs(atomsnum);\n        this.origin = cryst.origin;\n        this.size = cryst.size;\n        this.unit = cryst.unit;\n        this.matrix = cryst.matrix4;\n        var headerlines = 6;\n        if (atomsnum < 0)\n            headerlines++; //see: http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/cubeplugin.html\n        var raw = lines.splice(natoms + headerlines).join(\" \");\n        raw = raw.replace(/^\\s+/, '');\n        var rawArray = raw.split(/[\\s\\r]+/);\n        this.data = Float32Array.from(rawArray, parseFloat);\n    }\n    ;\n    //parse cp4 files\n    ccp4(bin) {\n        // http://www.ccp4.ac.uk/html/maplib.html#description\n        //code from ngl: https://github.com/arose/ngl/blob/master/js/ngl/parser.js\n        var header = {};\n        bin = new Int8Array(bin);\n        var intView = new Int32Array(bin.buffer, 0, 56);\n        var floatView = new Float32Array(bin.buffer, 0, 56);\n        var dv = new DataView(bin.buffer);\n        // 53  MAP         Character string 'MAP ' to identify file type\n        header.MAP = String.fromCharCode(dv.getUint8(52 * 4), dv.getUint8(52 * 4 + 1), dv.getUint8(52 * 4 + 2), dv.getUint8(52 * 4 + 3));\n        // 54  MACHST      Machine stamp indicating machine type which wrote file\n        //                 17 and 17 for big-endian or 68 and 65 for little-endian\n        header.MACHST = [dv.getUint8(53 * 4), dv.getUint8(53 * 4 + 1)];\n        // swap byte order when big endian\n        if (header.MACHST[0] === 17 && header.MACHST[1] === 17) {\n            var n = bin.byteLength;\n            for (var i = 0; i < n; i += 4) {\n                dv.setFloat32(i, dv.getFloat32(i), true);\n            }\n        }\n        header.NX = intView[0]; // NC - columns (fastest changing)\n        header.NY = intView[1]; // NR - rows\n        header.NZ = intView[2]; // NS - sections (slowest changing)\n        // mode\n        //  0 image : signed 8-bit bytes range -128 to 127\n        //  1 image : 16-bit halfwords\n        //  2 image : 32-bit reals\n        //  3 transform : complex 16-bit integers\n        //  4 transform : complex 32-bit reals\n        //  6 image : unsigned 16-bit range 0 to 65535\n        // 16 image: unsigned char * 3 (for rgb data, non-standard)\n        //\n        // Note: Mode 2 is the normal mode used in the CCP4 programs.\n        //       Other modes than 2 and 0 may NOT WORK\n        header.MODE = intView[3];\n        // start\n        header.NXSTART = intView[4]; // NCSTART - first column\n        header.NYSTART = intView[5]; // NRSTART - first row\n        header.NZSTART = intView[6]; // NSSTART - first section\n        // intervals\n        header.MX = intView[7]; // intervals along x\n        header.MY = intView[8]; // intervals along y\n        header.MZ = intView[9]; // intervals along z\n        // cell length (Angstroms in CCP4)\n        header.xlen = floatView[10];\n        header.ylen = floatView[11];\n        header.zlen = floatView[12];\n        // cell angle (Degrees)\n        header.alpha = floatView[13];\n        header.beta = floatView[14];\n        header.gamma = floatView[15];\n        // axis correspondence (1,2,3 for X,Y,Z)\n        header.MAPC = intView[16]; // column\n        header.MAPR = intView[17]; // row\n        header.MAPS = intView[18]; // section\n        // density statistics\n        header.DMIN = floatView[19];\n        header.DMAX = floatView[20];\n        header.DMEAN = floatView[21];\n        // space group number 0 or 1 (default=0)\n        header.ISPG = intView[22];\n        // number of bytes used for symmetry data (0 or 80)\n        header.NSYMBT = intView[23];\n        // Flag for skew transformation, =0 none, =1 if foll\n        header.LSKFLG = intView[24];\n        // 26-34  SKWMAT  Skew matrix S (in order S11, S12, S13, S21 etc) if\n        //                LSKFLG .ne. 0.\n        // 35-37  SKWTRN  Skew translation t if LSKFLG != 0.\n        //                Skew transformation is from standard orthogonal\n        //                coordinate frame (as used for atoms) to orthogonal\n        //                map frame, as Xo(map) = S * (Xo(atoms) - t)\n        // 38      future use       (some of these are used by the MSUBSX routines\n        //  .          \"              in MAPBRICK, MAPCONT and FRODO)\n        //  .          \"   (all set to zero by default)\n        //  .          \"\n        // 52          \"\n        // 50-52 origin in X,Y,Z used for transforms\n        header.originX = floatView[49];\n        header.originY = floatView[50];\n        header.originZ = floatView[51];\n        // 53  MAP         Character string 'MAP ' to identify file type\n        // => see top of this parser\n        // 54  MACHST      Machine stamp indicating machine type which wrote file\n        // => see top of this parser\n        // Rms deviation of map from mean density\n        header.ARMS = floatView[54];\n        // 56      NLABL           Number of labels being used\n        // 57-256  LABEL(20,10)    10  80 character text labels (ie. A4 format)\n        //console.log(\"Map has min,mean,average,rmsddv: \"+header.DMIN+\",\"+header.DMAX+\",\"+header.DMEAN+\",\"+header.ARMS);\n        //create transformation matrix, code mostly copied from ngl\n        var h = header;\n        var basisX = [\n            h.xlen,\n            0,\n            0\n        ];\n        var basisY = [\n            h.ylen * Math.cos(Math.PI / 180.0 * h.gamma),\n            h.ylen * Math.sin(Math.PI / 180.0 * h.gamma),\n            0\n        ];\n        var basisZ = [\n            h.zlen * Math.cos(Math.PI / 180.0 * h.beta),\n            h.zlen * (Math.cos(Math.PI / 180.0 * h.alpha)\n                - Math.cos(Math.PI / 180.0 * h.gamma)\n                    * Math.cos(Math.PI / 180.0 * h.beta)) / Math.sin(Math.PI / 180.0 * h.gamma),\n            0\n        ];\n        basisZ[2] = Math.sqrt(h.zlen * h.zlen * Math.sin(Math.PI / 180.0 * h.beta) *\n            Math.sin(Math.PI / 180.0 * h.beta) - basisZ[1] * basisZ[1]);\n        var basis = [0, basisX, basisY, basisZ];\n        var nxyz = [0, h.MX, h.MY, h.MZ];\n        var mapcrs = [0, h.MAPC, h.MAPR, h.MAPS];\n        this.matrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4();\n        this.matrix.set(basis[mapcrs[1]][0] / nxyz[mapcrs[1]], basis[mapcrs[2]][0] / nxyz[mapcrs[2]], basis[mapcrs[3]][0] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][1] / nxyz[mapcrs[1]], basis[mapcrs[2]][1] / nxyz[mapcrs[2]], basis[mapcrs[3]][1] / nxyz[mapcrs[3]], 0, basis[mapcrs[1]][2] / nxyz[mapcrs[1]], basis[mapcrs[2]][2] / nxyz[mapcrs[2]], basis[mapcrs[3]][2] / nxyz[mapcrs[3]], 0, 0, 0, 0, 1);\n        //include translation in matrix, NXSTART etc are an offset in grid space\n        this.matrix = this.matrix.multiplyMatrices(this.matrix, new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().makeTranslation(h.NXSTART + h.originX, h.NYSTART + h.originY, h.NZSTART + h.originZ));\n        //all translation and scaling done by matrix, so reset origin and unit\n        this.origin = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n        this.unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);\n        this.size = { x: header.NX, y: header.NY, z: header.NZ };\n        this.dimensionorder = [header.MAPC, header.MAPR, header.MAPS];\n        var data = new Float32Array(bin.buffer, 1024 + header.NSYMBT);\n        //data must by (slowest changing) x,y,z (fastest changing)\n        var NX = header.NX, NY = header.NY, NZ = header.NZ;\n        this.data = new Float32Array(NX * NY * NZ);\n        for (let i = 0; i < NX; i++) {\n            for (let j = 0; j < NY; j++) {\n                for (let k = 0; k < NZ; k++) {\n                    //should I be concerned that I'm not using mapc?\n                    this.data[((i * NY) + j) * NZ + k] = data[((k * NY) + j) * NX + i];\n                }\n            }\n        }\n    }\n    ;\n}\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/VolumeData.ts?");

/***/ }),

/***/ "./src/VolumetricRender.ts":
/*!*********************************!*\
  !*** ./src/VolumetricRender.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLVolumetricRender: () => (/* binding */ GLVolumetricRender)\n/* harmony export */ });\n/* harmony import */ var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGL/shapes */ \"./src/WebGL/shapes/index.ts\");\n/* harmony import */ var _WebGL_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGL/math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _GLShape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GLShape */ \"./src/GLShape.ts\");\n\n\n\n\n\n;\n/**\n * A GLVolumetricRender is a \"shape\" for representing volumetric data as a density distribution.\n *\n * @class\n *\n * @param {VolumeData} data - volumetric data\n * @param {VolumetricRenderSpec} spec - specification of volumetric render\n * @returns {$3Dmol.GLShape}\n */\nclass GLVolumetricRender {\n    static interpolateArray(data, fitCount) {\n        function linearInterpolate(before, after, atPoint) {\n            return before + (after - before) * atPoint;\n        }\n        var newData = [];\n        var springFactor = (data.length - 1) / (fitCount - 1);\n        newData[0] = data[0]; // for new allocation\n        for (var i = 1; i < fitCount - 1; i++) {\n            var tmp = i * springFactor;\n            var before = Math.floor(tmp);\n            var after = Math.ceil(tmp);\n            var atPoint = tmp - before;\n            newData[i] = linearInterpolate(data[before], data[after], atPoint);\n        }\n        newData[fitCount - 1] = data[data.length - 1]; // for new allocation\n        return newData;\n    }\n    constructor(data, spec, viewer) {\n        this.hidden = false;\n        this.boundingSphere = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.renderedShapeObj = null;\n        this.shapeObj = null;\n        this.subsamples = 5.0;\n        this.data = null;\n        this.transferfunctionbuffer = [];\n        this.min = 0;\n        this.max = 0;\n        spec = spec || {};\n        var transferfn = Object.assign([], spec.transferfn);\n        this.subsamples = spec.subsamples || 5.0;\n        let TRANSFER_BUFFER_SIZE = 256;\n        // arrange points based on position property\n        transferfn.forEach(function (a) { a.value = parseFloat(a.value); });\n        transferfn.sort(function (a, b) { return a.value - b.value; });\n        this.min = transferfn[0].value;\n        if (transferfn.length == 0)\n            transferfn.push(transferfn[0]); //need at least two\n        this.max = transferfn[transferfn.length - 1].value;\n        // create and fill an array of interpolated values per 2 colors\n        var pos1, pos2, color1, color2, R, G, B, A, alpha1, alpha2;\n        for (let i = 0; i < transferfn.length - 1; i++) {\n            color1 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(transferfn[i].color);\n            color2 = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(transferfn[i + 1].color);\n            alpha1 = transferfn[i].opacity;\n            alpha2 = transferfn[i + 1].opacity;\n            pos1 = Math.floor((transferfn[i].value - this.min) * TRANSFER_BUFFER_SIZE / (this.max - this.min));\n            pos2 = Math.floor((transferfn[i + 1].value - this.min) * TRANSFER_BUFFER_SIZE / (this.max - this.min));\n            if (pos1 == pos2)\n                continue;\n            R = GLVolumetricRender.interpolateArray([color1.r * 255, color2.r * 255], pos2 - pos1);\n            G = GLVolumetricRender.interpolateArray([color1.g * 255, color2.g * 255], pos2 - pos1);\n            B = GLVolumetricRender.interpolateArray([color1.b * 255, color2.b * 255], pos2 - pos1);\n            A = GLVolumetricRender.interpolateArray([alpha1 * 255, alpha2 * 255], pos2 - pos1);\n            for (let j = 0; j < R.length; j++) {\n                this.transferfunctionbuffer.push(R[j]);\n                this.transferfunctionbuffer.push(G[j]);\n                this.transferfunctionbuffer.push(B[j]);\n                this.transferfunctionbuffer.push(A[j]); // opacity will be added later\n            }\n        }\n        this.transferfunctionbuffer = new Uint8ClampedArray(this.transferfunctionbuffer);\n        //need to create transformation matrix that maps model points into\n        //texture space\n        // need extent (bounding box dimensions), maxdepth (box diagonal), \n        // texmatrix (conversion from model to texture coords), minunit,\n        // possibly non-orthnormal basis if matrix\n        if (data.matrix) {\n            //figure out bounding box of transformed grid\n            let start = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);\n            let end = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(data.size.x, data.size.y, data.size.z);\n            let unit = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);\n            start.applyMatrix4(data.matrix);\n            end.applyMatrix4(data.matrix);\n            unit.applyMatrix4(data.matrix).sub(start);\n            this.extent = [[start.x, start.y, start.z], [end.x, end.y, end.z]];\n            //check all corners, these may not be the farthest apart\n            for (let i = 1; i < 7; i++) {\n                end.x = (i & 1) ? data.size.x : 0;\n                end.y = (i & 2) ? data.size.y : 0;\n                end.z = (i & 4) ? data.size.z : 0;\n                end.applyMatrix4(data.matrix);\n                this.extent[0][0] = Math.min(this.extent[0][0], end.x);\n                this.extent[0][1] = Math.min(this.extent[0][1], end.y);\n                this.extent[0][2] = Math.min(this.extent[0][2], end.z);\n                this.extent[1][0] = Math.max(this.extent[1][0], end.x);\n                this.extent[1][1] = Math.max(this.extent[1][1], end.y);\n                this.extent[1][2] = Math.max(this.extent[1][2], end.z);\n            }\n            let xoff = end.x - start.x;\n            let yoff = end.y - start.y;\n            let zoff = end.z - start.z;\n            this.maxdepth = Math.sqrt(xoff * xoff + yoff * yoff + zoff * zoff);\n            this.minunit = Math.min(Math.min(unit.x, unit.y), unit.z);\n            //invert onto grid, then scale by grid dimensions to get\n            //normalized texture coordinates\n            this.texmatrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().identity().scale({ x: data.size.x, y: data.size.y, z: data.size.z });\n            this.texmatrix = this.texmatrix.multiplyMatrices(data.matrix, this.texmatrix);\n            this.texmatrix = this.texmatrix.getInverse(this.texmatrix);\n        }\n        else {\n            this.texmatrix = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Matrix4().identity();\n            let xoff = data.unit.x * data.size.x;\n            let yoff = data.unit.y * data.size.y;\n            let zoff = data.unit.z * data.size.z;\n            //scale doesn't apply to the translation vector, so preapply it\n            this.texmatrix.makeTranslation(-data.origin.x / xoff, -data.origin.y / yoff, -data.origin.z / zoff);\n            this.texmatrix.scale({ x: 1.0 / xoff, y: 1.0 / yoff, z: 1.0 / zoff });\n            this.minunit = Math.min(Math.min(data.unit.x, data.unit.y), data.unit.z);\n            //need the bounding box so we can intersect with rays\n            this.extent = [[data.origin.x, data.origin.y, data.origin.z],\n                [data.origin.x + xoff, data.origin.y + yoff, data.origin.z + zoff]];\n            this.maxdepth = Math.sqrt(xoff * xoff + yoff * yoff + zoff * zoff);\n        }\n        //use GLShape to construct box\n        var shape = new _GLShape__WEBPACK_IMPORTED_MODULE_4__.GLShape({});\n        shape.addBox({\n            corner: { x: this.extent[0][0], y: this.extent[0][1], z: this.extent[0][2] },\n            dimensions: {\n                w: this.extent[1][0] - this.extent[0][0],\n                h: this.extent[1][1] - this.extent[0][1],\n                d: this.extent[1][2] - this.extent[0][2]\n            }\n        });\n        this.geo = shape.finalize();\n        this.boundingSphere.center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_1__.Vector3((this.extent[0][0] + this.extent[1][0]) / 2.0, (this.extent[0][1] + this.extent[1][1]) / 2.0, (this.extent[0][2] + this.extent[1][2]) / 2.0);\n        this.boundingSphere.radius = this.maxdepth / 2;\n        if (spec.coords === undefined && spec.selection !== undefined) {\n            if (viewer) {\n                spec.coords = viewer.selectedAtoms(spec.selection);\n            }\n            else {\n                console.log('Need to provide viewer to volumetric renderer if selection specified.');\n            }\n        }\n        // volume selectivity based on given coords and distance\n        if (spec.coords !== undefined && spec.seldist !== undefined) {\n            let mask = new Uint8Array(data.data.length);\n            //for each coordinate\n            let d = spec.seldist;\n            let d2 = d * d;\n            for (let i = 0, n = spec.coords.length; i < n; i++) {\n                let c = spec.coords[i];\n                let minx = c.x - d, miny = c.y - d, minz = c.z - d;\n                let maxx = c.x + d, maxy = c.y + d, maxz = c.z + d;\n                if (data.getIndex(minx, miny, minz) >= 0 || data.getIndex(maxx, maxy, maxz) >= 0) {\n                    //bounding box overlaps grid\n                    //iterate over the grid points in the seldist bounding box\n                    //minunit may be inefficient if axes have very different units. oh well.\n                    for (let x = minx; x < maxx; x += this.minunit) {\n                        for (let y = miny; y < maxy; y += this.minunit) {\n                            for (let z = minz; z < maxz; z += this.minunit) {\n                                let idx = data.getIndex(x, y, z);\n                                if (idx >= 0 && !mask[idx]) {\n                                    //if not already masked, check distance\n                                    let distsq = (x - c.x) * (x - c.x) + (y - c.y) * (y - c.y) + (z - c.z) * (z - c.z);\n                                    if (distsq < d2) {\n                                        mask[idx] = 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            //any place mask is zero, make infinite in data\n            for (let i = 0, n = data.data.length; i < n; i++) {\n                if (mask[i] == 0)\n                    data.data[i] = Infinity;\n            }\n        }\n        this.data = data;\n    }\n    /**\n     * Initialize webgl objects for rendering\n     * @param {Object3D} group\n     *\n     */\n    globj(group) {\n        if (this.renderedShapeObj) {\n            group.remove(this.renderedShapeObj);\n            this.renderedShapeObj = null;\n        }\n        if (this.hidden)\n            return;\n        this.shapeObj = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Object3D();\n        var material = null;\n        var texture = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Texture(this.data, true);\n        var transfertexture = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Texture(this.transferfunctionbuffer, false);\n        texture.needsUpdate = true;\n        transfertexture.needsUpdate = true;\n        transfertexture.flipY = false;\n        material = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.VolumetricMaterial({\n            transferfn: transfertexture,\n            transfermin: this.min,\n            transfermax: this.max,\n            map: texture,\n            extent: this.extent,\n            maxdepth: this.maxdepth,\n            texmatrix: this.texmatrix,\n            unit: this.minunit,\n            subsamples: this.subsamples,\n        });\n        var mesh = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Mesh(this.geo, material);\n        this.shapeObj.add(mesh);\n        this.renderedShapeObj = this.shapeObj.clone();\n        group.add(this.renderedShapeObj);\n    }\n    ;\n    removegl(group) {\n        if (this.renderedShapeObj) {\n            // dispose of geos and materials\n            if (this.renderedShapeObj.geometry !== undefined)\n                this.renderedShapeObj.geometry.dispose();\n            if (this.renderedShapeObj.material !== undefined)\n                this.renderedShapeObj.material.dispose();\n            group.remove(this.renderedShapeObj);\n            this.renderedShapeObj = null;\n        }\n        this.shapeObj = null;\n    }\n    ;\n    get position() {\n        return this.boundingSphere.center;\n    }\n    get x() {\n        return this.boundingSphere.center.x;\n    }\n    get y() {\n        return this.boundingSphere.center.y;\n    }\n    get z() {\n        return this.boundingSphere.center.z;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/VolumetricRender.ts?");

/***/ }),

/***/ "./src/WebGL/Camera.ts":
/*!*****************************!*\
  !*** ./src/WebGL/Camera.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"./src/WebGL/core/index.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ \"./src/WebGL/math/index.ts\");\n\n\n/*\n * Simplified Perspective Camera\n */\n/* @constructor */\nclass Camera extends _core__WEBPACK_IMPORTED_MODULE_0__.Object3D {\n    constructor(fov = 50, aspect = 1, near = 0.1, far = 2000, ortho = false) {\n        super();\n        this.projectionMatrix = new _math__WEBPACK_IMPORTED_MODULE_1__.Matrix4();\n        this.projectionMatrixInverse = new _math__WEBPACK_IMPORTED_MODULE_1__.Matrix4();\n        this.matrixWorldInverse = new _math__WEBPACK_IMPORTED_MODULE_1__.Matrix4();\n        this.fov = fov;\n        this.aspect = aspect;\n        this.near = near;\n        this.far = far;\n        var center = this.position.z;\n        this.right = center * Math.tan((Math.PI / 180) * fov);\n        this.left = -this.right;\n        this.top = this.right / this.aspect;\n        this.bottom = -this.top;\n        this.ortho = !!ortho;\n        this.updateProjectionMatrix();\n    }\n    lookAt(vector) {\n        //Why is the parameter order switched (compared to Object3D)?\n        this.matrix.lookAt(this.position, vector, this.up);\n        if (this.rotationAutoUpdate) {\n            if (this.useQuaternion === false && this.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_1__.Vector3) {\n                this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);\n            }\n            else {\n                console.error(\"Unimplemented math operation.\");\n            }\n        }\n    }\n    updateProjectionMatrix() {\n        if (this.ortho) {\n            this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);\n        }\n        else {\n            this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);\n        }\n        this.projectionMatrixInverse.getInverse(this.projectionMatrix);\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/Camera.ts?");

/***/ }),

/***/ "./src/WebGL/Fog.ts":
/*!**************************!*\
  !*** ./src/WebGL/Fog.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fog: () => (/* binding */ Fog)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colors */ \"./src/colors.ts\");\n\nclass Fog {\n    constructor(hex, near = 1, far = 1000) {\n        this.name = \"\";\n        this.color = new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(hex);\n        this.near = near;\n        this.far = far;\n    }\n    clone() {\n        return new Fog(this.color.getHex(), this.near, this.far);\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/Fog.ts?");

/***/ }),

/***/ "./src/WebGL/Renderer.ts":
/*!*******************************!*\
  !*** ./src/WebGL/Renderer.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera */ \"./src/WebGL/Camera.ts\");\n/* harmony import */ var _constants_Sides__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants/Sides */ \"./src/WebGL/constants/Sides.ts\");\n/* harmony import */ var _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants/TextureConstants */ \"./src/WebGL/constants/TextureConstants.ts\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core */ \"./src/WebGL/core/index.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../colors */ \"./src/colors.ts\");\n/* harmony import */ var _materials__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./materials */ \"./src/WebGL/materials/index.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./objects */ \"./src/WebGL/objects/index.ts\");\n/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shaders */ \"./src/WebGL/shaders/index.ts\");\n/* harmony import */ var _SpritePlugin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SpritePlugin */ \"./src/WebGL/SpritePlugin.ts\");\n/**\n * Simplified webGL renderer\n */\n\n\n\n\n\n\n\n\n\n\nclass Renderer {\n    constructor(parameters) {\n        this.context = null;\n        this.devicePixelRatio = 1.0; //set in setSize\n        this.autoClear = true;\n        this.autoClearColor = true;\n        this.autoClearDepth = true;\n        this.autoClearStencil = true;\n        // scene graph\n        this.sortObjects = true;\n        this.autoUpdateObjects = true;\n        this.autoUpdateScene = true;\n        // info\n        this.info = {\n            memory: {\n                programs: 0,\n                geometries: 0,\n                textures: 0,\n            },\n            render: {\n                calls: 0,\n                vertices: 0,\n                faces: 0,\n                points: 0,\n            },\n        };\n        // internal properties\n        this._programs = [];\n        this._programs_counter = 0;\n        this._webglversion = 1;\n        // internal state cache\n        this._currentProgram = null;\n        this._currentMaterialId = -1;\n        this._currentGeometryGroupHash = null;\n        this._currentCamera = null;\n        this._geometryGroupCounter = 0;\n        // GL state cache\n        this._oldDoubleSided = -1;\n        this._oldFlipSided = -1;\n        this._oldDepthTest = -1;\n        this._oldDepthWrite = -1;\n        this._oldPolygonOffset = null;\n        this._oldLineWidth = null;\n        this._viewportWidth = 0;\n        this._viewportHeight = 0;\n        this._currentWidth = 0;\n        this._currentHeight = 0;\n        this._enabledAttributes = {};\n        // camera matrices cache\n        this._projScreenMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();\n        this._vector3 = new _math__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n        this._worldInverse = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();\n        this._projInverse = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();\n        this._textureMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();\n        // light arrays cach\n        this._direction = new _math__WEBPACK_IMPORTED_MODULE_6__.Vector3();\n        this._lightsNeedUpdate = true;\n        this._lights = {\n            ambient: [0, 0, 0],\n            directional: {\n                length: 0,\n                colors: [],\n                positions: [],\n            },\n            point: {\n                length: 0,\n                colors: [],\n                positions: [],\n                distances: [],\n            },\n            spot: {\n                length: 0,\n                colors: [],\n                positions: [],\n                distances: [],\n                directions: [],\n                anglesCos: [],\n                exponents: [],\n            },\n            hemi: {\n                length: 0,\n                skyColors: [],\n                groundColors: [],\n                positions: [],\n            },\n        };\n        this.sprites = new _SpritePlugin__WEBPACK_IMPORTED_MODULE_9__.SpritePlugin();\n        //screensshader related variables\n        this._screenshader = null;\n        this._vertexattribpos = null;\n        this._screenQuadVBO = null;\n        //framebuffer variables\n        this._fb = null;\n        this._targetTexture = null;\n        this._depthTexture = null;\n        parameters = parameters || {};\n        this.row = parameters.row;\n        this.col = parameters.col;\n        this.rows = parameters.rows;\n        this.cols = parameters.cols;\n        this._canvas =\n            parameters.canvas !== undefined\n                ? parameters.canvas\n                : document.createElement(\"canvas\");\n        this._precision =\n            parameters.precision !== undefined ? parameters.precision : \"highp\";\n        this._alpha = parameters.alpha !== undefined ? parameters.alpha : true;\n        this._premultipliedAlpha =\n            parameters.premultipliedAlpha !== undefined\n                ? parameters.premultipliedAlpha\n                : true;\n        this._antialias =\n            parameters.antialias !== undefined ? parameters.antialias : false;\n        this._stencil =\n            parameters.stencil !== undefined ? parameters.stencil : true;\n        this._preserveDrawingBuffer =\n            parameters.preserveDrawingBuffer !== undefined\n                ? parameters.preserveDrawingBuffer\n                : false;\n        this._clearColor =\n            parameters.clearColor !== undefined\n                ? new _colors__WEBPACK_IMPORTED_MODULE_4__.Color(parameters.clearColor)\n                : new _colors__WEBPACK_IMPORTED_MODULE_4__.Color(0x000000);\n        this._clearAlpha =\n            parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0;\n        this._outlineMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.MeshOutlineMaterial(parameters.outline);\n        this._outlineSphereImposterMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.SphereImposterOutlineMaterial(parameters.outline);\n        this._outlineStickImposterMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.StickImposterOutlineMaterial(parameters.outline);\n        this._outlineEnabled = !!parameters.outline;\n        this.domElement = this._canvas;\n        this._canvas.id = parameters.id;\n        if (parameters.containerWidth == 0 || parameters.containerHeight == 0) {\n            return; //start lost\n        }\n        this.initGL();\n        this.setDefaultGLState();\n        this.context = this._gl;\n        if (this.isWebGL1()) {\n            this._extInstanced = this._gl.getExtension(\"ANGLE_instanced_arrays\");\n        }\n        else { //no longer an extension, wrap\n            this._extInstanced = {\n                vertexAttribDivisorANGLE: this._gl.vertexAttribDivisor.bind(this._gl),\n                drawElementsInstancedANGLE: this._gl.drawElementsInstanced.bind(this._gl),\n            };\n        }\n        this._extFragDepth = this._gl.getExtension(\"EXT_frag_depth\");\n        this._extFloatLinear = this._gl.getExtension(\"OES_texture_float_linear\");\n        this._extColorBufferFloat = this._gl.getExtension(\"EXT_color_buffer_float\");\n        this.sprites.init(this);\n    }\n    // API\n    supportedExtensions() {\n        return {\n            supportsAIA: Boolean(this._extInstanced),\n            supportsImposters: Boolean(this._extFragDepth) || !this.isWebGL1(),\n            regen: false\n        };\n    }\n    getContext() {\n        return this._gl;\n    }\n    getCanvas() {\n        return this._canvas;\n    }\n    isLost() {\n        return this._gl == null || this._gl.isContextLost();\n    }\n    getPrecision() {\n        return this._precision;\n    }\n    setClearColorHex(hex, alpha) {\n        this._clearColor.setHex(hex);\n        this._clearAlpha = alpha;\n        if (!this.isLost()) {\n            this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);\n        }\n    }\n    enableOutline(parameters) {\n        this._outlineMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.MeshOutlineMaterial(parameters);\n        this._outlineSphereImposterMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.SphereImposterOutlineMaterial(parameters);\n        this._outlineStickImposterMaterial = new _materials__WEBPACK_IMPORTED_MODULE_5__.StickImposterOutlineMaterial(parameters);\n        this._outlineEnabled = true;\n    }\n    disableOutline() {\n        this._outlineEnabled = false;\n    }\n    setViewport() {\n        if (this.rows != undefined &&\n            this.cols != undefined &&\n            this.row != undefined &&\n            this.col != undefined) {\n            var wid = this._canvas.width / this.cols;\n            var hei = this._canvas.height / this.rows;\n            this._viewportWidth = wid;\n            this._viewportHeight = hei;\n            if (!this.isLost()) {\n                this._gl.enable(this._gl.SCISSOR_TEST);\n                this._gl.scissor(wid * this.col, hei * this.row, wid, hei);\n                this._gl.viewport(wid * this.col, hei * this.row, wid, hei);\n            }\n        }\n    }\n    setSize(width, height) {\n        //zooming (in the browser) changes the pixel ratio and width/height\n        this.devicePixelRatio =\n            window.devicePixelRatio !== undefined ? window.devicePixelRatio : 1;\n        //with antialiasing on (which doesn't seem to do much), render at double rsolution to eliminate jaggies\n        //my iphone crashes if we do though, so as a hacky workaround, don't do it with retina displays\n        if (this._antialias && this.devicePixelRatio < 2.0)\n            this.devicePixelRatio *= 2.0;\n        if (this.rows != undefined &&\n            this.cols != undefined &&\n            this.row != undefined &&\n            this.col != undefined) {\n            var wid = width / this.cols;\n            var hei = height / this.rows;\n            this._canvas.width = width * this.devicePixelRatio;\n            this._canvas.height = height * this.devicePixelRatio;\n            this._viewportWidth = wid * this.devicePixelRatio;\n            this._viewportHeight = hei * this.devicePixelRatio;\n            this._canvas.style.width = width + \"px\";\n            this._canvas.style.height = height + \"px\";\n            this.setViewport();\n        }\n        else {\n            this._viewportWidth = this._canvas.width = width * this.devicePixelRatio;\n            this._viewportHeight = this._canvas.height = height * this.devicePixelRatio;\n            this._canvas.style.width = width + \"px\";\n            this._canvas.style.height = height + \"px\";\n            if (!this.isLost()) {\n                this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);\n            }\n        }\n        this.initFrameBuffer();\n    }\n    clear(color, depth, stencil) {\n        var bits = 0;\n        if (color === undefined || color)\n            bits |= this._gl.COLOR_BUFFER_BIT;\n        if (depth === undefined || depth)\n            bits |= this._gl.DEPTH_BUFFER_BIT;\n        if (stencil === undefined || stencil)\n            bits |= this._gl.STENCIL_BUFFER_BIT;\n        this._gl.clear(bits);\n    }\n    clearTarget(color, depth, stencil) {\n        this.clear(color, depth, stencil);\n    }\n    setMaterialFaces(material, reflected) {\n        var doubleSided = material.side === _constants_Sides__WEBPACK_IMPORTED_MODULE_1__.DoubleSide;\n        var flipSided = material.side === _constants_Sides__WEBPACK_IMPORTED_MODULE_1__.BackSide;\n        if (!material.imposter)\n            // Ignore reflection with imposters\n            flipSided = reflected ? !flipSided : flipSided;\n        if (this._oldDoubleSided !== doubleSided) {\n            if (doubleSided) {\n                this._gl.disable(this._gl.CULL_FACE);\n            }\n            else {\n                this._gl.enable(this._gl.CULL_FACE);\n            }\n            this._oldDoubleSided = doubleSided;\n        }\n        if (this._oldFlipSided !== flipSided) {\n            if (flipSided) {\n                this._gl.frontFace(this._gl.CW);\n            }\n            else {\n                this._gl.frontFace(this._gl.CCW);\n            }\n            this._oldFlipSided = flipSided;\n        }\n        this._gl.cullFace(this._gl.BACK);\n    }\n    setDepthTest(depthTest) {\n        if (this._oldDepthTest !== depthTest) {\n            if (depthTest) {\n                this._gl.enable(this._gl.DEPTH_TEST);\n            }\n            else {\n                this._gl.disable(this._gl.DEPTH_TEST);\n            }\n            this._oldDepthTest = depthTest;\n        }\n    }\n    setDepthWrite(depthWrite) {\n        if (this._oldDepthWrite !== depthWrite) {\n            this._gl.depthMask(depthWrite);\n            this._oldDepthWrite = depthWrite;\n        }\n    }\n    setBlending(blending) {\n        if (!blending) {\n            this._gl.disable(this._gl.BLEND);\n        }\n        else {\n            this._gl.enable(this._gl.BLEND);\n            this._gl.blendEquationSeparate(this._gl.FUNC_ADD, this._gl.FUNC_ADD);\n            this._gl.blendFuncSeparate(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\n        }\n    }\n    // TODO: need to set up shader attributes and uniforms as attributes on\n    // material object after attaching prgm\n    // We need to attach appropriate uniform variables to material after shaders\n    // have been chosen\n    initMaterial(material, lights, fog, objects) {\n        material.addEventListener(\"dispose\", this.onMaterialDispose.bind(this));\n        var parameters, shaderID;\n        shaderID = material.shaderID;\n        if (shaderID) {\n            var shader = _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderLib[shaderID];\n            material.vertexShader = shader.vertexShader;\n            material.fragmentShader = shader.fragmentShader;\n            material.uniforms = _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderUtils.clone(shader.uniforms);\n            // TODO: set material uniforms to shader uniform variables\n        }\n        parameters = {\n            wireframe: material.wireframe,\n            fragdepth: material.imposter,\n            volumetric: material.volumetric,\n        };\n        material.program = this.buildProgram(material.fragmentShader, material.vertexShader, material.uniforms, parameters);\n    }\n    renderBuffer(camera, lights, fog, material, geometryGroup, object) {\n        if (!material.visible)\n            return;\n        var program, attributes;\n        // Sets up proper vertex and fragment shaders and attaches them to webGL\n        // program\n        // Also sets appropriate uniform variables\n        program = this.setProgram(camera, lights, fog, material, object, this);\n        if (!program)\n            return;\n        attributes = program.attributes;\n        var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryGroupHash = geometryGroup.id * 0xffffff + program.id * 2 + wireframeBit;\n        if (geometryGroupHash !== this._currentGeometryGroupHash) {\n            this._currentGeometryGroupHash = geometryGroupHash;\n            updateBuffers = true;\n        }\n        // rebind shader attributes to appropriate (and already initialized) gl\n        // buffers\n        if (updateBuffers) {\n            this.disableAttributes();\n            // Vertices\n            if (attributes.position >= 0) {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n                this.enableAttribute(attributes.position);\n                this._gl.vertexAttribPointer(attributes.position, 3, this._gl.FLOAT, false, 0, 0);\n            }\n            // Colors\n            if (attributes.color >= 0) {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);\n                this.enableAttribute(attributes.color);\n                this._gl.vertexAttribPointer(attributes.color, 3, this._gl.FLOAT, false, 0, 0);\n            }\n            // Normals\n            if (attributes.normal >= 0) {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);\n                this.enableAttribute(attributes.normal);\n                this._gl.vertexAttribPointer(attributes.normal, 3, this._gl.FLOAT, false, 0, 0);\n            }\n            // Offsets (Instanced only)\n            if (attributes.offset >= 0) {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglOffsetBuffer);\n                this.enableAttribute(attributes.offset);\n                this._gl.vertexAttribPointer(attributes.offset, 3, this._gl.FLOAT, false, 0, 0);\n            }\n            // Radii (Instanced only)\n            if (attributes.radius >= 0) {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglRadiusBuffer);\n                this.enableAttribute(attributes.radius);\n                this._gl.vertexAttribPointer(attributes.radius, 1, this._gl.FLOAT, false, 0, 0);\n            }\n        }\n        // Render\n        var faceCount, lineCount;\n        // lambert shaders - draw triangles\n        // TODO: make sure geometryGroup's face count is setup correctly\n        if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh) {\n            if (material.shaderID === \"instanced\") {\n                var sphereGeometryGroup = material.sphere.geometryGroups[0];\n                if (updateBuffers) {\n                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n                    this._gl.bufferData(this._gl.ARRAY_BUFFER, sphereGeometryGroup.vertexArray, this._gl.STATIC_DRAW);\n                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);\n                    this._gl.bufferData(this._gl.ARRAY_BUFFER, sphereGeometryGroup.normalArray, this._gl.STATIC_DRAW);\n                    this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);\n                    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, sphereGeometryGroup.faceArray, this._gl.STATIC_DRAW);\n                }\n                faceCount = sphereGeometryGroup.faceidx;\n                this._extInstanced.vertexAttribDivisorANGLE(attributes.offset, 1);\n                this._extInstanced.vertexAttribDivisorANGLE(attributes.radius, 1);\n                this._extInstanced.vertexAttribDivisorANGLE(attributes.color, 1);\n                this._extInstanced.drawElementsInstancedANGLE(this._gl.TRIANGLES, faceCount, this._gl.UNSIGNED_SHORT, 0, geometryGroup.radiusArray.length);\n                this._extInstanced.vertexAttribDivisorANGLE(attributes.offset, 0);\n                this._extInstanced.vertexAttribDivisorANGLE(attributes.radius, 0);\n                this._extInstanced.vertexAttribDivisorANGLE(attributes.color, 0);\n            }\n            else if (material.wireframe) {\n                lineCount = geometryGroup.lineidx;\n                this.setLineWidth(material.wireframeLinewidth);\n                if (updateBuffers)\n                    this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);\n                this._gl.drawElements(this._gl.LINES, lineCount, this._gl.UNSIGNED_SHORT, 0);\n            }\n            else {\n                faceCount = geometryGroup.faceidx;\n                if (updateBuffers)\n                    this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);\n                this._gl.drawElements(this._gl.TRIANGLES, faceCount, this._gl.UNSIGNED_SHORT, 0);\n            }\n            this.info.render.calls++;\n            this.info.render.vertices += faceCount;\n            this.info.render.faces += faceCount / 3;\n        }\n        // basic shaders - draw lines\n        else if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line) {\n            lineCount = geometryGroup.vertices;\n            this.setLineWidth(material.linewidth);\n            this._gl.drawArrays(this._gl.LINES, 0, lineCount);\n            this.info.render.calls++;\n        }\n    }\n    render(scene, camera, forceClear) {\n        if (camera instanceof _Camera__WEBPACK_IMPORTED_MODULE_0__.Camera === false) {\n            console.error(\"Renderer.render: camera is not an instance of Camera.\");\n            return;\n        }\n        var i, il, webglObject, object, renderList, lights = scene.__lights, fog = scene.fog;\n        // reset caching for this frame\n        this._currentMaterialId = -1;\n        this._lightsNeedUpdate = true;\n        // update scene graph\n        if (this.autoUpdateScene)\n            scene.updateMatrixWorld();\n        // update camera matrices\n        // Pretty sure camera's parent is always going to be undefined for our\n        // purposes...\n        if (camera.parent === undefined)\n            camera.updateMatrixWorld();\n        camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n        this._projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n        if (this.isLost()) {\n            return;\n        }\n        // update WebGL objects\n        if (this.autoUpdateObjects)\n            this.initWebGLObjects(scene);\n        this.info.render.calls = 0;\n        this.info.render.vertices = 0;\n        this.info.render.faces = 0;\n        this.info.render.points = 0;\n        this._currentWidth = this._viewportWidth;\n        this._currentHeight = this._viewportHeight;\n        this.setViewport();\n        this.setFrameBuffer();\n        if (this.autoClear || forceClear) {\n            this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);\n            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);\n        }\n        // set matrices for regular objects (frustum culled)\n        renderList = scene.__webglObjects;\n        var hasvolumetric = false;\n        for (i = 0, il = renderList.length; i < il; i++) {\n            webglObject = renderList[i];\n            object = webglObject.object;\n            webglObject.render = false;\n            if (object.visible) {\n                this.setupMatrices(object, camera);\n                this.unrollBufferMaterial(webglObject);\n                webglObject.render = true;\n                if (webglObject.volumetric)\n                    hasvolumetric = true;\n            }\n        }\n        // set matrices for immediate objects\n        var material = null;\n        // opaque pass (front-to-back order)\n        this.setBlending(false);\n        this.renderObjects(scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material);\n        // Render embedded labels (sprites)\n        this.renderSprites(scene, camera, false);\n        // prime depth buffer\n        this.renderObjects(scene.__webglObjects, true, \"blank\", camera, lights, fog, true, material);\n        // transparent pass (back-to-front order)\n        this.renderObjects(scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material);\n        //volumetric is separate\n        if (hasvolumetric && this._fb) {\n            //disconnect framebuffer to get depth texture\n            this.reinitFrameBuffer();\n            this.renderObjects(scene.__webglObjects, false, \"volumetric\", camera, lights, fog, true, material);\n        }\n        this.renderFrameBuffertoScreen();\n        this.setDepthTest(true);\n        this.setDepthWrite(true);\n        // Render floating labels (sprites)\n        this.renderSprites(scene, camera, true);\n    }\n    //reinitialize framebuffer without the depth texture attached so we can read to it\n    //do not allocate new textures\n    reinitFrameBuffer() {\n        // only needed/works with webgl2\n        if (this.isWebGL1())\n            return;\n        // Create and bind the framebuffer\n        this._fb = this._gl.createFramebuffer();\n        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb);\n        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0);\n    }\n    //setup framebuffer for drawing into, assumes buffers already allocated\n    setFrameBuffer() {\n        if (this.isWebGL1() || !this._fb)\n            return;\n        let width = this._viewportWidth;\n        let height = this._viewportHeight;\n        //when using framebuffer, always draw from origin, will shift the viewport when we render\n        this._gl.enable(this._gl.SCISSOR_TEST);\n        this._gl.scissor(0, 0, width, height);\n        this._gl.viewport(0, 0, width, height);\n        //color texture\n        this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture);\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, width, height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n        //depth texture\n        this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, width, height, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null);\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n        //bind fb\n        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb);\n        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0);\n        this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);\n    }\n    //allocate buffers for framebuffer, needs to be called with every resize\n    initFrameBuffer() {\n        // only needed/works with webgl2\n        if (this.isWebGL1())\n            return;\n        let width = this._viewportWidth;\n        let height = this._viewportHeight;\n        //when using framebuffer, always draw from origin, will shift the viewport when we render\n        this._gl.enable(this._gl.SCISSOR_TEST);\n        this._gl.scissor(0, 0, width, height);\n        this._gl.viewport(0, 0, width, height);\n        //create textures and frame buffer, will be initialized in setFrameBuffer\n        this._targetTexture = this._gl.createTexture();\n        this._depthTexture = this._gl.createTexture();\n        this._fb = this._gl.createFramebuffer();\n        // build screenshader\n        var screenshader = _shaders__WEBPACK_IMPORTED_MODULE_8__.ShaderLib.screen;\n        this._screenshader = this.buildProgram(screenshader.fragmentShader, screenshader.vertexShader, screenshader.uniforms, {});\n        this._vertexattribpos = this._gl.getAttribLocation(this._screenshader, \"vertexPosition\");\n        // create the vertex array and attrib array for the full screenquad\n        var verts = [\n            // First triangle:\n            1.0, 1.0, -1.0, 1.0, -1.0, -1.0,\n            // Second triangle:\n            -1.0, -1.0, 1.0, -1.0, 1.0, 1.0,\n        ];\n        this._screenQuadVBO = this._gl.createBuffer();\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);\n        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(verts), this._gl.STATIC_DRAW);\n    }\n    renderFrameBuffertoScreen() {\n        // only needed/works with webgl2\n        if (this.isWebGL1() || this._fb === null)\n            return;\n        this.setViewport(); //draw texture in correct viewport\n        // bind default framebuffer\n        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);\n        this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);\n        this._gl.frontFace(this._gl.CCW);\n        this._gl.cullFace(this._gl.BACK);\n        // set screen shader and use it\n        this._gl.useProgram(this._screenshader);\n        this._currentProgram = this._screenshader;\n        // disable depth test\n        this.setDepthTest(-1);\n        this.setDepthWrite(-1);\n        // bind vertexarray buffer and texture\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO);\n        this._gl.enableVertexAttribArray(this._vertexattribpos);\n        this._gl.vertexAttribPointer(this._vertexattribpos, 2, this._gl.FLOAT, false, 0, 0);\n        this._gl.activeTexture(this._gl.TEXTURE0);\n        this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture);\n        // Draw 6 vertexes => 2 triangles:\n        this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);\n    }\n    initWebGLObjects(scene) {\n        if (!scene.__webglObjects) {\n            scene.__webglObjects = [];\n            scene.__webglObjectsImmediate = [];\n            scene.__webglSprites = [];\n            scene.__webglFlares = [];\n        }\n        // Add objects; this sets up buffers for each geometryGroup\n        if (scene.__objectsAdded.length) {\n            while (scene.__objectsAdded.length) {\n                this.addObject(scene.__objectsAdded[0], scene);\n                scene.__objectsAdded.splice(0, 1);\n            }\n            // Force buffer update during render\n            // Hackish fix for initial cartoon-render-then-transparent-surface\n            // bug\n            this._currentGeometryGroupHash = -1;\n        }\n        while (scene.__objectsRemoved.length) {\n            this.removeObject(scene.__objectsRemoved[0], scene);\n            scene.__objectsRemoved.splice(0, 1);\n        }\n        // update must be called after objects adding / removal\n        // This sends typed arrays to GL buffers for each geometryGroup\n        for (var o = 0, ol = scene.__webglObjects.length; o < ol; o++) {\n            this.updateObject(scene.__webglObjects[o].object);\n        }\n    }\n    getYRatio() {\n        if (this.rows !== undefined && this.row !== undefined)\n            return this.rows;\n        return 1;\n    }\n    getXRatio() {\n        if (this.cols !== undefined && this.col !== undefined)\n            return this.cols;\n        return 1;\n    }\n    getAspect(width, height) {\n        if (width == undefined || height == undefined) {\n            width = this._canvas.width;\n            height = this._canvas.height;\n        }\n        var aspect = width / height;\n        if (this.rows != undefined &&\n            this.cols != undefined &&\n            this.row != undefined &&\n            this.col != undefined) {\n            var wid = width / this.cols;\n            var hei = height / this.rows;\n            aspect = wid / hei;\n        }\n        return aspect;\n    }\n    setTexture(texture, slot, is3D) {\n        if (texture.needsUpdate) {\n            if (!texture.__webglInit) {\n                texture.__webglInit = true;\n                texture.addEventListener(\"dispose\", this.onTextureDispose.bind(this));\n                texture.__webglTexture = this._gl.createTexture();\n                this.info.memory.textures++;\n            }\n            this._gl.activeTexture(this._gl.TEXTURE0 + slot);\n            var gltextureType = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D;\n            this._gl.bindTexture(gltextureType, texture.__webglTexture);\n            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n            this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n            this._gl.pixelStorei(this._gl.PACK_ALIGNMENT, texture.unpackAlignment);\n            var glFormat = this.paramToGL(texture.format), glType = this.paramToGL(texture.type);\n            if (!is3D) {\n                var image = texture.image;\n                var width = image.width; //might not be defined\n                var height = image.height;\n                if (typeof width === \"undefined\") {\n                    //if no width,\n                    width = image.length;\n                    if (glFormat == this._gl.RGBA) {\n                        width /= 4; //each element takes up 4 bytes\n                    }\n                    height = 1;\n                }\n                this.setTextureParameters(this._gl.TEXTURE_2D, texture);\n                if (!this.isWebGL1()) {\n                    //webgl2\n                    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, glFormat, width, height, 0, glFormat, glType, texture.image);\n                }\n                else {\n                    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);\n                }\n            }\n            else {\n                //3D\n                this.setTextureParameters(this._gl.TEXTURE_3D, texture);\n                this._gl.texImage3D(this._gl.TEXTURE_3D, 0, this._gl.R32F, texture.image.size.z, texture.image.size.y, texture.image.size.x, 0, this._gl.RED, this._gl.FLOAT, texture.image.data);\n            }\n            texture.needsUpdate = false;\n            if (texture.onUpdate)\n                texture.onUpdate();\n        }\n        else {\n            this._gl.activeTexture(this._gl.TEXTURE0 + slot);\n            if (is3D)\n                this._gl.bindTexture(this._gl.TEXTURE_3D, texture.__webglTexture);\n            else\n                this._gl.bindTexture(this._gl.TEXTURE_2D, texture.__webglTexture);\n        }\n    }\n    supportsVolumetric() {\n        return !this.isWebGL1();\n    }\n    enableAttribute(attribute) {\n        if (!this._enabledAttributes[attribute]) {\n            this._gl.enableVertexAttribArray(attribute);\n            this._enabledAttributes[attribute] = true;\n        }\n    }\n    disableAttributes() {\n        for (let attribute in this._enabledAttributes) {\n            if (this._enabledAttributes[attribute]) {\n                this._gl.disableVertexAttribArray(attribute);\n                this._enabledAttributes[attribute] = false;\n            }\n        }\n    }\n    setPolygonOffset(polygonOffset, offsetFactor, offsetUnits) {\n        if (this._oldPolygonOffset !== polygonOffset) {\n            if (polygonOffset)\n                this._gl.enable(this._gl.POLYGON_OFFSET_FILL);\n            else\n                this._gl.disable(this._gl.POLYGON_OFFSET_FILL);\n        }\n    }\n    setLineWidth(width) {\n        if (width !== this._oldLineWidth) {\n            this._gl.lineWidth(width);\n            this._oldLineWidth = width;\n        }\n    }\n    deallocateGeometry(geometry) {\n        geometry.__webglInit = undefined;\n        if (geometry.__webglVertexBuffer !== undefined)\n            this._gl.deleteBuffer(geometry.__webglVertexBuffer);\n        if (geometry.__webglColorBuffer !== undefined)\n            this._gl.deleteBuffer(geometry.__webglColorBuffer);\n        if (geometry.geometryGroups !== undefined) {\n            for (var g = 0, gl = geometry.groups; g < gl; g++) {\n                var geometryGroup = geometry.geometryGroups[g];\n                if (geometryGroup.__webglVertexBuffer !== undefined)\n                    this._gl.deleteBuffer(geometryGroup.__webglVertexBuffer);\n                if (geometryGroup.__webglColorBuffer !== undefined)\n                    this._gl.deleteBuffer(geometryGroup.__webglColorBuffer);\n                if (geometryGroup.__webglNormalBuffer !== undefined)\n                    this._gl.deleteBuffer(geometryGroup.__webglNormalBuffer);\n                if (geometryGroup.__webglFaceBuffer !== undefined)\n                    this._gl.deleteBuffer(geometryGroup.__webglFaceBuffer);\n                if (geometryGroup.__webglLineBuffer !== undefined)\n                    this._gl.deleteBuffer(geometryGroup.__webglLineBuffer);\n            }\n        }\n    }\n    deallocateMaterial(material) {\n        var program = material.program;\n        if (program === undefined)\n            return;\n        material.program = undefined;\n        // only deallocate GL program if this was the last use of shared program\n        // assumed there is only single copy of any program in the _programs\n        // list\n        // (that's how it's constructed)\n        var i, il, programInfo;\n        var deleteProgram = false;\n        for (i = 0, il = this._programs.length; i < il; i++) {\n            programInfo = this._programs[i];\n            if (programInfo.program === program) {\n                programInfo.usedTimes--;\n                if (programInfo.usedTimes === 0) {\n                    deleteProgram = true;\n                }\n                break;\n            }\n        }\n        if (deleteProgram === true) {\n            // avoid using array.splice, this is costlier than creating new\n            // array from scratch\n            var newPrograms = [];\n            for (i = 0, il = this._programs.length; i < il; i++) {\n                programInfo = this._programs[i];\n                if (programInfo.program !== program) {\n                    newPrograms.push(programInfo);\n                }\n            }\n            this._programs = newPrograms;\n            this._gl.deleteProgram(program);\n            this.info.memory.programs--;\n        }\n    }\n    deallocateTexture(texture) {\n        if (texture.image && texture.image.__webglTextureCube) {\n            // cube texture\n            this._gl.deleteTexture(texture.image.__webglTextureCube);\n        }\n        else {\n            // 2D texture\n            if (!texture.__webglInit)\n                return;\n            texture.__webglInit = false;\n            this._gl.deleteTexture(texture.__webglTexture);\n        }\n    }\n    onGeometryDispose(event) {\n        var geometry = event.target;\n        geometry.removeEventListener(\"dispose\", this.onGeometryDispose);\n        this.deallocateGeometry(geometry);\n        this.info.memory.geometries--;\n    }\n    onTextureDispose(event) {\n        var texture = event.target;\n        texture.removeEventListener(\"dispose\", this.onTextureDispose);\n        this.deallocateTexture(texture);\n        this.info.memory.textures--;\n    }\n    onMaterialDispose(event) {\n        var material = event.target;\n        material.removeEventListener(\"dispose\", this.onMaterialDispose);\n        this.deallocateMaterial(material);\n    }\n    // Compile and return shader\n    getShader(type, str) {\n        var shader;\n        if (!this.isWebGL1() && !str.startsWith(\"#version\")) {\n            //convert webgl1 to webgl2, unless a version is already explicit\n            str = str.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\n            if (type == \"fragment\") {\n                str = str.replace(/varying/g, \"in\");\n            }\n            else {\n                str = str.replace(/varying/g, \"out\");\n            }\n            str = str.replace(/attribute/g, \"in\");\n            str = str.replace(/texture2D/g, \"texture\");\n            str = str.replace(/\\/\\/DEFINEFRAGCOLOR/g, \"out vec4 glFragColor;\");\n            str = str.replace(/gl_FragColor/g, \"glFragColor\");\n            str = \"#version 300 es\\n\" + str;\n        }\n        if (type === \"fragment\")\n            shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);\n        else if (type === \"vertex\")\n            shader = this._gl.createShader(this._gl.VERTEX_SHADER);\n        if (shader == null)\n            return null;\n        this._gl.shaderSource(shader, str);\n        this._gl.compileShader(shader);\n        if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {\n            console.error(this._gl.getShaderInfoLog(shader));\n            console.error(\"could not initialize shader\");\n            return null;\n        }\n        return shader;\n    }\n    // Compile appropriate shaders (if necessary) from source code and attach to\n    // gl program.\n    buildProgram(fragmentShader, vertexShader, uniforms, parameters) {\n        var p, pl, program, code;\n        var chunks = [];\n        chunks.push(fragmentShader);\n        chunks.push(vertexShader);\n        for (p in parameters) {\n            chunks.push(p);\n            chunks.push(parameters[p]);\n        }\n        code = chunks.join();\n        // check if program has already been compiled\n        for (p = 0, pl = this._programs.length; p < pl; p++) {\n            var programInfo = this._programs[p];\n            if (programInfo.code === code) {\n                programInfo.usedTimes++;\n                return programInfo.program;\n            }\n        }\n        // check if program requires webgl2\n        if (this.isWebGL1()) {\n            if (parameters.volumetric)\n                throw new Error(\"Volumetric rendering requires webgl2 which is not supported by your hardware.\");\n        }\n        // Set up new program and compile shaders\n        program = this._gl.createProgram();\n        if (program == null)\n            return null;\n        // set up precision\n        var precision = this._precision;\n        var prefix = \"precision \" + precision + \" float;\";\n        var prefix_vertex = [\n            parameters.volumetric ? \"#version 300 es\" : \"\",\n            prefix,\n        ].join(\"\\n\");\n        var prefix_fragment = [\n            parameters.volumetric ? \"#version 300 es\" : \"\",\n            parameters.fragdepth && this.isWebGL1()\n                ? \"#extension GL_EXT_frag_depth: enable\"\n                : \"\",\n            parameters.wireframe ? \"#define WIREFRAME 1\" : \"\",\n            prefix,\n        ].join(\"\\n\");\n        var glFragmentShader = this.getShader(\"fragment\", prefix_fragment + fragmentShader);\n        var glVertexShader = this.getShader(\"vertex\", prefix_vertex + vertexShader);\n        if (glVertexShader != null)\n            this._gl.attachShader(program, glVertexShader);\n        if (glFragmentShader != null)\n            this._gl.attachShader(program, glFragmentShader);\n        this._gl.linkProgram(program);\n        if (!this._gl.getProgramParameter(program, this._gl.LINK_STATUS))\n            console.error(\"Could not initialize shader\");\n        // gather and cache uniform variables and attributes\n        program.uniforms = {};\n        program.attributes = {};\n        var identifiers, u, i;\n        // uniform vars\n        identifiers = [\n            \"viewMatrix\",\n            \"modelViewMatrix\",\n            \"projectionMatrix\",\n            \"normalMatrix\",\n        ];\n        // custom uniform vars\n        for (u in uniforms)\n            identifiers.push(u);\n        for (i = 0; i < identifiers.length; i++) {\n            var uniformVar = identifiers[i];\n            program.uniforms[uniformVar] = this._gl.getUniformLocation(program, uniformVar);\n        }\n        // attributes\n        identifiers = [\n            \"position\",\n            \"normal\",\n            \"color\",\n            \"lineDistance\",\n            \"offset\",\n            \"radius\",\n        ];\n        /*\n         * for (a in attributes) identifiers.push(a);\n         */\n        for (i = 0; i < identifiers.length; i++) {\n            var attributeVar = identifiers[i];\n            program.attributes[attributeVar] = this._gl.getAttribLocation(program, attributeVar);\n        }\n        program.id = this._programs_counter++;\n        this._programs.push({\n            program: program,\n            code: code,\n            usedTimes: 1,\n        });\n        this.info.memory.programs = this._programs.length;\n        return program;\n    }\n    setProgram(camera, lights, fog, material, object, renderer) {\n        if (material.needsUpdate) {\n            if (material.program)\n                this.deallocateMaterial(material);\n            this.initMaterial(material, lights, fog, object);\n            material.needsUpdate = false;\n        }\n        if (material.program == null)\n            return null;\n        var refreshMaterial = false;\n        // p_uniforms: uniformVarName => uniformLocation\n        // m_uniforms: uniformVarName => uniformJsVal\n        var program = material.program, p_uniforms = program.uniforms, m_uniforms = material.uniforms;\n        if (program != this._currentProgram) {\n            this._gl.useProgram(program);\n            this._currentProgram = program;\n            refreshMaterial = true;\n        }\n        if (material.id != this._currentMaterialId) {\n            this._currentMaterialId = material.id;\n            refreshMaterial = true;\n        }\n        if (camera != this._currentCamera) {\n            this._currentCamera = camera;\n            refreshMaterial = true;\n        }\n        this._gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);\n        this._gl.uniformMatrix4fv(p_uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);\n        this._gl.uniformMatrix3fv(p_uniforms.normalMatrix, false, object._normalMatrix.elements);\n        // Send projection matrix to uniform variable in shader\n        if (refreshMaterial) {\n            // Load projection, model-view matrices for perspective\n            // Set up correct fog uniform vals\n            m_uniforms.fogColor.value = fog.color;\n            m_uniforms.fogNear.value = fog.near;\n            m_uniforms.fogFar.value = fog.far;\n            // Set up lights for lambert shader\n            if (material.shaderID.startsWith(\"lambert\") ||\n                material.shaderID === \"instanced\" ||\n                material.shaderID.endsWith(\"imposter\")) {\n                // load view and normal matrices for directional and object\n                // lighting\n                this._gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);\n                if (this._lightsNeedUpdate) {\n                    this.setupLights(program, lights);\n                    this._lightsNeedUpdate = false;\n                }\n                // Set up correct light uniform var vals\n                m_uniforms.directionalLightColor.value = this._lights.directional.colors;\n                m_uniforms.directionalLightDirection.value =\n                    this._lights.directional.positions;\n            }\n            else if (material.shaderID.endsWith(\"outline\")) {\n                m_uniforms.outlineColor.value = material.outlineColor;\n                m_uniforms.outlineWidth.value = material.outlineWidth;\n                m_uniforms.outlinePushback.value = material.outlinePushback;\n            }\n            else if (material.shaderID === \"volumetric\") {\n                //need a matrix that maps back from model coordinates to texture coordinates\n                //  textureMat*modelInv*position\n                object._modelViewMatrix.getScale(this._direction); //scale factor of conversion\n                this._worldInverse.getInverse(object._modelViewMatrix);\n                this._projInverse.getInverse(camera.projectionMatrix);\n                this._textureMatrix.multiplyMatrices(object.material.texmatrix, this._worldInverse);\n                this._gl.uniformMatrix4fv(p_uniforms.textmat, false, this._textureMatrix.elements);\n                this._gl.uniformMatrix4fv(p_uniforms.projinv, false, this._projInverse.elements);\n                //  need the resolution (step size of ray in viewer coordinates)\n                let invscale = Math.min(Math.min(this._direction.x, this._direction.y), this._direction.z);\n                m_uniforms.step.value = object.material.unit * invscale;\n                m_uniforms.maxdepth.value = object.material.maxdepth * invscale;\n                m_uniforms.transfermax.value = object.material.transfermax;\n                m_uniforms.transfermin.value = object.material.transfermin;\n                m_uniforms.subsamples.value = object.material.subsamples;\n                renderer.setTexture(object.material.transferfn, 4, false);\n                renderer.setTexture(object.material.map, 3, true);\n                //depth texture from the renderbuffer, for volumetric integration with surfaces\n                this._gl.activeTexture(this._gl.TEXTURE5);\n                this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);\n            }\n            // opacity, diffuse, emissive, etc\n            m_uniforms.opacity.value = material.opacity;\n            // Load any other material specific uniform variables to gl shaders\n            this.loadMaterialUniforms(p_uniforms, m_uniforms);\n        }\n        return program;\n    }\n    loadMaterialUniforms(p_uniforms, m_uniforms) {\n        var uniformVar, type, uniformVal, uniformLoc;\n        for (uniformVar in m_uniforms) {\n            if (!p_uniforms[uniformVar])\n                continue;\n            type = m_uniforms[uniformVar].type;\n            uniformVal = m_uniforms[uniformVar].value;\n            uniformLoc = p_uniforms[uniformVar];\n            // single float\n            if (type === \"f\")\n                this._gl.uniform1f(uniformLoc, uniformVal);\n            // single integer\n            else if (type === \"i\")\n                this._gl.uniform1i(uniformLoc, uniformVal);\n            // array of floats\n            else if (type === \"fv\")\n                this._gl.uniform3fv(uniformLoc, uniformVal);\n            // color - r,g,b floats\n            else if (type === \"c\")\n                this._gl.uniform3f(uniformLoc, uniformVal.r, uniformVal.g, uniformVal.b);\n            else if (type === \"f4\")\n                this._gl.uniform4f(uniformLoc, uniformVal[0], uniformVal[1], uniformVal[2], uniformVal[3]);\n        }\n    }\n    // Objects adding\n    addObject(object, scene) {\n        var g, gl, geometry, geometryGroup;\n        if (!object.__webglInit) {\n            object.__webglInit = true;\n            object._modelViewMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix4();\n            object._normalMatrix = new _math__WEBPACK_IMPORTED_MODULE_6__.Matrix3();\n            if (object.geometry !== undefined &&\n                object.geometry.__webglInit === undefined) {\n                object.geometry.__webglInit = true;\n                object.geometry.addEventListener(\"dispose\", this.onGeometryDispose.bind(this));\n            }\n            if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh || object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line) {\n                geometry = object.geometry;\n                for (g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {\n                    geometryGroup = geometry.geometryGroups[g];\n                    geometryGroup.id = this._geometryGroupCounter++;\n                    // initialise VBO on the first access\n                    if (!geometryGroup.__webglVertexBuffer) {\n                        if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh) {\n                            this.createMeshBuffers(geometryGroup);\n                            geometry.elementsNeedUpdate = true;\n                            geometry.normalsNeedUpdate = true;\n                        }\n                        else if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line)\n                            this.createLineBuffers(geometryGroup);\n                        geometry.verticesNeedUpdate = true;\n                        geometry.colorsNeedUpdate = true;\n                    }\n                }\n            }\n        }\n        if (!object.__webglActive) {\n            if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh || object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line) {\n                geometry = object.geometry;\n                for (g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {\n                    geometryGroup = geometry.geometryGroups[g];\n                    this.addBuffer(scene.__webglObjects, geometryGroup, object);\n                }\n            }\n            // Sprite\n            else if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Sprite)\n                scene.__webglSprites.push(object);\n            object.__webglActive = true;\n        }\n    }\n    updateObject(object) {\n        var geometry = object.geometry, geometryGroup;\n        if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh || object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line) {\n            for (var g = 0, gl = geometry.geometryGroups.length; g < gl; g++) {\n                geometryGroup = geometry.geometryGroups[g];\n                if (geometry.verticesNeedUpdate ||\n                    geometry.elementsNeedUpdate ||\n                    geometry.colorsNeedUpdate ||\n                    geometry.normalsNeedUpdate) {\n                    this.setBuffers(geometryGroup, this._gl.STATIC_DRAW);\n                }\n            }\n            geometry.verticesNeedUpdate = false;\n            geometry.elementsNeedUpdate = false;\n            geometry.normalsNeedUpdate = false;\n            geometry.colorsNeedUpdate = false;\n            geometry.buffersNeedUpdate = false;\n        }\n    }\n    removeObject(object, scene) {\n        if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Mesh || object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Line)\n            this.removeInstances(scene.__webglObjects, object);\n        else if (object instanceof _objects__WEBPACK_IMPORTED_MODULE_7__.Sprite)\n            this.removeInstancesDirect(scene.__webglSprites, object);\n        object.__webglActive = false;\n    }\n    removeInstances(objList, object) {\n        for (var o = objList.length - 1; o >= 0; --o) {\n            if (objList[o].object === object)\n                objList.splice(o, 1);\n        }\n    }\n    removeInstancesDirect(objList, object) {\n        for (var o = objList.length - 1; o >= 0; --o) {\n            if (objList[o] === object)\n                objList.splice(o, 1);\n        }\n    }\n    unrollBufferMaterial(globject) {\n        var object = globject.object;\n        var material = object.material;\n        if (material.volumetric) {\n            globject.opaque = null;\n            globject.transparent = null;\n            globject.volumetric = material;\n        }\n        else if (material.transparent) {\n            globject.opaque = null;\n            globject.volumetric = null;\n            globject.transparent = material;\n            if (!material.wireframe) {\n                var blankMaterial = material.clone();\n                blankMaterial.opacity = 0.0;\n                globject.blank = blankMaterial;\n            }\n        }\n        else {\n            globject.opaque = material;\n            globject.transparent = null;\n            globject.volumetric = null;\n        }\n    }\n    setBuffers(geometryGroup, hint) {\n        var vertexArray = geometryGroup.vertexArray;\n        var colorArray = geometryGroup.colorArray;\n        // offset buffers\n        if (geometryGroup.__webglOffsetBuffer !== undefined) {\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglOffsetBuffer);\n            this._gl.bufferData(this._gl.ARRAY_BUFFER, vertexArray, hint);\n        }\n        else {\n            //normal, non-instanced case\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);\n            this._gl.bufferData(this._gl.ARRAY_BUFFER, vertexArray, hint);\n        }\n        // color buffers\n        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);\n        this._gl.bufferData(this._gl.ARRAY_BUFFER, colorArray, hint);\n        // normal buffers\n        if (geometryGroup.normalArray &&\n            geometryGroup.__webglNormalBuffer !== undefined) {\n            var normalArray = geometryGroup.normalArray;\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);\n            this._gl.bufferData(this._gl.ARRAY_BUFFER, normalArray, hint);\n        }\n        // radius buffers\n        if (geometryGroup.radiusArray &&\n            geometryGroup.__webglRadiusBuffer !== undefined) {\n            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, geometryGroup.__webglRadiusBuffer);\n            this._gl.bufferData(this._gl.ARRAY_BUFFER, geometryGroup.radiusArray, hint);\n        }\n        // face (index) buffers\n        if (geometryGroup.faceArray &&\n            geometryGroup.__webglFaceBuffer !== undefined) {\n            var faceArray = geometryGroup.faceArray;\n            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);\n            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);\n        }\n        // line (index) buffers (for wireframe)\n        if (geometryGroup.lineArray &&\n            geometryGroup.__webglLineBuffer !== undefined) {\n            var lineArray = geometryGroup.lineArray;\n            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);\n            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);\n        }\n    }\n    // Creates appropriate gl buffers for geometry chunk\n    // TODO: do we need line buffer for mesh objects?\n    // Also, can we integrate this with createLineBuffers?\n    createMeshBuffers(geometryGroup) {\n        if (geometryGroup.radiusArray) {\n            geometryGroup.__webglRadiusBuffer = this._gl.createBuffer();\n        }\n        if (geometryGroup.useOffset) {\n            geometryGroup.__webglOffsetBuffer = this._gl.createBuffer();\n        }\n        geometryGroup.__webglVertexBuffer = this._gl.createBuffer();\n        geometryGroup.__webglNormalBuffer = this._gl.createBuffer();\n        geometryGroup.__webglColorBuffer = this._gl.createBuffer();\n        geometryGroup.__webglFaceBuffer = this._gl.createBuffer();\n        geometryGroup.__webglLineBuffer = this._gl.createBuffer();\n        this.info.memory.geometries++;\n    }\n    createLineBuffers(geometry) {\n        geometry.__webglVertexBuffer = this._gl.createBuffer();\n        geometry.__webglColorBuffer = this._gl.createBuffer();\n        this.info.memory.geometries++;\n    }\n    addBuffer(objlist, buffer, object) {\n        objlist.push({\n            buffer: buffer,\n            object: object,\n            opaque: null,\n            transparent: null,\n        });\n    }\n    setupMatrices(object, camera) {\n        object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n        object._normalMatrix.getInverse(object._modelViewMatrix);\n        object._normalMatrix.transpose();\n    }\n    // Fallback filters for non-power-of-2 textures\n    filterFallback(filter) {\n        return this._gl.LINEAR;\n    }\n    setTextureParameters(textureType, texture) {\n        if (textureType == this._gl.TEXTURE_2D) {\n            this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n            this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n            this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this.filterFallback(texture.magFilter));\n            this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this.filterFallback(texture.minFilter));\n        }\n        else {\n            // 3Dtexture\n            this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n            this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n            this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_R, this._gl.CLAMP_TO_EDGE);\n            if (this._extColorBufferFloat && this._extFloatLinear) {\n                //linear interpolation isn't supported by default (despite being the default??)\n                this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);\n                this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);\n            }\n            else {\n                this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);\n                this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);\n            }\n        }\n    }\n    // Map constants to WebGL constants\n    paramToGL(p) {\n        if (p === _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_2__.UnsignedByteType)\n            return this._gl.UNSIGNED_BYTE;\n        if (p === _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_2__.RGBAFormat)\n            return this._gl.RGBA;\n        if (p === _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_2__.NearestFilter)\n            return this._gl.NEAREST;\n        return 0;\n    }\n    setupLights(program, lights) {\n        var l, ll, light, r = 0, g = 0, b = 0, color, intensity, zlights = this._lights, dirColors = zlights.directional.colors, dirPositions = zlights.directional.positions, dirLength = 0, dirOffset = 0;\n        for (l = 0, ll = lights.length; l < ll; l++) {\n            light = lights[l];\n            color = light.color;\n            intensity = light.intensity;\n            if (light instanceof _core__WEBPACK_IMPORTED_MODULE_3__.Light) {\n                this._direction.getPositionFromMatrix(light.matrixWorld);\n                this._vector3.getPositionFromMatrix(light.target.matrixWorld);\n                this._direction.sub(this._vector3);\n                this._direction.normalize();\n                if (this._direction.x === 0 && this._direction.y === 0 && this._direction.z === 0)\n                    continue;\n                dirPositions[dirOffset] = this._direction.x;\n                dirPositions[dirOffset + 1] = this._direction.y;\n                dirPositions[dirOffset + 2] = this._direction.z;\n                dirColors[dirOffset] = color.r * intensity;\n                dirColors[dirOffset + 1] = color.g * intensity;\n                dirColors[dirOffset + 2] = color.b * intensity;\n                dirOffset += 3;\n                dirLength++;\n            }\n        }\n        zlights.ambient[0] = r;\n        zlights.ambient[1] = g;\n        zlights.ambient[2] = b;\n        zlights.directional.length = dirLength;\n    }\n    initGL() {\n        //note setting antialis to true doesn't seem to do much and\n        //causes problems on iOS Safari\n        try {\n            if (!(this._gl = this._canvas.getContext(\"webgl2\", {\n                alpha: this._alpha,\n                premultipliedAlpha: this._premultipliedAlpha,\n                antialias: this._antialias,\n                stencil: this._stencil,\n                preserveDrawingBuffer: this._preserveDrawingBuffer,\n            }))) {\n                if (!(this._gl = this._canvas.getContext(\"experimental-webgl\", {\n                    alpha: this._alpha,\n                    premultipliedAlpha: this._premultipliedAlpha,\n                    antialias: this._antialias,\n                    stencil: this._stencil,\n                    preserveDrawingBuffer: this._preserveDrawingBuffer,\n                }))) {\n                    if (!(this._gl = this._canvas.getContext(\"webgl\", {\n                        alpha: this._alpha,\n                        premultipliedAlpha: this._premultipliedAlpha,\n                        antialias: this._antialias,\n                        stencil: this._stencil,\n                        preserveDrawingBuffer: this._preserveDrawingBuffer,\n                    }))) {\n                        throw \"Error creating WebGL context.\";\n                    }\n                }\n            }\n            var vers = this._gl.getParameter(this._gl.VERSION);\n            this._webglversion = parseInt(vers[6]);\n        }\n        catch (error) {\n            console.error(error);\n        }\n    }\n    isWebGL1() {\n        return this._webglversion == 1;\n    }\n    setDefaultGLState() {\n        this._gl.clearColor(0, 0, 0, 1);\n        this._gl.clearDepth(1);\n        this._gl.clearStencil(0);\n        this._gl.enable(this._gl.DEPTH_TEST);\n        this._gl.depthFunc(this._gl.LEQUAL);\n        this._gl.frontFace(this._gl.CCW);\n        this._gl.cullFace(this._gl.BACK);\n        this._gl.enable(this._gl.CULL_FACE);\n        this._gl.enable(this._gl.BLEND);\n        this._gl.blendEquation(this._gl.FUNC_ADD);\n        this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);\n        this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);\n    }\n    // rendering\n    renderObjects(renderList, reverse, materialType, camera, lights, fog, useBlending, material) {\n        var webglObject, object, buffer, material, start, end, delta;\n        // Forward or backward render\n        if (reverse) {\n            start = renderList.length - 1;\n            end = -1;\n            delta = -1;\n        }\n        else {\n            start = 0;\n            end = renderList.length;\n            delta = 1;\n        }\n        for (var i = start; i !== end; i += delta) {\n            webglObject = renderList[i];\n            if (webglObject.render) {\n                object = webglObject.object;\n                buffer = webglObject.buffer;\n                material = webglObject[materialType];\n                if (!material)\n                    continue;\n                if (useBlending)\n                    this.setBlending(true);\n                this.setDepthTest(material.depthTest);\n                this.setDepthWrite(material.depthWrite);\n                this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n                var reflected = object._modelViewMatrix.isReflected();\n                this.setMaterialFaces(material, reflected);\n                this.renderBuffer(camera, lights, fog, material, buffer, object);\n                if (this._outlineEnabled || material.outline) {\n                    if (material.shaderID == \"sphereimposter\") {\n                        this.renderBuffer(camera, lights, fog, this._outlineSphereImposterMaterial, buffer, object);\n                    }\n                    else if (material.shaderID == \"stickimposter\") {\n                        this.renderBuffer(camera, lights, fog, this._outlineStickImposterMaterial, buffer, object);\n                    }\n                    else if (!material.wireframe &&\n                        material.shaderID !== \"basic\" &&\n                        material.opacity !== 0.0) {\n                        this.renderBuffer(camera, lights, fog, this._outlineMaterial, buffer, object);\n                    }\n                }\n            }\n        }\n    }\n    renderSprites(scene, camera, inFront) {\n        // Reset state once regardless\n        // This should also fix cartoon render bug (after transparent surface\n        // render)\n        this._currentGeometryGroupHash = -1;\n        this._currentProgram = null;\n        this._currentCamera = null;\n        this._oldDepthWrite = -1;\n        this._oldDepthTest = -1;\n        this._oldDoubleSided = -1;\n        this._currentMaterialId = -1;\n        this._oldFlipSided = -1;\n        this._lightsNeedUpdate = true;\n        this.sprites.render(scene, camera, this._currentWidth, this._currentHeight, inFront);\n        // Reset state a\n        this._currentGeometryGroupHash = -1;\n        this._currentProgram = null;\n        this._currentCamera = null;\n        this._oldDepthWrite = -1;\n        this._oldDepthTest = -1;\n        this._oldDoubleSided = -1;\n        this._currentMaterialId = -1;\n        this._oldFlipSided = -1;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/Renderer.ts?");

/***/ }),

/***/ "./src/WebGL/SpritePlugin.ts":
/*!***********************************!*\
  !*** ./src/WebGL/SpritePlugin.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpritePlugin: () => (/* binding */ SpritePlugin)\n/* harmony export */ });\n/* harmony import */ var _shaders_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders/index */ \"./src/WebGL/shaders/index.ts\");\n\n/*\n * Sprite render plugin\n */\nclass SpritePlugin {\n    constructor() {\n        this.sprite = {\n            vertices: null,\n            faces: null,\n            vertexBuffer: null,\n            elementBuffer: null,\n            program: null,\n            attributes: {},\n            uniforms: null,\n        };\n    }\n    init(renderer) {\n        this.gl = renderer.context;\n        this.renderer = renderer;\n        this.precision = renderer.getPrecision();\n        this.sprite.vertices = new Float32Array(8 + 8);\n        this.sprite.faces = new Uint16Array(6);\n        var i = 0;\n        this.sprite.vertices[i++] = -1;\n        this.sprite.vertices[i++] = -1; // vertex 0\n        this.sprite.vertices[i++] = 0;\n        this.sprite.vertices[i++] = 0; // uv 0\n        this.sprite.vertices[i++] = 1;\n        this.sprite.vertices[i++] = -1; // vertex 1\n        this.sprite.vertices[i++] = 1;\n        this.sprite.vertices[i++] = 0; // uv 1\n        this.sprite.vertices[i++] = 1;\n        this.sprite.vertices[i++] = 1; // vertex 2\n        this.sprite.vertices[i++] = 1;\n        this.sprite.vertices[i++] = 1; // uv 2\n        this.sprite.vertices[i++] = -1;\n        this.sprite.vertices[i++] = 1; // vertex 3\n        this.sprite.vertices[i++] = 0;\n        this.sprite.vertices[i++] = 1; // uv 3\n        i = 0;\n        this.sprite.faces[i++] = 0;\n        this.sprite.faces[i++] = 1;\n        this.sprite.faces[i++] = 2;\n        this.sprite.faces[i++] = 0;\n        this.sprite.faces[i++] = 2;\n        this.sprite.faces[i++] = 3;\n        this.sprite.vertexBuffer = this.gl.createBuffer();\n        this.sprite.elementBuffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.sprite.vertices, this.gl.STATIC_DRAW);\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer);\n        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.faces, this.gl.STATIC_DRAW);\n        this.sprite.program = this.createProgram(_shaders_index__WEBPACK_IMPORTED_MODULE_0__.ShaderLib.sprite, this.precision || 1 /** added default to single precision */);\n        this.sprite.attributes = {};\n        const uniforms = {};\n        this.sprite.attributes.position = this.gl.getAttribLocation(this.sprite.program, \"position\");\n        this.sprite.attributes.uv = this.gl.getAttribLocation(this.sprite.program, \"uv\");\n        uniforms.uvOffset = this.gl.getUniformLocation(this.sprite.program, \"uvOffset\");\n        uniforms.uvScale = this.gl.getUniformLocation(this.sprite.program, \"uvScale\");\n        uniforms.rotation = this.gl.getUniformLocation(this.sprite.program, \"rotation\");\n        uniforms.scale = this.gl.getUniformLocation(this.sprite.program, \"scale\");\n        uniforms.alignment = this.gl.getUniformLocation(this.sprite.program, \"alignment\");\n        uniforms.color = this.gl.getUniformLocation(this.sprite.program, \"color\");\n        uniforms.map = this.gl.getUniformLocation(this.sprite.program, \"map\");\n        uniforms.opacity = this.gl.getUniformLocation(this.sprite.program, \"opacity\");\n        uniforms.useScreenCoordinates = this.gl.getUniformLocation(this.sprite.program, \"useScreenCoordinates\");\n        uniforms.screenPosition = this.gl.getUniformLocation(this.sprite.program, \"screenPosition\");\n        uniforms.modelViewMatrix = this.gl.getUniformLocation(this.sprite.program, \"modelViewMatrix\");\n        uniforms.projectionMatrix = this.gl.getUniformLocation(this.sprite.program, \"projectionMatrix\");\n        uniforms.fogType = this.gl.getUniformLocation(this.sprite.program, \"fogType\");\n        uniforms.fogDensity = this.gl.getUniformLocation(this.sprite.program, \"fogDensity\");\n        uniforms.fogNear = this.gl.getUniformLocation(this.sprite.program, \"fogNear\");\n        uniforms.fogFar = this.gl.getUniformLocation(this.sprite.program, \"fogFar\");\n        uniforms.fogColor = this.gl.getUniformLocation(this.sprite.program, \"fogColor\");\n        uniforms.alphaTest = this.gl.getUniformLocation(this.sprite.program, \"alphaTest\");\n        this.sprite.uniforms = uniforms;\n    }\n    render(scene, camera, viewportWidth, viewportHeight, inFront) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        if (!this.gl)\n            throw new Error(\"WebGLRenderer not initialized\");\n        let sprites = [];\n        (_a = scene === null || scene === void 0 ? void 0 : scene.__webglSprites) === null || _a === void 0 ? void 0 : _a.forEach((sprite) => {\n            //depthTest is false for inFront labels\n            if (inFront && sprite.material.depthTest == false) {\n                sprites.push(sprite);\n            }\n            else if (!inFront && sprite.material.depthTest) {\n                sprites.push(sprite);\n            }\n        });\n        let nSprites = sprites.length;\n        if (!nSprites)\n            return;\n        const attributes = this.sprite.attributes;\n        const uniforms = this.sprite.uniforms;\n        if (!uniforms)\n            throw new Error(\"Uniforms not defined\");\n        var halfViewportWidth = viewportWidth * 0.5, halfViewportHeight = viewportHeight * 0.5;\n        // setup gl\n        this.gl.useProgram(this.sprite.program);\n        this.gl.enableVertexAttribArray(attributes.position);\n        this.gl.enableVertexAttribArray(attributes.uv);\n        this.gl.disable(this.gl.CULL_FACE);\n        this.gl.enable(this.gl.BLEND);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer);\n        this.gl.vertexAttribPointer(attributes.position, 2, this.gl.FLOAT, false, 2 * 8, 0);\n        this.gl.vertexAttribPointer(attributes.uv, 2, this.gl.FLOAT, false, 2 * 8, 8);\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer);\n        this.gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);\n        this.gl.activeTexture(this.gl.TEXTURE0);\n        this.gl.uniform1i(uniforms.map, 0);\n        var oldFogType = 0;\n        var sceneFogType = 0;\n        var fog = scene.fog;\n        if (fog) {\n            this.gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);\n            this.gl.uniform1f(uniforms.fogNear, fog.near);\n            this.gl.uniform1f(uniforms.fogFar, fog.far);\n            this.gl.uniform1i(uniforms.fogType, 1);\n            oldFogType = 1;\n            sceneFogType = 1;\n        }\n        else {\n            this.gl.uniform1i(uniforms.fogType, 0);\n            oldFogType = 0;\n            sceneFogType = 0;\n        }\n        // update positions and sort\n        var i;\n        let sprite;\n        let material;\n        let size;\n        let fogType;\n        let scale = [];\n        for (i = 0; i < nSprites; i++) {\n            sprite = sprites[i];\n            material = sprite.material;\n            if (!material)\n                continue;\n            if (material.depthTest == false && !inFront)\n                continue;\n            if (!sprite.visible || material.opacity === 0)\n                continue;\n            if (!material.useScreenCoordinates) {\n                sprite._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);\n                sprite.z = -sprite._modelViewMatrix.elements[14];\n            }\n            else {\n                sprite.z = -sprite.position.z;\n            }\n        }\n        sprites.sort(painterSortStable);\n        // render all sprites\n        for (i = 0; i < nSprites; i++) {\n            sprite = sprites[i];\n            material = sprite.material;\n            if (!material)\n                continue;\n            if (!sprite.visible || material.opacity === 0)\n                continue;\n            if (material.map && material.map.image && material.map.image.width) {\n                this.gl.uniform1f((uniforms === null || uniforms === void 0 ? void 0 : uniforms.alphaTest) || null, material.alphaTest);\n                var w = material.map.image.width;\n                var h = material.map.image.height;\n                scale[0] = (w * this.renderer.devicePixelRatio) / viewportWidth;\n                scale[1] = (h * this.renderer.devicePixelRatio) / viewportHeight;\n                if (material.useScreenCoordinates === true) {\n                    this.gl.uniform1i(uniforms.useScreenCoordinates, 1);\n                    this.gl.uniform3f(uniforms.screenPosition, (sprite.position.x * this.renderer.devicePixelRatio -\n                        halfViewportWidth) /\n                        halfViewportWidth, (halfViewportHeight -\n                        sprite.position.y * this.renderer.devicePixelRatio) /\n                        halfViewportHeight, Math.max(0, Math.min(1, sprite.position.z)));\n                }\n                else {\n                    this.gl.uniform1i(uniforms.useScreenCoordinates, 0);\n                    this.gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements);\n                }\n                if (scene.fog && material.fog) {\n                    fogType = sceneFogType;\n                }\n                else {\n                    fogType = 0;\n                }\n                if (oldFogType !== fogType) {\n                    this.gl.uniform1i(uniforms.fogType, fogType);\n                    oldFogType = fogType;\n                }\n                size = 1 / (material.scaleByViewport ? viewportHeight : 1);\n                scale[0] *= size * sprite.scale.x;\n                scale[1] *= size * sprite.scale.y;\n                let alignx = (_b = material === null || material === void 0 ? void 0 : material.alignment) === null || _b === void 0 ? void 0 : _b.x, aligny = (_c = material === null || material === void 0 ? void 0 : material.alignment) === null || _c === void 0 ? void 0 : _c.y;\n                if (material.screenOffset) {\n                    //adjust alignment offset by screenOffset adjusted to sprite coords\n                    alignx = (alignx || 0) + (2.0 * material.screenOffset.x) / w;\n                    aligny = (aligny || 0) + (2.0 * material.screenOffset.y) / h;\n                }\n                this.gl.uniform2f(uniforms.uvScale, ((_d = material === null || material === void 0 ? void 0 : material.uvScale) === null || _d === void 0 ? void 0 : _d.x) || 1, ((_e = material === null || material === void 0 ? void 0 : material.uvScale) === null || _e === void 0 ? void 0 : _e.y) || 1);\n                this.gl.uniform2f(uniforms.uvOffset, ((_f = material === null || material === void 0 ? void 0 : material.uvOffset) === null || _f === void 0 ? void 0 : _f.x) || 0, ((_g = material === null || material === void 0 ? void 0 : material.uvOffset) === null || _g === void 0 ? void 0 : _g.y) || 0);\n                this.gl.uniform2f(uniforms.alignment, alignx || 0, aligny || 0);\n                this.gl.uniform1f(uniforms.opacity, material.opacity);\n                this.gl.uniform3f(uniforms.color, ((_h = material === null || material === void 0 ? void 0 : material.color) === null || _h === void 0 ? void 0 : _h.r) || 0, ((_j = material === null || material === void 0 ? void 0 : material.color) === null || _j === void 0 ? void 0 : _j.g) || 0, ((_k = material === null || material === void 0 ? void 0 : material.color) === null || _k === void 0 ? void 0 : _k.b) || 0);\n                this.gl.uniform1f(uniforms.rotation, sprite.rotation);\n                this.gl.uniform2fv(uniforms.scale, scale);\n                //this.renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n                this.renderer.setDepthTest(material.depthTest);\n                this.renderer.setDepthWrite(material.depthWrite);\n                this.renderer.setTexture(material.map, 0);\n                this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);\n            }\n        }\n        // restore gl\n        this.gl.enable(this.gl.CULL_FACE);\n    }\n    createProgram(shader, precision) {\n        if (!this.gl)\n            throw new Error(\"WebGL Rendering context not found\");\n        var program = this.gl.createProgram();\n        if (!program)\n            throw new Error(\"Error creating webgl program\");\n        var fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n        var vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\n        if (!fragmentShader)\n            throw new Error(\"Unable to create fragment shader SpritePlugin.createProgram\");\n        if (!vertexShader)\n            throw new Error(\"Unable to create vertex shader SpritePlugin.createProgram\");\n        var prefix = \"precision \" + precision + \" float;\\n\";\n        this.gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);\n        this.gl.shaderSource(vertexShader, prefix + shader.vertexShader);\n        this.gl.compileShader(fragmentShader);\n        this.gl.compileShader(vertexShader);\n        if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS) ||\n            !this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {\n            throw new Error(`Error compiling shader: \n      ${this.gl.getShaderInfoLog(fragmentShader)} \n      ${this.gl.getShaderInfoLog(vertexShader)}`);\n        }\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.attachShader(program, vertexShader);\n        this.gl.linkProgram(program);\n        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS))\n            console.error(\"Could not initialize shader\");\n        return program;\n    }\n}\nfunction painterSortStable(a, b) {\n    if (a.z !== b.z) {\n        return b.z - a.z;\n    }\n    else {\n        return b.id - a.id;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/SpritePlugin.ts?");

/***/ }),

/***/ "./src/WebGL/constants/Coloring.ts":
/*!*****************************************!*\
  !*** ./src/WebGL/constants/Coloring.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coloring: () => (/* binding */ Coloring)\n/* harmony export */ });\nvar Coloring;\n(function (Coloring) {\n    // colors\n    Coloring[Coloring[\"NoColors\"] = 0] = \"NoColors\";\n    Coloring[Coloring[\"FaceColors\"] = 1] = \"FaceColors\";\n    Coloring[Coloring[\"VertexColors\"] = 2] = \"VertexColors\";\n})(Coloring || (Coloring = {}));\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/constants/Coloring.ts?");

/***/ }),

/***/ "./src/WebGL/constants/Shading.ts":
/*!****************************************!*\
  !*** ./src/WebGL/constants/Shading.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shading: () => (/* binding */ Shading)\n/* harmony export */ });\nvar Shading;\n(function (Shading) {\n    // shading\n    Shading[Shading[\"NoShading\"] = 0] = \"NoShading\";\n    Shading[Shading[\"FlatShading\"] = 1] = \"FlatShading\";\n    Shading[Shading[\"SmoothShading\"] = 2] = \"SmoothShading\";\n})(Shading || (Shading = {}));\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/constants/Shading.ts?");

/***/ }),

/***/ "./src/WebGL/constants/Sides.ts":
/*!**************************************!*\
  !*** ./src/WebGL/constants/Sides.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackSide: () => (/* binding */ BackSide),\n/* harmony export */   DoubleSide: () => (/* binding */ DoubleSide),\n/* harmony export */   FrontSide: () => (/* binding */ FrontSide)\n/* harmony export */ });\n// sides - not an enum for backwards compat\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/constants/Sides.ts?");

/***/ }),

/***/ "./src/WebGL/constants/SpriteAlignment.ts":
/*!************************************************!*\
  !*** ./src/WebGL/constants/SpriteAlignment.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpriteAlignment: () => (/* binding */ SpriteAlignment)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n//Alignment for Sprites\n\nconst SpriteAlignment = {\n    topLeft: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, -1),\n    topCenter: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, -1),\n    topRight: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(-1, -1),\n    centerLeft: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 0),\n    center: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0),\n    centerRight: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(-1, 0),\n    bottomLeft: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),\n    bottomCenter: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 1),\n    bottomRight: new _math__WEBPACK_IMPORTED_MODULE_0__.Vector2(-1, 1)\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/constants/SpriteAlignment.ts?");

/***/ }),

/***/ "./src/WebGL/constants/TextureConstants.ts":
/*!*************************************************!*\
  !*** ./src/WebGL/constants/TextureConstants.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClampToEdgeWrapping: () => (/* binding */ ClampToEdgeWrapping),\n/* harmony export */   FloatType: () => (/* binding */ FloatType),\n/* harmony export */   LinearFilter: () => (/* binding */ LinearFilter),\n/* harmony export */   LinearMipMapLinearFilter: () => (/* binding */ LinearMipMapLinearFilter),\n/* harmony export */   NearestFilter: () => (/* binding */ NearestFilter),\n/* harmony export */   R32Format: () => (/* binding */ R32Format),\n/* harmony export */   RFormat: () => (/* binding */ RFormat),\n/* harmony export */   RGBAFormat: () => (/* binding */ RGBAFormat),\n/* harmony export */   UnsignedByteType: () => (/* binding */ UnsignedByteType)\n/* harmony export */ });\n// wrapping modes\nconst ClampToEdgeWrapping = 1001;\n//Filters\nconst LinearFilter = 1006;\nconst NearestFilter = 1007;\nconst LinearMipMapLinearFilter = 1008;\n//Data types\nconst UnsignedByteType = 1009;\nconst FloatType = 1010;\n//Pixel formats\nconst RGBAFormat = 1021;\nconst RFormat = 1022;\nconst R32Format = 1023;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/constants/TextureConstants.ts?");

/***/ }),

/***/ "./src/WebGL/constants/TextureOperations.ts":
/*!**************************************************!*\
  !*** ./src/WebGL/constants/TextureOperations.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextureOperations: () => (/* binding */ TextureOperations)\n/* harmony export */ });\n//Texture constants\n//TODO: Which of these do I need (since I only use textures to display label sprites) ?\nvar TextureOperations;\n(function (TextureOperations) {\n    TextureOperations[TextureOperations[\"MultiplyOperation\"] = 0] = \"MultiplyOperation\";\n    TextureOperations[TextureOperations[\"MixOperation\"] = 1] = \"MixOperation\";\n    TextureOperations[TextureOperations[\"AddOperation\"] = 2] = \"AddOperation\";\n})(TextureOperations || (TextureOperations = {}));\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/constants/TextureOperations.ts?");

/***/ }),

/***/ "./src/WebGL/constants/index.ts":
/*!**************************************!*\
  !*** ./src/WebGL/constants/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackSide: () => (/* reexport safe */ _Sides__WEBPACK_IMPORTED_MODULE_1__.BackSide),\n/* harmony export */   ClampToEdgeWrapping: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.ClampToEdgeWrapping),\n/* harmony export */   Coloring: () => (/* reexport safe */ _Coloring__WEBPACK_IMPORTED_MODULE_0__.Coloring),\n/* harmony export */   DoubleSide: () => (/* reexport safe */ _Sides__WEBPACK_IMPORTED_MODULE_1__.DoubleSide),\n/* harmony export */   FloatType: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.FloatType),\n/* harmony export */   FrontSide: () => (/* reexport safe */ _Sides__WEBPACK_IMPORTED_MODULE_1__.FrontSide),\n/* harmony export */   LinearFilter: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.LinearFilter),\n/* harmony export */   LinearMipMapLinearFilter: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.LinearMipMapLinearFilter),\n/* harmony export */   NearestFilter: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.NearestFilter),\n/* harmony export */   R32Format: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.R32Format),\n/* harmony export */   RFormat: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.RFormat),\n/* harmony export */   RGBAFormat: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat),\n/* harmony export */   Shading: () => (/* reexport safe */ _Shading__WEBPACK_IMPORTED_MODULE_2__.Shading),\n/* harmony export */   SpriteAlignment: () => (/* reexport safe */ _SpriteAlignment__WEBPACK_IMPORTED_MODULE_3__.SpriteAlignment),\n/* harmony export */   TextureOperations: () => (/* reexport safe */ _TextureOperations__WEBPACK_IMPORTED_MODULE_5__.TextureOperations),\n/* harmony export */   UnsignedByteType: () => (/* reexport safe */ _TextureConstants__WEBPACK_IMPORTED_MODULE_4__.UnsignedByteType)\n/* harmony export */ });\n/* harmony import */ var _Coloring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Coloring */ \"./src/WebGL/constants/Coloring.ts\");\n/* harmony import */ var _Sides__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sides */ \"./src/WebGL/constants/Sides.ts\");\n/* harmony import */ var _Shading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Shading */ \"./src/WebGL/constants/Shading.ts\");\n/* harmony import */ var _SpriteAlignment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SpriteAlignment */ \"./src/WebGL/constants/SpriteAlignment.ts\");\n/* harmony import */ var _TextureConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextureConstants */ \"./src/WebGL/constants/TextureConstants.ts\");\n/* harmony import */ var _TextureOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TextureOperations */ \"./src/WebGL/constants/TextureOperations.ts\");\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/constants/index.ts?");

/***/ }),

/***/ "./src/WebGL/core/EventDispatcher.ts":
/*!*******************************************!*\
  !*** ./src/WebGL/core/EventDispatcher.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher)\n/* harmony export */ });\n//Event Handling\nclass EventDispatcher {\n    constructor() {\n        this.listeners = {};\n    }\n    dispatchEvent(event) {\n        var listenerArray = this.listeners[event.type];\n        if (listenerArray !== undefined) {\n            event.target = this;\n            for (var i = 0, l = listenerArray.length; i < l; i++)\n                listenerArray[i].call(this, event);\n        }\n    }\n    removeEventListener(type, listener) {\n        if (!listener) {\n            this.listeners[type] = [];\n        }\n        else {\n            var index = this.listeners[type].indexOf(listener);\n            if (index !== -1)\n                this.listeners[type].splice(index, 1);\n        }\n    }\n    addEventListener(type, listener) {\n        if (this.listeners[type] === undefined)\n            this.listeners[type] = [];\n        if (this.listeners[type].indexOf(listener) === -1)\n            this.listeners[type].push(listener);\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/core/EventDispatcher.ts?");

/***/ }),

/***/ "./src/WebGL/core/Geometry.ts":
/*!************************************!*\
  !*** ./src/WebGL/core/Geometry.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Geometry: () => (/* binding */ Geometry),\n/* harmony export */   GeometryGroup: () => (/* binding */ GeometryGroup),\n/* harmony export */   GeometryIDCount: () => (/* binding */ GeometryIDCount)\n/* harmony export */ });\n/* harmony import */ var _materials_LineBasicMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials/LineBasicMaterial */ \"./src/WebGL/materials/LineBasicMaterial.ts\");\n/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ \"./src/WebGL/core/EventDispatcher.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n\n\n\n\nconst BUFFERSIZE = 65535; //limited to 16bit indices\nclass GeometryGroup {\n    constructor(id = 0) {\n        this.vertexArray = null;\n        this.colorArray = null;\n        this.normalArray = null;\n        this.radiusArray = null;\n        this.faceArray = null;\n        this.lineArray = null;\n        this.vertices = 0;\n        this.faceidx = 0;\n        this.lineidx = 0;\n        this.__inittedArrays = false;\n        this.id = id;\n    }\n    setColors(setcolor) {\n        //apply a function that takes the vertex coordinate and returns a color\n        var v = this.vertexArray;\n        var c = this.colorArray;\n        if (!v)\n            throw new Error(\"vertex array not initialized\");\n        if (!c)\n            throw new Error(\"color array not initialized\");\n        if (v.length != c.length) {\n            console.log(\"Cannot re-color geometry group due to mismatched lengths.\");\n            return;\n        }\n        for (var i = 0; i < v.length; i += 3) {\n            var col = setcolor(v[i], v[i + 1], v[i + 2]);\n            if (!(col instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color)) {\n                col = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(col);\n            }\n            c[i] = col.r;\n            c[i + 1] = col.g;\n            c[i + 2] = col.b;\n        }\n    }\n    getNumVertices() {\n        return this.vertices;\n    }\n    getVertices() {\n        return this.vertexArray;\n    }\n    getCentroid() {\n        if (!this.vertexArray)\n            throw new Error(\"vertex array not initialized\");\n        var centroid = new _math__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        var offset, x, y, z;\n        for (var i = 0; i < this.vertices; ++i) {\n            offset = i * 3;\n            x = this.vertexArray[offset];\n            y = this.vertexArray[offset + 1];\n            z = this.vertexArray[offset + 2];\n            centroid.x += x;\n            centroid.y += y;\n            centroid.z += z;\n        }\n        //divideScalar checks for 0 denom\n        centroid.divideScalar(this.vertices);\n        return centroid;\n    }\n    //setup normals - vertex and face array must exist\n    setNormals() {\n        var faces = this.faceArray;\n        var verts = this.vertexArray;\n        var norms = this.normalArray;\n        if (!this.vertices || !this.faceidx)\n            return;\n        if (!faces)\n            throw new Error(\"face array not initialized\");\n        if (!verts)\n            throw new Error(\"vertex array not initialized\");\n        if (!norms)\n            throw new Error(\"normal array not initialized\");\n        //vertex indices\n        var a, b, c, \n        //and actual vertices\n        vA, vB, vC, norm;\n        for (var i = 0; i < faces.length / 3; ++i) {\n            a = faces[i * 3] * 3;\n            b = faces[i * 3 + 1] * 3;\n            c = faces[i * 3 + 2] * 3;\n            vA = new _math__WEBPACK_IMPORTED_MODULE_2__.Vector3(verts[a], verts[a + 1], verts[a + 2]);\n            vB = new _math__WEBPACK_IMPORTED_MODULE_2__.Vector3(verts[b], verts[b + 1], verts[b + 2]);\n            vC = new _math__WEBPACK_IMPORTED_MODULE_2__.Vector3(verts[c], verts[c + 1], verts[c + 2]);\n            vA.subVectors(vA, vB);\n            vC.subVectors(vC, vB);\n            vC.cross(vA);\n            //face normal\n            norm = vC;\n            norm.normalize();\n            norms[a] += norm.x;\n            norms[b] += norm.x;\n            norms[c] += norm.x;\n            norms[a + 1] += norm.y;\n            norms[b + 1] += norm.y;\n            norms[c + 1] += norm.y;\n            norms[a + 2] += norm.z;\n            norms[b + 2] += norm.z;\n            norms[c + 2] += norm.z;\n        }\n    }\n    /* sets line index array from face arr\n    Note - assumes all faces are triangles (i.e. there will\n    be an extra diagonal for four-sided faces - user should\n    specify linearr for custom shape generation to show wireframe squares\n    as rectangles rather than two triangles) */\n    setLineIndices() {\n        if (!this.faceidx)\n            return;\n        if (this.lineArray &&\n            this.lineArray.length == this.faceidx * 2 &&\n            this.lineidx == this.faceidx * 2)\n            return; //assume already computed\n        var faceArr = this.faceArray, lineArr = (this.lineArray = new Uint16Array(this.faceidx * 2));\n        this.lineidx = this.faceidx * 2;\n        if (!faceArr)\n            throw new Error(\"face array not initialized\");\n        for (var i = 0; i < this.faceidx / 3; ++i) {\n            var faceoffset = i * 3;\n            var lineoffset = faceoffset * 2;\n            var a = faceArr[faceoffset], b = faceArr[faceoffset + 1], c = faceArr[faceoffset + 2];\n            lineArr[lineoffset] = a;\n            lineArr[lineoffset + 1] = b;\n            lineArr[lineoffset + 2] = a;\n            lineArr[lineoffset + 3] = c;\n            lineArr[lineoffset + 4] = b;\n            lineArr[lineoffset + 5] = c;\n        }\n    }\n    vrml(indent, material) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n        var ret = \"\";\n        ret +=\n            indent +\n                \"Shape {\\n\" +\n                indent +\n                \" appearance Appearance {\\n\" +\n                indent +\n                \"  material Material {\\n\" +\n                indent +\n                \"   diffuseColor \" +\n                ((_a = material === null || material === void 0 ? void 0 : material.color) === null || _a === void 0 ? void 0 : _a.r) +\n                \" \" +\n                ((_b = material === null || material === void 0 ? void 0 : material.color) === null || _b === void 0 ? void 0 : _b.g) +\n                \" \" +\n                ((_c = material === null || material === void 0 ? void 0 : material.color) === null || _c === void 0 ? void 0 : _c.b) +\n                \"\\n\";\n        if (material.wireframe && this.colorArray) {\n            //per vertex colors don't seem to work\n            let c = this.colorArray;\n            ret += indent + \"    emissiveColor \" + c[0] + \" \" + c[1] + \" \" + c[2] + \"\\n\";\n        }\n        if (material === null || material === void 0 ? void 0 : material.transparent) {\n            ret += indent + \"   transparency \" + (1.0 - material.opacity) + \"\\n\";\n        }\n        ret += indent + \"  }\\n\"; //material\n        ret += indent + \" }\\n\"; //appearance\n        var oldindent = indent;\n        indent += \" \"; //inshape\n        if (material instanceof _materials_LineBasicMaterial__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial || material.wireframe) {\n            ret +=\n                indent +\n                    \"geometry IndexedLineSet {\\n\" +\n                    indent +\n                    \" colorPerVertex TRUE\\n\" +\n                    indent +\n                    \" coord Coordinate {\\n\" +\n                    indent +\n                    \"  point [\\n\";\n            let x, y, z;\n            for (let i = 0; i < this.vertices; ++i) {\n                let offset = i * 3;\n                x = (_d = this.vertexArray) === null || _d === void 0 ? void 0 : _d[offset];\n                y = (_e = this.vertexArray) === null || _e === void 0 ? void 0 : _e[offset + 1];\n                z = (_f = this.vertexArray) === null || _f === void 0 ? void 0 : _f[offset + 2];\n                ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n            }\n            ret += indent + \"  ]\\n\";\n            ret += indent + \" }\\n\"; //end coordinate\n            if (this.colorArray && !material.wireframe) {\n                ret += indent + \" color Color {\\n\" + indent + \"  color [\\n\";\n                for (let i = 0; i < this.vertices; ++i) {\n                    let offset = i * 3;\n                    x = this.colorArray[offset];\n                    y = this.colorArray[offset + 1];\n                    z = this.colorArray[offset + 2];\n                    ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n                }\n                ret += indent + \"  ]\\n\";\n                ret += indent + \" }\\n\"; //end color\n            }\n            ret += indent + \" coordIndex [\\n\";\n            if (material.wireframe && this.faceArray) {\n                for (let i = 0; i < this.faceidx; i += 3) {\n                    x = (_g = this.faceArray) === null || _g === void 0 ? void 0 : _g[i];\n                    y = (_h = this.faceArray) === null || _h === void 0 ? void 0 : _h[i + 1];\n                    z = (_j = this.faceArray) === null || _j === void 0 ? void 0 : _j[i + 2];\n                    ret += indent + \"  \" + x + \", \" + y + \", \" + z + \", -1,\\n\";\n                }\n            }\n            else {\n                for (let i = 0; i < this.vertices - 1; i += 2) {\n                    ret += indent + \"  \" + i + \", \" + (i + 1) + \", -1,\\n\";\n                }\n            }\n            ret += indent + \" ]\\n\";\n            ret += indent + \"}\\n\"; //geometry\n        }\n        else {\n            //faces\n            ret +=\n                indent +\n                    \"geometry IndexedFaceSet {\\n\" +\n                    indent +\n                    \" colorPerVertex TRUE\\n\" +\n                    indent +\n                    \" normalPerVertex TRUE\\n\" +\n                    indent +\n                    \" solid FALSE\\n\";\n            //vertices\n            ret += indent + \" coord Coordinate {\\n\" + indent + \"  point [\\n\";\n            let x, y, z;\n            for (let i = 0; i < this.vertices; ++i) {\n                let offset = i * 3;\n                x = (_k = this.vertexArray) === null || _k === void 0 ? void 0 : _k[offset];\n                y = (_l = this.vertexArray) === null || _l === void 0 ? void 0 : _l[offset + 1];\n                z = (_m = this.vertexArray) === null || _m === void 0 ? void 0 : _m[offset + 2];\n                ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n            }\n            ret += indent + \"  ]\\n\";\n            ret += indent + \" }\\n\"; //end coordinate\n            //normals\n            ret += indent + \" normal Normal {\\n\" + indent + \"  vector [\\n\";\n            for (let i = 0; i < this.vertices; ++i) {\n                let offset = i * 3;\n                x = (_o = this.normalArray) === null || _o === void 0 ? void 0 : _o[offset];\n                y = (_p = this.normalArray) === null || _p === void 0 ? void 0 : _p[offset + 1];\n                z = (_q = this.normalArray) === null || _q === void 0 ? void 0 : _q[offset + 2];\n                ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n            }\n            ret += indent + \"  ]\\n\";\n            ret += indent + \" }\\n\"; //end normal\n            //colors\n            if (this.colorArray) {\n                ret += indent + \" color Color {\\n\" + indent + \"  color [\\n\";\n                for (let i = 0; i < this.vertices; ++i) {\n                    let offset = i * 3;\n                    x = this.colorArray[offset];\n                    y = this.colorArray[offset + 1];\n                    z = this.colorArray[offset + 2];\n                    ret += indent + \"   \" + x + \" \" + y + \" \" + z + \",\\n\";\n                }\n                ret += indent + \"  ]\\n\";\n                ret += indent + \" }\\n\"; //end color\n            }\n            //faces\n            ret += indent + \" coordIndex [\\n\";\n            for (let i = 0; i < this.faceidx; i += 3) {\n                x = (_r = this.faceArray) === null || _r === void 0 ? void 0 : _r[i];\n                y = (_s = this.faceArray) === null || _s === void 0 ? void 0 : _s[i + 1];\n                z = (_t = this.faceArray) === null || _t === void 0 ? void 0 : _t[i + 2];\n                ret += indent + \"  \" + x + \", \" + y + \", \" + z + \", -1,\\n\";\n            }\n            ret += indent + \" ]\\n\"; //end faces\n            ret += indent + \"}\\n\"; //geometry\n        }\n        ret += oldindent + \"}\"; //shape\n        return ret;\n    }\n    truncateArrayBuffers(mesh = true, reallocatemem = false) {\n        var vertexArr = this.vertexArray, colorArr = this.colorArray, normalArr = this.normalArray, faceArr = this.faceArray, lineArr = this.lineArray, radiusArr = this.radiusArray;\n        //subarray to avoid copying and reallocating memory\n        this.vertexArray = (vertexArr === null || vertexArr === void 0 ? void 0 : vertexArr.subarray(0, this.vertices * 3)) || null;\n        this.colorArray = (colorArr === null || colorArr === void 0 ? void 0 : colorArr.subarray(0, this.vertices * 3)) || null;\n        if (mesh) {\n            this.normalArray = (normalArr === null || normalArr === void 0 ? void 0 : normalArr.subarray(0, this.vertices * 3)) || null;\n            this.faceArray = (faceArr === null || faceArr === void 0 ? void 0 : faceArr.subarray(0, this.faceidx)) || null;\n            if (this.lineidx > 0)\n                //not always set so reclaim memory\n                this.lineArray = (lineArr === null || lineArr === void 0 ? void 0 : lineArr.subarray(0, this.lineidx)) || null;\n            else\n                this.lineArray = new Uint16Array(0);\n        }\n        else {\n            this.normalArray = new Float32Array(0);\n            this.faceArray = new Uint16Array(0);\n            this.lineArray = new Uint16Array(0);\n        }\n        if (radiusArr) {\n            this.radiusArray = radiusArr.subarray(0, this.vertices);\n        }\n        if (reallocatemem) {\n            //actually copy smaller arrays to save memory\n            if (this.normalArray)\n                this.normalArray = new Float32Array(this.normalArray);\n            if (this.faceArray)\n                this.faceArray = new Uint16Array(this.faceArray);\n            if (this.lineArray)\n                this.lineArray = new Uint16Array(this.lineArray);\n            if (this.vertexArray)\n                this.vertexArray = new Float32Array(this.vertexArray);\n            if (this.colorArray)\n                this.colorArray = new Float32Array(this.colorArray);\n            if (this.radiusArray)\n                this.radiusArray = new Float32Array(this.radiusArray);\n        }\n        this.__inittedArrays = true;\n    }\n}\nclass Geometry extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {\n    constructor(mesh = false, radii = false, offset = false) {\n        super();\n        this.name = \"\";\n        this.hasTangents = false;\n        this.dynamic = true; // the intermediate typed arrays will be deleted when set to false;\n        this.verticesNeedUpdate = false;\n        this.elementsNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.buffersNeedUpdate = false;\n        this.imposter = false;\n        this.instanced = false;\n        this.geometryGroups = [];\n        this.groups = 0;\n        this.id = GeometryIDCount++;\n        this.mesh = mesh; // Does this geometry represent a mesh (i.e. do we need Face/Line index buffers?)\n        this.radii = radii;\n        this.offset = offset; //offset buffer used for instancing\n    }\n    //Get geometry group to accomodate addVertices new vertices - create\n    // new group if necessary\n    updateGeoGroup(addVertices = 0) {\n        var _a;\n        var retGroup = this.groups > 0 ? this.geometryGroups[this.groups - 1] : null;\n        if (!retGroup ||\n            retGroup.vertices + addVertices > (((_a = retGroup === null || retGroup === void 0 ? void 0 : retGroup.vertexArray) === null || _a === void 0 ? void 0 : _a.length) || 0) / 3)\n            retGroup = this.addGeoGroup();\n        return retGroup;\n    }\n    //return comma separated list of IndexedFace (or Line) sets from geometry groups\n    vrml(indent, material) {\n        var ret = \"\";\n        var len = this.geometryGroups.length;\n        for (var g = 0; g < len; g++) {\n            var geoGroup = this.geometryGroups[g];\n            ret += geoGroup.vrml(indent, material) + \",\\n\";\n        }\n        return ret;\n    }\n    addGeoGroup() {\n        var ret = new GeometryGroup(this.geometryGroups.length);\n        this.geometryGroups.push(ret);\n        this.groups = this.geometryGroups.length;\n        ret.vertexArray = new Float32Array(BUFFERSIZE * 3);\n        ret.colorArray = new Float32Array(BUFFERSIZE * 3);\n        //TODO: instantiating uint arrays according to max number of vertices\n        // is dangerous, since there exists the possibility that there will be\n        // more face or line indices than vertex points - but so far that doesn't\n        // seem to be the case for any of the renders\n        if (this.mesh) {\n            ret.normalArray = new Float32Array(BUFFERSIZE * 3);\n            ret.faceArray = new Uint16Array(BUFFERSIZE * 6);\n            ret.lineArray = new Uint16Array(BUFFERSIZE * 6);\n        }\n        if (this.radii) {\n            ret.radiusArray = new Float32Array(BUFFERSIZE);\n        }\n        ret.useOffset = this.offset;\n        return ret;\n    }\n    setUpNormals(...args) {\n        for (var g = 0; g < this.groups; g++) {\n            var geoGroup = this.geometryGroups[g];\n            geoGroup.setNormals(...args);\n        }\n    }\n    setColors(...setcolor) {\n        var len = this.geometryGroups.length;\n        for (var g = 0; g < len; g++) {\n            var geoGroup = this.geometryGroups[g];\n            geoGroup.setColors(...setcolor);\n        }\n    }\n    setUpWireframe(...lineIndexArgs) {\n        for (var g = 0; g < this.groups; g++) {\n            var geoGroup = this.geometryGroups[g];\n            geoGroup.setLineIndices(...lineIndexArgs);\n        }\n    }\n    //After vertices, colors, etc are collected in regular or typed arrays,\n    //  create typed arrays from regular arrays if they don't already exist,\n    initTypedArrays() {\n        for (var g = 0; g < this.groups; g++) {\n            var group = this.geometryGroups[g];\n            if (group.__inittedArrays === true)\n                continue;\n            //do not actually reallocate smaller memory here because\n            //of the performance hit - if you know your geometry is small,\n            //truncate manually with the second parameter true\n            group.truncateArrayBuffers(this.mesh, false);\n        }\n    }\n    dispose() {\n        this.dispatchEvent({ type: \"dispose\" });\n    }\n    get vertices() {\n        var vertices = 0;\n        for (var g = 0; g < this.groups; g++)\n            vertices += this.geometryGroups[g].vertices;\n        return vertices;\n    }\n}\nlet GeometryIDCount = 0;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/core/Geometry.ts?");

/***/ }),

/***/ "./src/WebGL/core/Object3D.ts":
/*!************************************!*\
  !*** ./src/WebGL/core/Object3D.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Light: () => (/* binding */ Light),\n/* harmony export */   Object3D: () => (/* binding */ Object3D),\n/* harmony export */   Object3DIDCount: () => (/* binding */ Object3DIDCount),\n/* harmony export */   Scene: () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n\n\nlet Object3DIDCount = 0;\n// Object3D base constructor function\nclass Object3D {\n    constructor() {\n        this.id = Object3DIDCount++;\n        this.name = \"\";\n        this.children = [];\n        this.position = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.rotation = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.matrix = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.matrixWorld = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.quaternion = new _math__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this.eulerOrder = \"XYZ\";\n        this.up = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        this.scale = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        this.matrixAutoUpdate = true;\n        this.matrixWorldNeedsUpdate = true;\n        this.rotationAutoUpdate = true;\n        this.useQuaternion = false;\n        this.visible = true;\n    }\n    lookAt(vector) {\n        this.matrix.lookAt(vector, this.position, this.up);\n        if (this.rotationAutoUpdate) {\n            if (this.useQuaternion === true)\n                console.error(\"Unimplemented math operation.\");\n            else if (this.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_0__.Vector3)\n                this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder);\n        }\n    }\n    //add child object\n    add(object) {\n        if (object === this) {\n            console.error(\"Can't add $3Dmol.Object3D to itself\");\n            return;\n        }\n        object.parent = this;\n        this.children.push(object);\n        //add to the scene (i.e. follow up this instance's parents until reach the top)\n        var scene = this;\n        while (scene.parent !== undefined)\n            scene = scene.parent;\n        if (scene !== undefined && scene instanceof Scene)\n            scene.__addObject(object);\n    }\n    remove(object) {\n        var index = this.children.indexOf(object);\n        if (index !== -1) {\n            object.parent = undefined;\n            this.children.splice(index, 1);\n            //Remove from scene\n            var scene = this;\n            while (scene.parent !== undefined)\n                scene = scene.parent;\n            if (scene !== undefined && scene instanceof Scene)\n                scene.__removeObject(object);\n        }\n    }\n    //convert to vrml\n    vrml(indent) {\n        //attempt to pretty print\n        if (!indent)\n            indent = \" \";\n        //all objects have a transformation (usually identity)\n        //not quite sure if getting rotation right here..\n        var theta = 2 * Math.atan2(this.quaternion.lengthxyz(), this.quaternion.w);\n        var x = 0, y = 0, z = 0;\n        if (theta != 0) {\n            let st = Math.sin(theta / 2);\n            x = this.quaternion.x / st;\n            y = this.quaternion.y / st;\n            z = this.quaternion.z / st;\n        }\n        var ret = indent +\n            \"Transform {\\n\" +\n            indent +\n            \" center \" +\n            this.position.x +\n            \" \" +\n            this.position.y +\n            \" \" +\n            this.position.z +\n            \"\\n\" +\n            indent +\n            \" rotation \" +\n            x +\n            \" \" +\n            y +\n            \" \" +\n            z +\n            \" \" +\n            theta +\n            \"\\n\" +\n            indent +\n            \" children [\\n\";\n        if (this.geometry) {\n            ret += this.geometry.vrml(indent, this.material);\n        }\n        for (var i = 0; i < this.children.length; i++) {\n            ret += this.children[i].vrml(indent + \" \") + \",\\n\";\n        }\n        ret += \" ]\\n\";\n        ret += \"}\";\n        return ret;\n    }\n    updateMatrix() {\n        this.matrix.setPosition(this.position);\n        if (this.useQuaternion === false && this.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_0__.Vector3) {\n            this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder);\n        }\n        else {\n            this.matrix.setRotationFromQuaternion(this.quaternion);\n        }\n        //TODO: Do I need this??\n        if (this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1)\n            this.matrix.scale(this.scale);\n        this.matrixWorldNeedsUpdate = true;\n    }\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate === true)\n            this.updateMatrix();\n        if (this.matrixWorldNeedsUpdate === true || force === true) {\n            if (this.parent === undefined)\n                this.matrixWorld.copy(this.matrix);\n            else\n                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n        this.matrixWorldNeedsUpdate = false;\n        //Update matrices of all children\n        for (var i = 0; i < this.children.length; i++) {\n            this.children[i].updateMatrixWorld(true);\n        }\n    }\n    clone(object) {\n        if (object === undefined)\n            object = new Object3D();\n        object.name = this.name;\n        object.up.copy(this.up);\n        object.position.copy(this.position);\n        if (object.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_0__.Vector3 &&\n            this.rotation instanceof _math__WEBPACK_IMPORTED_MODULE_0__.Vector3) {\n            object.rotation.copy(this.rotation);\n        }\n        else {\n            object.rotation = this.rotation;\n        }\n        object.eulerOrder = this.eulerOrder;\n        object.scale.copy(this.scale);\n        object.rotationAutoUpdate = this.rotationAutoUpdate;\n        object.matrix.copy(this.matrix);\n        object.matrixWorld.copy(this.matrixWorld);\n        object.quaternion.copy(this.quaternion);\n        object.matrixAutoUpdate = this.matrixAutoUpdate;\n        object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n        object.useQuaternion = this.useQuaternion;\n        object.visible = this.visible;\n        for (var i = 0; i < this.children.length; i++) {\n            var child = this.children[i];\n            object.add(child.clone());\n        }\n        return object;\n    }\n    setVisible(val) {\n        //recursively set visibility\n        this.visible = val;\n        for (var i = 0; i < this.children.length; i++) {\n            var child = this.children[i];\n            child.setVisible(val);\n        }\n    }\n}\n/*\n * Scene class\n */\n/* @constructor */\nclass Scene extends Object3D {\n    constructor() {\n        super(...arguments);\n        this.fog = null;\n        //may not need...\n        this.overrideMaterial = null;\n        this.matrixAutoUpdate = false;\n        this.__objects = [];\n        this.__lights = [];\n        this.__objectsAdded = [];\n        this.__objectsRemoved = [];\n    }\n    __addObject(object) {\n        //Directional Lighting\n        if (object instanceof Light) {\n            if (this.__lights.indexOf(object) === -1)\n                this.__lights.push(object);\n            //TODO: Do I need this??\n            if (object.target && object.target.parent === undefined)\n                this.add(object.target);\n        }\n        //Rotation group\n        else {\n            if (this.__objects.indexOf(object) === -1) {\n                this.__objects.push(object);\n                this.__objectsAdded.push(object);\n                //Check if previously removed\n                var idx = this.__objectsRemoved.indexOf(object);\n                if (idx !== -1)\n                    this.__objectsRemoved.splice(idx, 1);\n            }\n        }\n        //Add object's children\n        for (var i = 0; i < object.children.length; i++)\n            this.__addObject(object.children[i]);\n    }\n    __removeObject(object) {\n        var idx;\n        if (object instanceof Light) {\n            idx = this.__lights.indexOf(object);\n            if (idx !== -1)\n                this.__lights.splice(idx, 1);\n        }\n        //Object3D\n        else {\n            idx = this.__objects.indexOf(object);\n            if (idx !== -1) {\n                this.__objects.splice(idx, 1);\n                this.__objectsRemoved.push(object);\n                //Check if previously added\n                var ai = this.__objectsAdded.indexOf(object);\n                if (ai !== -1)\n                    this.__objectsAdded.splice(idx, 1);\n            }\n        }\n        //Remove object's children\n        for (var i = 0; i < object.children.length; i++)\n            this.__removeObject(object.children[i]);\n    }\n}\nclass Light extends Object3D {\n    constructor(hex, intensity = 1) {\n        super();\n        this.position = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        this.target = new Object3D();\n        this.castShadow = false;\n        this.onlyShadow = false;\n        this.color = new _colors__WEBPACK_IMPORTED_MODULE_1__.Color(hex);\n        this.intensity = intensity;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/core/Object3D.ts?");

/***/ }),

/***/ "./src/WebGL/core/Projector.ts":
/*!*************************************!*\
  !*** ./src/WebGL/core/Projector.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projector: () => (/* binding */ Projector)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n\nconst viewProjectionMatrix = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n//$3Dmol Projection \nclass Projector {\n    static unprojectVector(vector, camera) {\n        camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n        viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);\n        return vector.applyProjection(viewProjectionMatrix);\n    }\n    ;\n    static projectVector(vector, camera) {\n        camera.matrixWorldInverse.getInverse(camera.matrixWorld);\n        viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n        return vector.applyProjection(viewProjectionMatrix);\n    }\n    ;\n    projectVector(vector, camera) {\n        return Projector.projectVector(vector, camera);\n    }\n    unprojectVector(vector, camera) {\n        return Projector.unprojectVector(vector, camera);\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/core/Projector.ts?");

/***/ }),

/***/ "./src/WebGL/core/Raycaster.ts":
/*!*************************************!*\
  !*** ./src/WebGL/core/Raycaster.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Raycaster: () => (/* binding */ Raycaster),\n/* harmony export */   intersectObject: () => (/* binding */ intersectObject)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shapes */ \"./src/WebGL/shapes/index.ts\");\n\n\nconst descSort = (a, b) => {\n    return a.distance - b.distance;\n};\nconst viewProjectionMatrix = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass Raycaster {\n    constructor(origin, direction, far, near) {\n        this.precision = 0.0001;\n        this.linePrecision = 0.2;\n        this.ray = new _math__WEBPACK_IMPORTED_MODULE_0__.Ray(origin, direction);\n        if (this.ray.direction.lengthSq() > 0)\n            this.ray.direction.normalize();\n        this.near = near || 0;\n        this.far = far || Infinity;\n    }\n    set(origin, direction) {\n        this.ray.set(origin, direction);\n    }\n    setFromCamera(coords, camera) {\n        if (!camera.ortho) {\n            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n            this.ray.direction.set(coords.x, coords.y, coords.z);\n            camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n            viewProjectionMatrix.multiplyMatrices(camera.matrixWorld, camera.projectionMatrixInverse);\n            this.ray.direction.applyProjection(viewProjectionMatrix);\n            this.ray.direction.sub(this.ray.origin).normalize();\n        }\n        else {\n            this.ray.origin\n                .set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far))\n                .unproject(camera);\n            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n        }\n    }\n    intersectObjects(group, objects) {\n        var intersects = [];\n        for (var i = 0, l = objects.length; i < l; i++)\n            intersectObject(group, objects[i], this, intersects);\n        intersects.sort(descSort);\n        return intersects;\n    }\n}\n// [-1, 1]\nconst clamp = (x) => {\n    return Math.min(Math.max(x, -1), 1);\n};\nvar sphere = new _shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere();\nvar cylinder = new _shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder();\nvar triangle = new _shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle();\nvar w_0 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(); // for cylinders, cylinder.c1 - ray.origin\nvar v1 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(); // all purpose local vector\nvar v2 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar v3 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nvar matrixPosition = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n//object is a Sphere or (Bounding) Box\nfunction intersectObject(group, clickable, raycaster, intersects) {\n    matrixPosition.getPositionFromMatrix(group.matrixWorld);\n    if (clickable.intersectionShape === undefined)\n        return intersects;\n    var intersectionShape = clickable.intersectionShape;\n    var precision = raycaster.linePrecision;\n    precision *= group.matrixWorld.getMaxScaleOnAxis();\n    var precisionSq = precision * precision;\n    //Check for intersection with clickable's bounding sphere, if it exists\n    if (clickable.boundingSphere !== undefined &&\n        clickable.boundingSphere instanceof _shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere) {\n        sphere.copy(clickable.boundingSphere);\n        sphere.applyMatrix4(group.matrixWorld);\n        if (!raycaster.ray.isIntersectionSphere(sphere)) {\n            return intersects;\n        }\n    }\n    //Iterate through intersection objects\n    var i, il, norm, normProj, cylProj, rayProj, distance, closestDistSq, denom, discriminant, s, t, s_c, t_c;\n    //triangle faces\n    for (i = 0, il = intersectionShape.triangle.length; i < il; i++) {\n        if (intersectionShape.triangle[i] instanceof _shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle) {\n            triangle.copy(intersectionShape.triangle[i]);\n            triangle.applyMatrix4(group.matrixWorld);\n            norm = triangle.getNormal();\n            normProj = raycaster.ray.direction.dot(norm);\n            //face culling\n            if (normProj >= 0)\n                continue;\n            w_0.subVectors(triangle.a, raycaster.ray.origin);\n            distance = norm.dot(w_0) / normProj;\n            if (distance < 0)\n                continue;\n            //intersects with plane, check if P inside triangle\n            v1.copy(raycaster.ray.direction)\n                .multiplyScalar(distance)\n                .add(raycaster.ray.origin);\n            v1.sub(triangle.a); // from pt a to intersection point P\n            v2.copy(triangle.b).sub(triangle.a); // from pt a to b\n            v3.copy(triangle.c).sub(triangle.a); // from pt a to c\n            var b_dot_c = v2.dot(v3);\n            var b_sq = v2.lengthSq();\n            var c_sq = v3.lengthSq();\n            // P = A + s(v2) + t(v3), inside trianle if 0 <= s, t <=1  and (s + t) <=0\n            t =\n                (b_sq * v1.dot(v3) - b_dot_c * v1.dot(v2)) /\n                    (b_sq * c_sq - b_dot_c * b_dot_c);\n            if (t < 0 || t > 1)\n                continue;\n            s = (v1.dot(v2) - t * b_dot_c) / b_sq;\n            if (s < 0 || s > 1 || s + t > 1)\n                continue;\n            else {\n                intersects.push({ clickable: clickable, distance: distance });\n            }\n        }\n    }\n    //cylinders\n    for (i = 0, il = intersectionShape.cylinder.length; i < il; i++) {\n        if (intersectionShape.cylinder[i] instanceof _shapes__WEBPACK_IMPORTED_MODULE_1__.Cylinder) {\n            cylinder.copy(intersectionShape.cylinder[i]);\n            cylinder.applyMatrix4(group.matrixWorld);\n            w_0.subVectors(cylinder.c1, raycaster.ray.origin);\n            cylProj = w_0.dot(cylinder.direction); // Dela\n            rayProj = w_0.dot(raycaster.ray.direction); // Epsilon\n            normProj = clamp(raycaster.ray.direction.dot(cylinder.direction)); // Beta\n            denom = 1 - normProj * normProj;\n            if (denom === 0.0)\n                continue;\n            s_c = (normProj * rayProj - cylProj) / denom;\n            t_c = (rayProj - normProj * cylProj) / denom;\n            v1.copy(cylinder.direction).multiplyScalar(s_c).add(cylinder.c1); // Q_c\n            v2.copy(raycaster.ray.direction)\n                .multiplyScalar(t_c)\n                .add(raycaster.ray.origin); // P_c\n            closestDistSq = v3.subVectors(v1, v2).lengthSq();\n            var radiusSq = cylinder.radius * cylinder.radius;\n            //Smoothing?\n            //if (closestDistSq > radiusSq) radiusSq += precisionSq;\n            // closest distance between ray and cylinder axis not greater than cylinder radius;\n            // might intersect this cylinder between atom and bond midpoint\n            if (closestDistSq <= radiusSq) {\n                //Find points where ray intersects sides of cylinder\n                discriminant =\n                    (normProj * cylProj - rayProj) * (normProj * cylProj - rayProj) -\n                        denom * (w_0.lengthSq() - cylProj * cylProj - radiusSq);\n                // ray tangent to cylinder?\n                if (discriminant <= 0)\n                    t = distance = Math.sqrt(closestDistSq);\n                else\n                    t = distance =\n                        (rayProj - normProj * cylProj - Math.sqrt(discriminant)) / denom;\n                //find closest intersection point; make sure it's between atom's position and cylinder midpoint\n                s = normProj * t - cylProj;\n                //does not intersect cylinder between atom and midpoint,\n                // or intersects cylinder behind camera\n                if (s < 0 || s * s > cylinder.lengthSq() || t < 0)\n                    continue;\n                else\n                    intersects.push({ clickable: clickable, distance: distance });\n            }\n        }\n    }\n    //lines\n    for (i = 0, il = intersectionShape.line.length; i < il; i += 2) {\n        v1.copy(intersectionShape.line[i]);\n        v1.applyMatrix4(group.matrixWorld);\n        v2.copy(intersectionShape.line[i + 1]);\n        v2.applyMatrix4(group.matrixWorld);\n        v3.subVectors(v2, v1);\n        var bondLengthSq = v3.lengthSq();\n        v3.normalize();\n        w_0.subVectors(v1, raycaster.ray.origin);\n        var lineProj = w_0.dot(v3);\n        rayProj = w_0.dot(raycaster.ray.direction);\n        normProj = clamp(raycaster.ray.direction.dot(v3));\n        denom = 1 - normProj * normProj;\n        if (denom === 0.0)\n            continue;\n        s_c = (normProj * rayProj - lineProj) / denom;\n        t_c = (rayProj - normProj * lineProj) / denom;\n        v1.add(v3.multiplyScalar(s_c)); // Q_c\n        v2.copy(raycaster.ray.direction)\n            .multiplyScalar(t_c)\n            .add(raycaster.ray.origin); // P_c\n        closestDistSq = v3.subVectors(v2, v1).lengthSq();\n        if (closestDistSq < precisionSq && s_c * s_c < bondLengthSq)\n            intersects.push({ clickable: clickable, distance: t_c });\n    }\n    for (i = 0, il = intersectionShape.sphere.length; i < il; i++) {\n        //sphere\n        if (intersectionShape.sphere[i] instanceof _shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere) {\n            sphere.copy(intersectionShape.sphere[i]);\n            sphere.applyMatrix4(group.matrixWorld);\n            if (raycaster.ray.isIntersectionSphere(sphere)) {\n                v1.subVectors(sphere.center, raycaster.ray.origin);\n                //distance from ray origin to point on the ray normal to sphere's center\n                //must be less than sphere's radius (since ray intersects sphere)\n                var distanceToCenter = v1.dot(raycaster.ray.direction);\n                discriminant =\n                    distanceToCenter * distanceToCenter -\n                        (v1.lengthSq() - sphere.radius * sphere.radius);\n                //Don't select if sphere center behind camera\n                if (distanceToCenter < 0)\n                    return intersects;\n                //ray tangent to sphere?\n                if (discriminant <= 0)\n                    distance = distanceToCenter;\n                //This is reversed if sphere is closer than ray origin.  Do we have\n                //to worry about handling that case?\n                else\n                    distance = distanceToCenter - Math.sqrt(discriminant);\n                intersects.push({ clickable: clickable, distance: distance });\n            }\n        }\n    }\n    return intersects;\n}\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/core/Raycaster.ts?");

/***/ }),

/***/ "./src/WebGL/core/Texture.ts":
/*!***********************************!*\
  !*** ./src/WebGL/core/Texture.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Texture: () => (/* binding */ Texture),\n/* harmony export */   TextureIdCount: () => (/* binding */ TextureIdCount)\n/* harmony export */ });\n/* harmony import */ var _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/TextureConstants */ \"./src/WebGL/constants/TextureConstants.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventDispatcher */ \"./src/WebGL/core/EventDispatcher.ts\");\n/* harmony import */ var _UVMapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UVMapping */ \"./src/WebGL/core/UVMapping.ts\");\n//Texture\n//We really only create textures from 2d rendering contexts (to display text labels)\n//edit: we can now create 3dtextures using volumetric data\n\n\n\n\n/* @constructor */\nclass Texture extends _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__.EventDispatcher {\n    constructor(image, is3D) {\n        super();\n        this.id = TextureIdCount++;\n        this.name = \"\";\n        this.image = image;\n        this.mapping = new _UVMapping__WEBPACK_IMPORTED_MODULE_3__.UVMapping();\n        this.wrapS = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n        this.wrapT = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping;\n        this.anisotropy = 1;\n        if (is3D) {\n            this.format = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.RFormat;\n            this.type = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n            this.premultiplyAlpha = false;\n            this.flipY = false;\n            this.unpackAlignment = 1;\n            this.magFilter = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n            this.minFilter = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.NearestFilter;\n        }\n        else {\n            this.format = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n            this.type = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType;\n            this.offset = new _math__WEBPACK_IMPORTED_MODULE_1__.Vector2(0, 0);\n            this.repeat = new _math__WEBPACK_IMPORTED_MODULE_1__.Vector2(1, 1);\n            this.premultiplyAlpha = false;\n            this.flipY = true;\n            this.unpackAlignment = 4;\n            this.magFilter = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            this.minFilter = _constants_TextureConstants__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter;\n        }\n        this.needsUpdate = false;\n        this.onUpdate = null;\n    }\n    clone(texture = new Texture()) {\n        texture.image = this.image;\n        texture.mapping = this.mapping;\n        texture.wrapS = this.wrapS;\n        texture.wrapT = this.wrapT;\n        texture.magFilter = this.magFilter;\n        texture.minFilter = this.minFilter;\n        texture.anisotropy = this.anisotropy;\n        texture.format = this.format;\n        texture.type = this.type;\n        texture.offset.copy(this.offset);\n        texture.repeat.copy(this.repeat);\n        texture.premultiplyAlpha = this.premultiplyAlpha;\n        texture.flipY = this.flipY;\n        texture.unpackAlignment = this.unpackAlignment;\n        return texture;\n    }\n    dispose() {\n        this.dispatchEvent({ type: \"dispose\" });\n    }\n}\nlet TextureIdCount = 0;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/core/Texture.ts?");

/***/ }),

/***/ "./src/WebGL/core/UVMapping.ts":
/*!*************************************!*\
  !*** ./src/WebGL/core/UVMapping.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UVMapping: () => (/* binding */ UVMapping)\n/* harmony export */ });\n// mapping modes\nclass UVMapping {\n}\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/core/UVMapping.ts?");

/***/ }),

/***/ "./src/WebGL/core/index.ts":
/*!*********************************!*\
  !*** ./src/WebGL/core/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDispatcher: () => (/* reexport safe */ _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher),\n/* harmony export */   Geometry: () => (/* reexport safe */ _Geometry__WEBPACK_IMPORTED_MODULE_1__.Geometry),\n/* harmony export */   GeometryGroup: () => (/* reexport safe */ _Geometry__WEBPACK_IMPORTED_MODULE_1__.GeometryGroup),\n/* harmony export */   GeometryIDCount: () => (/* reexport safe */ _Geometry__WEBPACK_IMPORTED_MODULE_1__.GeometryIDCount),\n/* harmony export */   Light: () => (/* reexport safe */ _Object3D__WEBPACK_IMPORTED_MODULE_2__.Light),\n/* harmony export */   Object3D: () => (/* reexport safe */ _Object3D__WEBPACK_IMPORTED_MODULE_2__.Object3D),\n/* harmony export */   Object3DIDCount: () => (/* reexport safe */ _Object3D__WEBPACK_IMPORTED_MODULE_2__.Object3DIDCount),\n/* harmony export */   Projector: () => (/* reexport safe */ _Projector__WEBPACK_IMPORTED_MODULE_3__.Projector),\n/* harmony export */   Raycaster: () => (/* reexport safe */ _Raycaster__WEBPACK_IMPORTED_MODULE_4__.Raycaster),\n/* harmony export */   Scene: () => (/* reexport safe */ _Object3D__WEBPACK_IMPORTED_MODULE_2__.Scene),\n/* harmony export */   Texture: () => (/* reexport safe */ _Texture__WEBPACK_IMPORTED_MODULE_5__.Texture),\n/* harmony export */   TextureIdCount: () => (/* reexport safe */ _Texture__WEBPACK_IMPORTED_MODULE_5__.TextureIdCount),\n/* harmony export */   UVMapping: () => (/* reexport safe */ _UVMapping__WEBPACK_IMPORTED_MODULE_6__.UVMapping),\n/* harmony export */   intersectObject: () => (/* reexport safe */ _Raycaster__WEBPACK_IMPORTED_MODULE_4__.intersectObject)\n/* harmony export */ });\n/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher */ \"./src/WebGL/core/EventDispatcher.ts\");\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Geometry */ \"./src/WebGL/core/Geometry.ts\");\n/* harmony import */ var _Object3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object3D */ \"./src/WebGL/core/Object3D.ts\");\n/* harmony import */ var _Projector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Projector */ \"./src/WebGL/core/Projector.ts\");\n/* harmony import */ var _Raycaster__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Raycaster */ \"./src/WebGL/core/Raycaster.ts\");\n/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Texture */ \"./src/WebGL/core/Texture.ts\");\n/* harmony import */ var _UVMapping__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UVMapping */ \"./src/WebGL/core/UVMapping.ts\");\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/core/index.ts?");

/***/ }),

/***/ "./src/WebGL/index.ts":
/*!****************************!*\
  !*** ./src/WebGL/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackSide: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.BackSide),\n/* harmony export */   Camera: () => (/* reexport safe */ _Camera__WEBPACK_IMPORTED_MODULE_7__.Camera),\n/* harmony export */   ClampToEdgeWrapping: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping),\n/* harmony export */   Coloring: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.Coloring),\n/* harmony export */   Cylinder: () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_6__.Cylinder),\n/* harmony export */   DoubleSide: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.DoubleSide),\n/* harmony export */   EventDispatcher: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher),\n/* harmony export */   FloatType: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.FloatType),\n/* harmony export */   Fog: () => (/* reexport safe */ _Fog__WEBPACK_IMPORTED_MODULE_8__.Fog),\n/* harmony export */   FrontSide: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.FrontSide),\n/* harmony export */   Geometry: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.Geometry),\n/* harmony export */   GeometryGroup: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.GeometryGroup),\n/* harmony export */   GeometryIDCount: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.GeometryIDCount),\n/* harmony export */   ImposterMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.ImposterMaterial),\n/* harmony export */   InstancedMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.InstancedMaterial),\n/* harmony export */   Light: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.Light),\n/* harmony export */   Line: () => (/* reexport safe */ _objects__WEBPACK_IMPORTED_MODULE_4__.Line),\n/* harmony export */   LineBasicMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial),\n/* harmony export */   LineStyle: () => (/* reexport safe */ _objects__WEBPACK_IMPORTED_MODULE_4__.LineStyle),\n/* harmony export */   LinearFilter: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.LinearFilter),\n/* harmony export */   LinearMipMapLinearFilter: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter),\n/* harmony export */   Material: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.Material),\n/* harmony export */   MaterialIdCount: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.MaterialIdCount),\n/* harmony export */   Matrix3: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.Matrix3),\n/* harmony export */   Matrix4: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.Matrix4),\n/* harmony export */   Mesh: () => (/* reexport safe */ _objects__WEBPACK_IMPORTED_MODULE_4__.Mesh),\n/* harmony export */   MeshDoubleLambertMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.MeshDoubleLambertMaterial),\n/* harmony export */   MeshLambertMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.MeshLambertMaterial),\n/* harmony export */   MeshOutlineMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.MeshOutlineMaterial),\n/* harmony export */   NearestFilter: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.NearestFilter),\n/* harmony export */   Object3D: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.Object3D),\n/* harmony export */   Object3DIDCount: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.Object3DIDCount),\n/* harmony export */   Projector: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.Projector),\n/* harmony export */   Quaternion: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.Quaternion),\n/* harmony export */   R32Format: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.R32Format),\n/* harmony export */   RFormat: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.RFormat),\n/* harmony export */   RGBAFormat: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat),\n/* harmony export */   Ray: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.Ray),\n/* harmony export */   Raycaster: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.Raycaster),\n/* harmony export */   Renderer: () => (/* reexport safe */ _Renderer__WEBPACK_IMPORTED_MODULE_9__.Renderer),\n/* harmony export */   Scene: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.Scene),\n/* harmony export */   ShaderLib: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.ShaderLib),\n/* harmony export */   ShaderUtils: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.ShaderUtils),\n/* harmony export */   Shading: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.Shading),\n/* harmony export */   Sphere: () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_6__.Sphere),\n/* harmony export */   SphereImposterMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.SphereImposterMaterial),\n/* harmony export */   SphereImposterOutlineMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.SphereImposterOutlineMaterial),\n/* harmony export */   Sprite: () => (/* reexport safe */ _objects__WEBPACK_IMPORTED_MODULE_4__.Sprite),\n/* harmony export */   SpriteAlignment: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment),\n/* harmony export */   SpriteMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.SpriteMaterial),\n/* harmony export */   SpritePlugin: () => (/* reexport safe */ _SpritePlugin__WEBPACK_IMPORTED_MODULE_10__.SpritePlugin),\n/* harmony export */   StickImposterMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.StickImposterMaterial),\n/* harmony export */   StickImposterOutlineMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.StickImposterOutlineMaterial),\n/* harmony export */   Texture: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.Texture),\n/* harmony export */   TextureIdCount: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.TextureIdCount),\n/* harmony export */   TextureOperations: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.TextureOperations),\n/* harmony export */   Triangle: () => (/* reexport safe */ _shapes__WEBPACK_IMPORTED_MODULE_6__.Triangle),\n/* harmony export */   UVMapping: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.UVMapping),\n/* harmony export */   UnsignedByteType: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType),\n/* harmony export */   Vector2: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.Vector2),\n/* harmony export */   Vector3: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.Vector3),\n/* harmony export */   VolumetricMaterial: () => (/* reexport safe */ _materials__WEBPACK_IMPORTED_MODULE_2__.VolumetricMaterial),\n/* harmony export */   basic: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.basic),\n/* harmony export */   clamp: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.clamp),\n/* harmony export */   clone: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.clone),\n/* harmony export */   conversionMatrix3: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.conversionMatrix3),\n/* harmony export */   degToRad: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.degToRad),\n/* harmony export */   instanced: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.instanced),\n/* harmony export */   intersectObject: () => (/* reexport safe */ _core__WEBPACK_IMPORTED_MODULE_1__.intersectObject),\n/* harmony export */   lambert: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.lambert),\n/* harmony export */   lambertdouble: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.lambertdouble),\n/* harmony export */   outline: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.outline),\n/* harmony export */   screen: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.screen),\n/* harmony export */   screenaa: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.screenaa),\n/* harmony export */   sphereimposter: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.sphereimposter),\n/* harmony export */   sphereimposteroutline: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.sphereimposteroutline),\n/* harmony export */   sprite: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.sprite),\n/* harmony export */   stickimposter: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.stickimposter),\n/* harmony export */   stickimposteroutline: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.stickimposteroutline),\n/* harmony export */   volumetric: () => (/* reexport safe */ _shaders__WEBPACK_IMPORTED_MODULE_5__.volumetric)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/WebGL/constants/index.ts\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ \"./src/WebGL/core/index.ts\");\n/* harmony import */ var _materials__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./materials */ \"./src/WebGL/materials/index.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./objects */ \"./src/WebGL/objects/index.ts\");\n/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shaders */ \"./src/WebGL/shaders/index.ts\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shapes */ \"./src/WebGL/shapes/index.ts\");\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Camera */ \"./src/WebGL/Camera.ts\");\n/* harmony import */ var _Fog__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Fog */ \"./src/WebGL/Fog.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Renderer */ \"./src/WebGL/Renderer.ts\");\n/* harmony import */ var _SpritePlugin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SpritePlugin */ \"./src/WebGL/SpritePlugin.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/index.ts?");

/***/ }),

/***/ "./src/WebGL/materials/ImposterMaterial.ts":
/*!*************************************************!*\
  !*** ./src/WebGL/materials/ImposterMaterial.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImposterMaterial: () => (/* binding */ ImposterMaterial)\n/* harmony export */ });\n/* harmony import */ var _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../constants/Coloring */ \"./src/WebGL/constants/Coloring.ts\");\n/* harmony import */ var _constants_Shading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../constants/Shading */ \"./src/WebGL/constants/Shading.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Material */ \"./src/WebGL/materials/Material.ts\");\n\n\n\n\n\n//Imposter material\n/* @constructor */\nclass ImposterMaterial extends _Material__WEBPACK_IMPORTED_MODULE_4__.Material {\n    constructor(parameters) {\n        super();\n        this.color = new _colors__WEBPACK_IMPORTED_MODULE_2__.Color(0xffffff);\n        this.ambient = new _colors__WEBPACK_IMPORTED_MODULE_2__.Color(0xfffff);\n        this.emissive = new _colors__WEBPACK_IMPORTED_MODULE_2__.Color(0x000000);\n        this.imposter = true;\n        //TODO: Which of these instance variables do I really need?\n        this.wrapAround = false;\n        this.wrapRGB = new _math__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 1, 1);\n        this.map = undefined;\n        this.lightMap = null;\n        this.specularMap = null;\n        this.envMap = null;\n        this.reflectivity = 1;\n        this.refractionRatio = 0.98;\n        this.fog = true;\n        this.wireframe = false;\n        this.wireframeLinewidth = 1;\n        this.wireframeLinecap = \"round\";\n        this.wireframeLinejoin = \"round\";\n        this.shading = _constants_Shading__WEBPACK_IMPORTED_MODULE_1__.Shading.SmoothShading;\n        this.shaderID = null;\n        this.vertexColors = _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__.Coloring.NoColors;\n        this.skinning = false;\n        this.setValues(parameters);\n    }\n    clone(material = new ImposterMaterial()) {\n        super.clone.call(this, material);\n        material.color.copy(this.color);\n        material.ambient.copy(this.ambient);\n        material.emissive.copy(this.emissive);\n        material.wrapAround = this.wrapAround;\n        material.wrapRGB.copy(this.wrapRGB);\n        material.map = this.map;\n        material.lightMap = this.lightMap;\n        material.specularMap = this.specularMap;\n        material.envMap = this.envMap;\n        material.combine = this.combine;\n        material.reflectivity = this.reflectivity;\n        material.refractionRatio = this.refractionRatio;\n        material.fog = this.fog;\n        material.shading = this.shading;\n        material.shaderID = this.shaderID;\n        material.vertexColors = this.vertexColors;\n        material.skinning = this.skinning;\n        material.morphTargets = this.morphTargets;\n        material.morphNormals = this.morphNormals;\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/ImposterMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/InstancedMaterial.ts":
/*!**************************************************!*\
  !*** ./src/WebGL/materials/InstancedMaterial.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InstancedMaterial: () => (/* binding */ InstancedMaterial)\n/* harmony export */ });\n/* harmony import */ var _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/Coloring */ \"./src/WebGL/constants/Coloring.ts\");\n/* harmony import */ var _constants_Shading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/Shading */ \"./src/WebGL/constants/Shading.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Material */ \"./src/WebGL/materials/Material.ts\");\n\n\n\n\n\nclass InstancedMaterial extends _Material__WEBPACK_IMPORTED_MODULE_4__.Material {\n    constructor(parameters) {\n        super();\n        this.color = new _colors__WEBPACK_IMPORTED_MODULE_2__.Color(0xffffff);\n        this.ambient = new _colors__WEBPACK_IMPORTED_MODULE_2__.Color(0xfffff);\n        this.emissive = new _colors__WEBPACK_IMPORTED_MODULE_2__.Color(0x000000);\n        //TODO: Which of these instance variables do I really need?\n        this.wrapAround = false;\n        this.wrapRGB = new _math__WEBPACK_IMPORTED_MODULE_3__.Vector3(1, 1, 1);\n        this.map = undefined;\n        this.lightMap = null;\n        this.specularMap = null;\n        this.envMap = null;\n        this.reflectivity = 1;\n        this.refractionRatio = 0.98;\n        this.fog = true;\n        this.wireframe = false;\n        this.wireframeLinewidth = 1;\n        this.wireframeLinecap = \"round\";\n        this.wireframeLinejoin = \"round\";\n        this.shading = _constants_Shading__WEBPACK_IMPORTED_MODULE_1__.Shading.SmoothShading;\n        this.shaderID = \"instanced\";\n        this.vertexColors = _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__.Coloring.NoColors;\n        this.skinning = false;\n        this.sphere = null;\n        this.setValues(parameters);\n    }\n    clone(material = new InstancedMaterial()) {\n        super.clone.call(this, material);\n        material.color.copy(this.color);\n        material.ambient.copy(this.ambient);\n        material.emissive.copy(this.emissive);\n        material.wrapAround = this.wrapAround;\n        material.wrapRGB.copy(this.wrapRGB);\n        material.map = this.map;\n        material.lightMap = this.lightMap;\n        material.specularMap = this.specularMap;\n        material.envMap = this.envMap;\n        material.combine = this.combine;\n        material.reflectivity = this.reflectivity;\n        material.refractionRatio = this.refractionRatio;\n        material.fog = this.fog;\n        material.shading = this.shading;\n        material.shaderID = this.shaderID;\n        material.vertexColors = this.vertexColors;\n        material.skinning = this.skinning;\n        material.morphTargets = this.morphTargets;\n        material.morphNormals = this.morphNormals;\n        material.sphere = this.sphere;\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/InstancedMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/LineBasicMaterial.ts":
/*!**************************************************!*\
  !*** ./src/WebGL/materials/LineBasicMaterial.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineBasicMaterial: () => (/* binding */ LineBasicMaterial)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Material */ \"./src/WebGL/materials/Material.ts\");\n\n\n//Line basic material\n/* @constructor */\nclass LineBasicMaterial extends _Material__WEBPACK_IMPORTED_MODULE_1__.Material {\n    constructor(parameters) {\n        super();\n        this.color = new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0xffffff);\n        this.linewidth = 1;\n        this.linecap = \"round\";\n        this.linejoin = \"round\";\n        this.vertexColors = false;\n        this.fog = true;\n        this.shaderID = \"basic\";\n        this.setValues(parameters);\n    }\n    clone(material = new LineBasicMaterial()) {\n        super.clone.call(this, material);\n        material.color.copy(this.color);\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/LineBasicMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/Material.ts":
/*!*****************************************!*\
  !*** ./src/WebGL/materials/Material.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Material: () => (/* binding */ Material),\n/* harmony export */   MaterialIdCount: () => (/* binding */ MaterialIdCount)\n/* harmony export */ });\n/* harmony import */ var _constants_Sides__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/Sides */ \"./src/WebGL/constants/Sides.ts\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core */ \"./src/WebGL/core/index.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n\n\n\n\n/*\n * Line and Mesh material types\n * @constructor\n */\nclass Material extends _core__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {\n    constructor() {\n        super(...arguments);\n        this.id = MaterialIdCount++;\n        this.name = \"\";\n        this.side = _constants_Sides__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n        this.opacity = 1;\n        this.transparent = false;\n        this.depthTest = true;\n        this.depthWrite = true;\n        this.stencilTest = true;\n        this.polygonOffset = false;\n        this.polygonOffsetFactor = 0;\n        this.polygonOffsetUnits = 0;\n        this.alphaTest = 0;\n        this.visible = true;\n        this.needsUpdate = true;\n        this.outline = false;\n        this.wireframe = false;\n    }\n    setValues(values = {}) {\n        if (values === undefined)\n            return;\n        for (var key in values) {\n            var newValue = values[key];\n            if (newValue === undefined) {\n                console.warn(\"$3Dmol.Material: '\" + key + \"' parameter is undefined.\");\n                continue;\n            }\n            if (key in this) {\n                var currentValue = this[key];\n                if (currentValue instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color && newValue instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color) {\n                    currentValue.copy(newValue);\n                }\n                else if (currentValue instanceof _colors__WEBPACK_IMPORTED_MODULE_3__.Color) {\n                    currentValue.set(newValue);\n                }\n                else if (currentValue instanceof _math__WEBPACK_IMPORTED_MODULE_2__.Vector3 &&\n                    newValue instanceof _math__WEBPACK_IMPORTED_MODULE_2__.Vector3) {\n                    currentValue.copy(newValue);\n                }\n                else {\n                    this[key] = newValue;\n                }\n            }\n        }\n    }\n    //TODO: might want to look into blending equations\n    clone(material = new Material()) {\n        material.name = this.name;\n        material.side = this.side;\n        material.opacity = this.opacity;\n        material.transparent = this.transparent;\n        material.depthTest = this.depthTest;\n        material.depthWrite = this.depthWrite;\n        material.stencilTest = this.stencilTest;\n        material.polygonOffset = this.polygonOffset;\n        material.polygonOffsetFactor = this.polygonOffsetFactor;\n        material.polygonOffsetUnits = this.polygonOffsetUnits;\n        material.alphaTest = this.alphaTest;\n        material.overdraw = this.overdraw;\n        material.visible = this.visible;\n        return material;\n    }\n    dispose() {\n        this.dispatchEvent({ type: \"dispose\" });\n    }\n}\nlet MaterialIdCount = 0;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/Material.ts?");

/***/ }),

/***/ "./src/WebGL/materials/MeshDoubleLambertMaterial.ts":
/*!**********************************************************!*\
  !*** ./src/WebGL/materials/MeshDoubleLambertMaterial.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshDoubleLambertMaterial: () => (/* binding */ MeshDoubleLambertMaterial)\n/* harmony export */ });\n/* harmony import */ var _constants_Sides__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../constants/Sides */ \"./src/WebGL/constants/Sides.ts\");\n/* harmony import */ var _MeshLambertMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MeshLambertMaterial */ \"./src/WebGL/materials/MeshLambertMaterial.ts\");\n\n\n//Double sided Mesh Lambert material\n/* @constructor */\nclass MeshDoubleLambertMaterial extends _MeshLambertMaterial__WEBPACK_IMPORTED_MODULE_1__.MeshLambertMaterial {\n    constructor(parameters) {\n        super(parameters);\n        this.shaderID = \"lambertdouble\";\n        this.side = _constants_Sides__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        this.outline = false;\n    }\n    clone(material = new MeshDoubleLambertMaterial()) {\n        super.clone.call(this, material);\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/MeshDoubleLambertMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/MeshLambertMaterial.ts":
/*!****************************************************!*\
  !*** ./src/WebGL/materials/MeshLambertMaterial.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshLambertMaterial: () => (/* binding */ MeshLambertMaterial)\n/* harmony export */ });\n/* harmony import */ var _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../constants/Coloring */ \"./src/WebGL/constants/Coloring.ts\");\n/* harmony import */ var _constants_Shading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../constants/Shading */ \"./src/WebGL/constants/Shading.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Material */ \"./src/WebGL/materials/Material.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n\n\n\n//Mesh Lambert material\n\n\n/* @constructor */\nclass MeshLambertMaterial extends _Material__WEBPACK_IMPORTED_MODULE_2__.Material {\n    constructor(parameters) {\n        super();\n        this.color = new _colors__WEBPACK_IMPORTED_MODULE_3__.Color(0xffffff);\n        this.ambient = new _colors__WEBPACK_IMPORTED_MODULE_3__.Color(0xfffff);\n        this.emissive = new _colors__WEBPACK_IMPORTED_MODULE_3__.Color(0x000000);\n        //TODO: Which of these instance variables do I really need?\n        this.wrapAround = false;\n        this.wrapRGB = new _math__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 1, 1);\n        this.map = undefined;\n        this.lightMap = null;\n        this.specularMap = null;\n        this.envMap = null;\n        this.reflectivity = 1;\n        this.refractionRatio = 0.98;\n        this.fog = true;\n        this.wireframe = false;\n        this.wireframeLinewidth = 1;\n        this.wireframeLinecap = \"round\";\n        this.wireframeLinejoin = \"round\";\n        this.shading = _constants_Shading__WEBPACK_IMPORTED_MODULE_1__.Shading.SmoothShading;\n        this.shaderID = \"lambert\";\n        this.vertexColors = _constants_Coloring__WEBPACK_IMPORTED_MODULE_0__.Coloring.NoColors;\n        this.skinning = false;\n        this.setValues(parameters);\n    }\n    clone(material = new MeshLambertMaterial()) {\n        super.clone.call(this, material);\n        material.color.copy(this.color);\n        material.ambient.copy(this.ambient);\n        material.emissive.copy(this.emissive);\n        material.wrapAround = this.wrapAround;\n        material.wrapRGB.copy(this.wrapRGB);\n        material.map = this.map;\n        material.lightMap = this.lightMap;\n        material.specularMap = this.specularMap;\n        material.envMap = this.envMap;\n        material.combine = this.combine;\n        material.reflectivity = this.reflectivity;\n        material.refractionRatio = this.refractionRatio;\n        material.fog = this.fog;\n        material.shading = this.shading;\n        material.shaderID = this.shaderID;\n        material.vertexColors = this.vertexColors;\n        material.skinning = this.skinning;\n        material.morphTargets = this.morphTargets;\n        material.morphNormals = this.morphNormals;\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/MeshLambertMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/MeshOutlineMaterial.ts":
/*!****************************************************!*\
  !*** ./src/WebGL/materials/MeshOutlineMaterial.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshOutlineMaterial: () => (/* binding */ MeshOutlineMaterial)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Material */ \"./src/WebGL/materials/Material.ts\");\n\n\n//Outlined Mesh Lamert material\n/* @constructor */\nclass MeshOutlineMaterial extends _Material__WEBPACK_IMPORTED_MODULE_1__.Material {\n    constructor(parameters) {\n        super();\n        parameters = parameters || {};\n        this.fog = true;\n        this.shaderID = \"outline\";\n        this.wireframe = false;\n        this.outlineColor = parameters.color || new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0);\n        this.outlineWidth = parameters.width || 0.1;\n        this.outlinePushback = parameters.pushback || 1.0;\n    }\n    clone(material = new MeshOutlineMaterial()) {\n        super.clone.call(this, material);\n        material.fog = this.fog;\n        material.shaderID = this.shaderID;\n        material.wireframe = this.wireframe;\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/MeshOutlineMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/SphereImposterMaterial.ts":
/*!*******************************************************!*\
  !*** ./src/WebGL/materials/SphereImposterMaterial.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SphereImposterMaterial: () => (/* binding */ SphereImposterMaterial)\n/* harmony export */ });\n/* harmony import */ var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImposterMaterial */ \"./src/WebGL/materials/ImposterMaterial.ts\");\n\nclass SphereImposterMaterial extends _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__.ImposterMaterial {\n    constructor(parameters) {\n        super(parameters);\n        this.shaderID = \"sphereimposter\";\n        this.setValues(parameters);\n    }\n    clone(material = new SphereImposterMaterial()) {\n        super.clone.call(this, material);\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/SphereImposterMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/SphereImposterOutlineMaterial.ts":
/*!**************************************************************!*\
  !*** ./src/WebGL/materials/SphereImposterOutlineMaterial.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SphereImposterOutlineMaterial: () => (/* binding */ SphereImposterOutlineMaterial)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImposterMaterial */ \"./src/WebGL/materials/ImposterMaterial.ts\");\n\n\nclass SphereImposterOutlineMaterial extends _ImposterMaterial__WEBPACK_IMPORTED_MODULE_1__.ImposterMaterial {\n    constructor(parameters) {\n        super(parameters);\n        parameters = parameters || {};\n        this.shaderID = \"sphereimposteroutline\";\n        this.outlineColor = parameters.color || new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0);\n        this.outlineWidth = parameters.width || 0.1;\n        this.outlinePushback = parameters.pushback || 1.0;\n        this.setValues(parameters);\n    }\n    clone(material = new SphereImposterOutlineMaterial()) {\n        super.clone.call(this, material);\n        material.outlineColor = this.outlineColor;\n        material.outlineWidth = this.outlineWidth;\n        material.outlinePushback = this.outlinePushback;\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/SphereImposterOutlineMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/SpriteMaterial.ts":
/*!***********************************************!*\
  !*** ./src/WebGL/materials/SpriteMaterial.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpriteMaterial: () => (/* binding */ SpriteMaterial)\n/* harmony export */ });\n/* harmony import */ var _constants_SpriteAlignment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/SpriteAlignment */ \"./src/WebGL/constants/SpriteAlignment.ts\");\n/* harmony import */ var _core_Texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Texture */ \"./src/WebGL/core/Texture.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Material */ \"./src/WebGL/materials/Material.ts\");\n\n\n\n\n\nclass SpriteMaterial extends _Material__WEBPACK_IMPORTED_MODULE_4__.Material {\n    constructor(parameters) {\n        super();\n        this.color = new _colors__WEBPACK_IMPORTED_MODULE_2__.Color(0xffffff);\n        this.map = new _core_Texture__WEBPACK_IMPORTED_MODULE_1__.Texture();\n        this.useScreenCoordinates = true;\n        this.fog = false; // use scene fog\n        this.uvOffset = new _math__WEBPACK_IMPORTED_MODULE_3__.Vector2(0, 0);\n        this.uvScale = new _math__WEBPACK_IMPORTED_MODULE_3__.Vector2(1, 1);\n        this.depthTest = !this.useScreenCoordinates;\n        this.sizeAttenuation = !this.useScreenCoordinates;\n        this.screenOffset = this.screenOffset;\n        this.scaleByViewPort = !this.sizeAttenuation;\n        this.alignment = _constants_SpriteAlignment__WEBPACK_IMPORTED_MODULE_0__.SpriteAlignment.center.clone();\n        this.setValues(parameters);\n        parameters = parameters || {};\n        if (parameters.depthTest === undefined)\n            this.depthTest = !this.useScreenCoordinates;\n        if (parameters.sizeAttenuation === undefined)\n            this.sizeAttenuation = !this.useScreenCoordinates;\n        if (parameters.scaleByViewPort === undefined)\n            this.scaleByViewPort = !this.sizeAttenuation;\n    }\n    clone(material = new SpriteMaterial()) {\n        super.clone.call(this, material);\n        material.color.copy(this.color);\n        material.map = this.map;\n        material.useScreenCoordinates = this.useScreenCoordinates;\n        material.screenOffset = this.screenOffset;\n        material.sizeAttenuation = this.sizeAttenuation;\n        material.scaleByViewport = this.scaleByViewPort;\n        material.alignment.copy(this.alignment);\n        material.uvOffset.copy(this.uvOffset);\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/SpriteMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/StickImposterMaterial.ts":
/*!******************************************************!*\
  !*** ./src/WebGL/materials/StickImposterMaterial.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StickImposterMaterial: () => (/* binding */ StickImposterMaterial)\n/* harmony export */ });\n/* harmony import */ var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImposterMaterial */ \"./src/WebGL/materials/ImposterMaterial.ts\");\n\nclass StickImposterMaterial extends _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__.ImposterMaterial {\n    constructor(parameters) {\n        super(parameters);\n        this.shaderID = \"stickimposter\";\n        this.setValues(parameters);\n    }\n    clone(material = new StickImposterMaterial()) {\n        super.clone.call(this, material);\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/StickImposterMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/StickImposterOutlineMaterial.ts":
/*!*************************************************************!*\
  !*** ./src/WebGL/materials/StickImposterOutlineMaterial.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StickImposterOutlineMaterial: () => (/* binding */ StickImposterOutlineMaterial)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImposterMaterial */ \"./src/WebGL/materials/ImposterMaterial.ts\");\n\n\nclass StickImposterOutlineMaterial extends _ImposterMaterial__WEBPACK_IMPORTED_MODULE_1__.ImposterMaterial {\n    constructor(parameters = {}) {\n        super(parameters);\n        this.shaderID = \"stickimposteroutline\";\n        this.outlineColor = new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0);\n        this.outlineWidth = 0.1;\n        this.outlinePushback = 1.0;\n        if (parameters.color)\n            this.outlineColor = parameters.color;\n        if (parameters.width)\n            this.outlineWidth = parameters.width;\n        if (parameters.pushback)\n            this.outlinePushback = parameters.pushback;\n        this.setValues(parameters);\n    }\n    clone(material = new StickImposterOutlineMaterial()) {\n        super.clone.call(this, material);\n        material.outlineColor = this.outlineColor;\n        material.outlineWidth = this.outlineWidth;\n        material.outlinePushback = this.outlinePushback;\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/StickImposterOutlineMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/VolumetricMaterial.ts":
/*!***************************************************!*\
  !*** ./src/WebGL/materials/VolumetricMaterial.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VolumetricMaterial: () => (/* binding */ VolumetricMaterial)\n/* harmony export */ });\n/* harmony import */ var _constants_Sides__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/Sides */ \"./src/WebGL/constants/Sides.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colors */ \"./src/colors.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Material */ \"./src/WebGL/materials/Material.ts\");\n//Volumetric material\n\n\n\n/* @constructor */\nclass VolumetricMaterial extends _Material__WEBPACK_IMPORTED_MODULE_2__.Material {\n    constructor(parameters) {\n        super();\n        this.transparent = false;\n        this.volumetric = true;\n        this.color = new _colors__WEBPACK_IMPORTED_MODULE_1__.Color(0xffffff);\n        this.transferfn = null;\n        this.map = undefined;\n        this.extent = [];\n        this.maxdepth = 100.0;\n        this.unit = 0;\n        this.texmatrix = null;\n        this.transfermin = -1.0;\n        this.transfermax = 1.0;\n        this.subsamples = 5.0;\n        this.shaderID = \"volumetric\";\n        this.side = _constants_Sides__WEBPACK_IMPORTED_MODULE_0__.FrontSide;\n        // this.fog = true; // TODO: to integrate the new shader with the fog stuff\n        this.setValues(parameters);\n    }\n    clone(material = new VolumetricMaterial()) {\n        super.clone.call(this, material);\n        material.transparent = this.transparent;\n        material.volumetric = this.volumetric;\n        material.color = this.color;\n        material.transferfn = this.transferfn;\n        material.map = this.map;\n        material.extent = this.extent;\n        material.maxdepth = this.maxdepth;\n        material.unit = this.unit;\n        material.texmatrix = this.texmatrix;\n        material.transfermin = this.transfermin;\n        material.transfermax = this.transfermax;\n        material.subsamples = this.subsamples;\n        material.shaderID = this.shaderID;\n        material.side = this.side;\n        return material;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/VolumetricMaterial.ts?");

/***/ }),

/***/ "./src/WebGL/materials/index.ts":
/*!**************************************!*\
  !*** ./src/WebGL/materials/index.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImposterMaterial: () => (/* reexport safe */ _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__.ImposterMaterial),\n/* harmony export */   InstancedMaterial: () => (/* reexport safe */ _InstancedMaterial__WEBPACK_IMPORTED_MODULE_1__.InstancedMaterial),\n/* harmony export */   LineBasicMaterial: () => (/* reexport safe */ _LineBasicMaterial__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial),\n/* harmony export */   Material: () => (/* reexport safe */ _Material__WEBPACK_IMPORTED_MODULE_3__.Material),\n/* harmony export */   MaterialIdCount: () => (/* reexport safe */ _Material__WEBPACK_IMPORTED_MODULE_3__.MaterialIdCount),\n/* harmony export */   MeshDoubleLambertMaterial: () => (/* reexport safe */ _MeshDoubleLambertMaterial__WEBPACK_IMPORTED_MODULE_4__.MeshDoubleLambertMaterial),\n/* harmony export */   MeshLambertMaterial: () => (/* reexport safe */ _MeshLambertMaterial__WEBPACK_IMPORTED_MODULE_5__.MeshLambertMaterial),\n/* harmony export */   MeshOutlineMaterial: () => (/* reexport safe */ _MeshOutlineMaterial__WEBPACK_IMPORTED_MODULE_6__.MeshOutlineMaterial),\n/* harmony export */   SphereImposterMaterial: () => (/* reexport safe */ _SphereImposterMaterial__WEBPACK_IMPORTED_MODULE_7__.SphereImposterMaterial),\n/* harmony export */   SphereImposterOutlineMaterial: () => (/* reexport safe */ _SphereImposterOutlineMaterial__WEBPACK_IMPORTED_MODULE_8__.SphereImposterOutlineMaterial),\n/* harmony export */   SpriteMaterial: () => (/* reexport safe */ _SpriteMaterial__WEBPACK_IMPORTED_MODULE_9__.SpriteMaterial),\n/* harmony export */   StickImposterMaterial: () => (/* reexport safe */ _StickImposterMaterial__WEBPACK_IMPORTED_MODULE_10__.StickImposterMaterial),\n/* harmony export */   StickImposterOutlineMaterial: () => (/* reexport safe */ _StickImposterOutlineMaterial__WEBPACK_IMPORTED_MODULE_11__.StickImposterOutlineMaterial),\n/* harmony export */   VolumetricMaterial: () => (/* reexport safe */ _VolumetricMaterial__WEBPACK_IMPORTED_MODULE_12__.VolumetricMaterial)\n/* harmony export */ });\n/* harmony import */ var _ImposterMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImposterMaterial */ \"./src/WebGL/materials/ImposterMaterial.ts\");\n/* harmony import */ var _InstancedMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InstancedMaterial */ \"./src/WebGL/materials/InstancedMaterial.ts\");\n/* harmony import */ var _LineBasicMaterial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineBasicMaterial */ \"./src/WebGL/materials/LineBasicMaterial.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Material */ \"./src/WebGL/materials/Material.ts\");\n/* harmony import */ var _MeshDoubleLambertMaterial__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MeshDoubleLambertMaterial */ \"./src/WebGL/materials/MeshDoubleLambertMaterial.ts\");\n/* harmony import */ var _MeshLambertMaterial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MeshLambertMaterial */ \"./src/WebGL/materials/MeshLambertMaterial.ts\");\n/* harmony import */ var _MeshOutlineMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MeshOutlineMaterial */ \"./src/WebGL/materials/MeshOutlineMaterial.ts\");\n/* harmony import */ var _SphereImposterMaterial__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SphereImposterMaterial */ \"./src/WebGL/materials/SphereImposterMaterial.ts\");\n/* harmony import */ var _SphereImposterOutlineMaterial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SphereImposterOutlineMaterial */ \"./src/WebGL/materials/SphereImposterOutlineMaterial.ts\");\n/* harmony import */ var _SpriteMaterial__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SpriteMaterial */ \"./src/WebGL/materials/SpriteMaterial.ts\");\n/* harmony import */ var _StickImposterMaterial__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./StickImposterMaterial */ \"./src/WebGL/materials/StickImposterMaterial.ts\");\n/* harmony import */ var _StickImposterOutlineMaterial__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./StickImposterOutlineMaterial */ \"./src/WebGL/materials/StickImposterOutlineMaterial.ts\");\n/* harmony import */ var _VolumetricMaterial__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./VolumetricMaterial */ \"./src/WebGL/materials/VolumetricMaterial.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/materials/index.ts?");

/***/ }),

/***/ "./src/WebGL/math/Quaternion.ts":
/*!**************************************!*\
  !*** ./src/WebGL/math/Quaternion.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Quaternion: () => (/* binding */ Quaternion)\n/* harmony export */ });\n/** @class\n *  @subcategory  Math\n * */\nclass Quaternion {\n    constructor(x, y, z, w) {\n        this.x = x || 0;\n        this.y = y || 0;\n        this.z = z || 0;\n        this.w = w !== undefined ? w : 1;\n    }\n    set(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    }\n    copy(q) {\n        this.x = q.x;\n        this.y = q.y;\n        this.z = q.z;\n        this.w = q.w;\n        return this;\n    }\n    conjugate() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    }\n    inverse() {\n        return this.conjugate().normalize();\n    }\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    lengthxyz() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    normalize() {\n        let l = this.length();\n        if (l === 0) {\n            this.x = 0;\n            this.y = 0;\n            this.z = 0;\n            this.w = 1;\n        }\n        else {\n            l = 1 / l;\n            this.x *= l;\n            this.y *= l;\n            this.z *= l;\n            this.w *= l;\n        }\n        return this;\n    }\n    multiply(q) {\n        return this.multiplyQuaternions(this, q);\n    }\n    multiplyScalar(s) {\n        this.x *= s;\n        this.y *= s;\n        this.z *= s;\n        this.w *= s;\n        return this;\n    }\n    multiplyQuaternions(a, b) {\n        const qax = a.x;\n        const qay = a.y;\n        const qaz = a.z;\n        const qaw = a.w;\n        const qbx = b.x;\n        const qby = b.y;\n        const qbz = b.z;\n        const qbw = b.w;\n        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n        return this;\n    }\n    sub(q) {\n        this.x -= q.x;\n        this.y -= q.y;\n        this.z -= q.z;\n        this.w -= q.w;\n        return this;\n    }\n    clone() {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n    setFromEuler(e) {\n        const c1 = Math.cos(e.x / 2);\n        const c2 = Math.cos(e.y / 2);\n        const c3 = Math.cos(e.z / 2);\n        const s1 = Math.sin(e.x / 2);\n        const s2 = Math.sin(e.y / 2);\n        const s3 = Math.sin(e.z / 2);\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/math/Quaternion.ts?");

/***/ }),

/***/ "./src/WebGL/math/Vector2.ts":
/*!***********************************!*\
  !*** ./src/WebGL/math/Vector2.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector2: () => (/* binding */ Vector2)\n/* harmony export */ });\n/** @class\n *  @subcategory  Math\n * */\nclass Vector2 {\n    constructor(x, y) {\n        this.x = x || 0.0;\n        this.y = y || 0.0;\n    }\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    subVectors(a, b) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        return this;\n    }\n    copy(v) {\n        this.x = v.x;\n        this.y = v.y;\n        return this;\n    }\n    clone() {\n        return new Vector2(this.x, this.y);\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/math/Vector2.ts?");

/***/ }),

/***/ "./src/WebGL/math/index.ts":
/*!*********************************!*\
  !*** ./src/WebGL/math/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Matrix3: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_5__.Matrix3),\n/* harmony export */   Matrix4: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_5__.Matrix4),\n/* harmony export */   Quaternion: () => (/* reexport safe */ _Quaternion__WEBPACK_IMPORTED_MODULE_0__.Quaternion),\n/* harmony export */   Ray: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_5__.Ray),\n/* harmony export */   Vector2: () => (/* reexport safe */ _Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2),\n/* harmony export */   Vector3: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_5__.Vector3),\n/* harmony export */   clamp: () => (/* reexport safe */ _utils_clamp__WEBPACK_IMPORTED_MODULE_2__.clamp),\n/* harmony export */   conversionMatrix3: () => (/* reexport safe */ _utils_conversionMatrix3__WEBPACK_IMPORTED_MODULE_3__.conversionMatrix3),\n/* harmony export */   degToRad: () => (/* reexport safe */ _utils_degToRad__WEBPACK_IMPORTED_MODULE_4__.degToRad)\n/* harmony export */ });\n/* harmony import */ var _Quaternion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Quaternion */ \"./src/WebGL/math/Quaternion.ts\");\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector2 */ \"./src/WebGL/math/Vector2.ts\");\n/* harmony import */ var _utils_clamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/clamp */ \"./src/WebGL/math/utils/clamp.ts\");\n/* harmony import */ var _utils_conversionMatrix3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/conversionMatrix3 */ \"./src/WebGL/math/utils/conversionMatrix3.ts\");\n/* harmony import */ var _utils_degToRad__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/degToRad */ \"./src/WebGL/math/utils/degToRad.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math */ \"./src/WebGL/math/math.ts\");\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/math/index.ts?");

/***/ }),

/***/ "./src/WebGL/math/math.ts":
/*!********************************!*\
  !*** ./src/WebGL/math/math.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Matrix3: () => (/* binding */ Matrix3),\n/* harmony export */   Matrix4: () => (/* binding */ Matrix4),\n/* harmony export */   Ray: () => (/* binding */ Ray),\n/* harmony export */   Vector3: () => (/* binding */ Vector3)\n/* harmony export */ });\n/* harmony import */ var _utils_degToRad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/degToRad */ \"./src/WebGL/math/utils/degToRad.ts\");\n/* harmony import */ var _utils_clamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/clamp */ \"./src/WebGL/math/utils/clamp.ts\");\n\n\nvar mRotation;\nvar mScale;\nvar x;\nvar y;\nvar z;\n/** @class\n *  @subcategory  Math\n * */\nclass Matrix4 {\n    constructor(n11 = 1, n12 = 0, n13 = 0, n14 = 0, n21 = 0, n22 = 1, n23 = 0, n24 = 0, n31 = 0, n32 = 0, n33 = 1, n34 = 0, n41 = 0, n42 = 0, n43 = 0, n44 = 1) {\n        if (typeof n11 !== \"undefined\" && typeof n11 !== \"number\") {\n            // passing list like initialization\n            this.elements = new Float32Array(n11);\n        }\n        else {\n            this.elements = new Float32Array(16);\n            this.elements[0] = n11;\n            this.elements[4] = n12;\n            this.elements[8] = n13;\n            this.elements[12] = n14;\n            this.elements[1] = n21;\n            this.elements[5] = n22;\n            this.elements[9] = n23;\n            this.elements[13] = n24;\n            this.elements[2] = n31;\n            this.elements[6] = n32;\n            this.elements[10] = n33;\n            this.elements[14] = n34;\n            this.elements[3] = n41;\n            this.elements[7] = n42;\n            this.elements[11] = n43;\n            this.elements[15] = n44;\n        }\n    }\n    // eslint-disable-next-line no-unused-vars, class-methods-use-this\n    makeScale(x, y, z) {\n        throw new Error(\"Method not implemented.\");\n    }\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n        const te = this.elements;\n        te[0] = n11;\n        te[4] = n12;\n        te[8] = n13;\n        te[12] = n14;\n        te[1] = n21;\n        te[5] = n22;\n        te[9] = n23;\n        te[13] = n24;\n        te[2] = n31;\n        te[6] = n32;\n        te[10] = n33;\n        te[14] = n34;\n        te[3] = n41;\n        te[7] = n42;\n        te[11] = n43;\n        te[15] = n44;\n        return this;\n    }\n    identity() {\n        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        return this;\n    }\n    copy(m) {\n        const me = m.elements;\n        this.set(me[0], me[4], me[8], me[12], me[1], me[5], me[9], me[13], me[2], me[6], me[10], me[14], me[3], me[7], me[11], me[15]);\n        return this;\n    }\n    matrix3FromTopLeft() {\n        const te = this.elements;\n        return new Matrix3(te[0], te[4], te[8], te[1], te[5], te[9], te[2], te[6], te[10]);\n    }\n    setRotationFromEuler(v, order) {\n        const te = this.elements;\n        const { x, y, z } = v;\n        const a = Math.cos(x);\n        const b = Math.sin(x);\n        const c = Math.cos(y);\n        const d = Math.sin(y);\n        const e = Math.cos(z);\n        const f = Math.sin(z);\n        if (order === undefined || order === \"XYZ\") {\n            const ae = a * e;\n            const af = a * f;\n            const be = b * e;\n            const bf = b * f;\n            te[0] = c * e;\n            te[4] = -c * f;\n            te[8] = d;\n            te[1] = af + be * d;\n            te[5] = ae - bf * d;\n            te[9] = -b * c;\n            te[2] = bf - ae * d;\n            te[6] = be + af * d;\n            te[10] = a * c;\n        }\n        else\n            console.error(`Error with matrix4 setRotationFromEuler. Order: ${order}`);\n        return this;\n    }\n    setRotationFromQuaternion(q) {\n        const te = this.elements;\n        const { x, y, z, w } = q;\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n        te[0] = 1 - (yy + zz);\n        te[4] = xy - wz;\n        te[8] = xz + wy;\n        te[1] = xy + wz;\n        te[5] = 1 - (xx + zz);\n        te[9] = yz - wx;\n        te[2] = xz - wy;\n        te[6] = yz + wx;\n        te[10] = 1 - (xx + yy);\n        return this;\n    }\n    multiplyMatrices(a, b) {\n        const ae = a.elements;\n        const be = b.elements;\n        const te = this.elements;\n        const a11 = ae[0];\n        const a12 = ae[4];\n        const a13 = ae[8];\n        const a14 = ae[12];\n        const a21 = ae[1];\n        const a22 = ae[5];\n        const a23 = ae[9];\n        const a24 = ae[13];\n        const a31 = ae[2];\n        const a32 = ae[6];\n        const a33 = ae[10];\n        const a34 = ae[14];\n        const a41 = ae[3];\n        const a42 = ae[7];\n        const a43 = ae[11];\n        const a44 = ae[15];\n        const b11 = be[0];\n        const b12 = be[4];\n        const b13 = be[8];\n        const b14 = be[12];\n        const b21 = be[1];\n        const b22 = be[5];\n        const b23 = be[9];\n        const b24 = be[13];\n        const b31 = be[2];\n        const b32 = be[6];\n        const b33 = be[10];\n        const b34 = be[14];\n        const b41 = be[3];\n        const b42 = be[7];\n        const b43 = be[11];\n        const b44 = be[15];\n        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n        return this;\n    }\n    multiplyScalar(s) {\n        const te = this.elements;\n        te[0] *= s;\n        te[4] *= s;\n        te[8] *= s;\n        te[12] *= s;\n        te[1] *= s;\n        te[5] *= s;\n        te[9] *= s;\n        te[13] *= s;\n        te[2] *= s;\n        te[6] *= s;\n        te[10] *= s;\n        te[14] *= s;\n        te[3] *= s;\n        te[7] *= s;\n        te[11] *= s;\n        te[15] *= s;\n        return this;\n    }\n    makeTranslation(x, y, z) {\n        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n        return this;\n    }\n    // snap values close to integers to their integer value\n    // useful and identifying identity matrices\n    snap(digits) {\n        if (!digits)\n            digits = 4;\n        const mult = Math.pow(10, 4);\n        const te = this.elements;\n        for (let i = 0; i < 16; i++) {\n            const rounded = Math.round(te[i]);\n            if (rounded === Math.round(te[i] * mult) / mult) {\n                te[i] = rounded;\n            }\n        }\n        return this;\n    }\n    transpose() {\n        const te = this.elements;\n        let tmp;\n        tmp = te[1];\n        te[1] = te[4];\n        te[4] = tmp;\n        tmp = te[2];\n        te[2] = te[8];\n        te[8] = tmp;\n        tmp = te[6];\n        te[6] = te[9];\n        te[9] = tmp;\n        tmp = te[3];\n        te[3] = te[12];\n        te[12] = tmp;\n        tmp = te[7];\n        te[7] = te[13];\n        te[13] = tmp;\n        tmp = te[11];\n        te[11] = te[14];\n        te[14] = tmp;\n        return this;\n    }\n    setPosition(v) {\n        const te = this.elements;\n        te[12] = v.x;\n        te[13] = v.y;\n        te[14] = v.z;\n        return this;\n    }\n    translate(v) {\n        const te = this.elements;\n        te[12] += v.x;\n        te[13] += v.y;\n        te[14] += v.z;\n        return this;\n    }\n    getInverse(m, throwOnInvertible) {\n        // based on\n        // http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n        const te = this.elements;\n        const me = m.elements;\n        const n11 = me[0];\n        const n12 = me[4];\n        const n13 = me[8];\n        const n14 = me[12];\n        const n21 = me[1];\n        const n22 = me[5];\n        const n23 = me[9];\n        const n24 = me[13];\n        const n31 = me[2];\n        const n32 = me[6];\n        const n33 = me[10];\n        const n34 = me[14];\n        const n41 = me[3];\n        const n42 = me[7];\n        const n43 = me[11];\n        const n44 = me[15];\n        te[0] =\n            n23 * n34 * n42 -\n                n24 * n33 * n42 +\n                n24 * n32 * n43 -\n                n22 * n34 * n43 -\n                n23 * n32 * n44 +\n                n22 * n33 * n44;\n        te[4] =\n            n14 * n33 * n42 -\n                n13 * n34 * n42 -\n                n14 * n32 * n43 +\n                n12 * n34 * n43 +\n                n13 * n32 * n44 -\n                n12 * n33 * n44;\n        te[8] =\n            n13 * n24 * n42 -\n                n14 * n23 * n42 +\n                n14 * n22 * n43 -\n                n12 * n24 * n43 -\n                n13 * n22 * n44 +\n                n12 * n23 * n44;\n        te[12] =\n            n14 * n23 * n32 -\n                n13 * n24 * n32 -\n                n14 * n22 * n33 +\n                n12 * n24 * n33 +\n                n13 * n22 * n34 -\n                n12 * n23 * n34;\n        te[1] =\n            n24 * n33 * n41 -\n                n23 * n34 * n41 -\n                n24 * n31 * n43 +\n                n21 * n34 * n43 +\n                n23 * n31 * n44 -\n                n21 * n33 * n44;\n        te[5] =\n            n13 * n34 * n41 -\n                n14 * n33 * n41 +\n                n14 * n31 * n43 -\n                n11 * n34 * n43 -\n                n13 * n31 * n44 +\n                n11 * n33 * n44;\n        te[9] =\n            n14 * n23 * n41 -\n                n13 * n24 * n41 -\n                n14 * n21 * n43 +\n                n11 * n24 * n43 +\n                n13 * n21 * n44 -\n                n11 * n23 * n44;\n        te[13] =\n            n13 * n24 * n31 -\n                n14 * n23 * n31 +\n                n14 * n21 * n33 -\n                n11 * n24 * n33 -\n                n13 * n21 * n34 +\n                n11 * n23 * n34;\n        te[2] =\n            n22 * n34 * n41 -\n                n24 * n32 * n41 +\n                n24 * n31 * n42 -\n                n21 * n34 * n42 -\n                n22 * n31 * n44 +\n                n21 * n32 * n44;\n        te[6] =\n            n14 * n32 * n41 -\n                n12 * n34 * n41 -\n                n14 * n31 * n42 +\n                n11 * n34 * n42 +\n                n12 * n31 * n44 -\n                n11 * n32 * n44;\n        te[10] =\n            n12 * n24 * n41 -\n                n14 * n22 * n41 +\n                n14 * n21 * n42 -\n                n11 * n24 * n42 -\n                n12 * n21 * n44 +\n                n11 * n22 * n44;\n        te[14] =\n            n14 * n22 * n31 -\n                n12 * n24 * n31 -\n                n14 * n21 * n32 +\n                n11 * n24 * n32 +\n                n12 * n21 * n34 -\n                n11 * n22 * n34;\n        te[3] =\n            n23 * n32 * n41 -\n                n22 * n33 * n41 -\n                n23 * n31 * n42 +\n                n21 * n33 * n42 +\n                n22 * n31 * n43 -\n                n21 * n32 * n43;\n        te[7] =\n            n12 * n33 * n41 -\n                n13 * n32 * n41 +\n                n13 * n31 * n42 -\n                n11 * n33 * n42 -\n                n12 * n31 * n43 +\n                n11 * n32 * n43;\n        te[11] =\n            n13 * n22 * n41 -\n                n12 * n23 * n41 -\n                n13 * n21 * n42 +\n                n11 * n23 * n42 +\n                n12 * n21 * n43 -\n                n11 * n22 * n43;\n        te[15] =\n            n12 * n23 * n31 -\n                n13 * n22 * n31 +\n                n13 * n21 * n32 -\n                n11 * n23 * n32 -\n                n12 * n21 * n33 +\n                n11 * n22 * n33;\n        const det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];\n        if (det === 0) {\n            const msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n            if (throwOnInvertible || false) {\n                throw new Error(msg);\n            }\n            else {\n                console.warn(msg);\n            }\n            this.identity();\n            return this;\n        }\n        this.multiplyScalar(1 / det);\n        return this;\n    }\n    isReflected() {\n        const te = this.elements;\n        const m0 = te[0];\n        const m3 = te[4];\n        const m6 = te[8];\n        const m1 = te[1];\n        const m4 = te[5];\n        const m7 = te[9];\n        const m2 = te[2];\n        const m5 = te[6];\n        const m8 = te[10];\n        const determinant = m0 * m4 * m8 + // +aei\n            m1 * m5 * m6 + // +bfg\n            m2 * m3 * m7 - // +cdh\n            m2 * m4 * m6 - // -ceg\n            m1 * m3 * m8 - // -bdi\n            m0 * m5 * m7; // -afh\n        return determinant < 0;\n    }\n    scale(v) {\n        const te = this.elements;\n        const { x } = v;\n        const { y } = v;\n        const { z } = v;\n        te[0] *= x;\n        te[4] *= y;\n        te[8] *= z;\n        te[1] *= x;\n        te[5] *= y;\n        te[9] *= z;\n        te[2] *= x;\n        te[6] *= y;\n        te[10] *= z;\n        te[3] *= x;\n        te[7] *= y;\n        te[11] *= z;\n        return this;\n    }\n    getMaxScaleOnAxis() {\n        const te = this.elements;\n        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n        return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));\n    }\n    makeFrustum(left, right, bottom, top, near, far) {\n        const te = this.elements;\n        const x = (2 * near) / (right - left);\n        const y = (2 * near) / (top - bottom);\n        const a = (right + left) / (right - left);\n        const b = (top + bottom) / (top - bottom);\n        const c = -(far + near) / (far - near);\n        const d = (-2 * far * near) / (far - near);\n        te[0] = x;\n        te[4] = 0;\n        te[8] = a;\n        te[12] = 0;\n        te[1] = 0;\n        te[5] = y;\n        te[9] = b;\n        te[13] = 0;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = c;\n        te[14] = d;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = -1;\n        te[15] = 0;\n        return this;\n    }\n    makePerspective(fov, aspect, near, far) {\n        const ymax = near * Math.tan((0,_utils_degToRad__WEBPACK_IMPORTED_MODULE_0__.degToRad)(fov * 0.5));\n        const ymin = -ymax;\n        const xmin = ymin * aspect;\n        const xmax = ymax * aspect;\n        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);\n    }\n    makeOrthographic(left, right, top, bottom, near, far) {\n        const te = this.elements;\n        const w = 1.0 / (right - left);\n        const h = 1.0 / (top - bottom);\n        const p = 1.0 / (far - near);\n        const x = (right + left) * w;\n        const y = (top + bottom) * h;\n        const z = (far + near) * p;\n        te[0] = 2 * w;\n        te[4] = 0;\n        te[8] = 0;\n        te[12] = -x;\n        te[1] = 0;\n        te[5] = 2 * h;\n        te[9] = 0;\n        te[13] = -y;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = -2 * p;\n        te[14] = -z;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = 0;\n        te[15] = 1;\n        return this;\n    }\n    isEqual(m) {\n        const me = m.elements;\n        const te = this.elements;\n        if (te[0] === me[0] &&\n            te[4] === me[4] &&\n            te[8] === me[8] &&\n            te[12] === me[12] &&\n            te[1] === me[1] &&\n            te[5] === me[5] &&\n            te[9] === me[9] &&\n            te[13] === me[13] &&\n            te[2] === me[2] &&\n            te[6] === me[6] &&\n            te[10] === me[10] &&\n            te[14] === me[14] &&\n            te[3] === me[3] &&\n            te[7] === me[7] &&\n            te[11] === me[11] &&\n            te[15] === me[15]) {\n            return true;\n        }\n        return false;\n    }\n    clone() {\n        const te = this.elements;\n        return new Matrix4(te[0], te[4], te[8], te[12], te[1], te[5], te[9], te[13], te[2], te[6], te[10], te[14], te[3], te[7], te[11], te[15]);\n    }\n    isIdentity() {\n        const te = this.elements;\n        if (te[0] === 1 &&\n            te[4] === 0 &&\n            te[8] === 0 &&\n            te[12] === 0 &&\n            te[1] === 0 &&\n            te[5] === 1 &&\n            te[9] === 0 &&\n            te[13] === 0 &&\n            te[2] === 0 &&\n            te[6] === 0 &&\n            te[10] === 1 &&\n            te[14] === 0 &&\n            te[3] === 0 &&\n            te[7] === 0 &&\n            te[11] === 0 &&\n            te[15] === 1) {\n            return true;\n        }\n        return false;\n    }\n    // return true if elements are with digits of identity\n    isNearlyIdentity(digits) {\n        const snapped = this.clone().snap(digits);\n        return snapped.isIdentity();\n    }\n    getScale(scale) {\n        const te = this.elements;\n        scale = scale || new Vector3();\n        // grab the axis vectors\n        x.set(te[0], te[1], te[2]);\n        y.set(te[4], te[5], te[6]);\n        z.set(te[8], te[9], te[10]);\n        scale.x = x.length();\n        scale.y = y.length();\n        scale.z = z.length();\n        return scale;\n    }\n    lookAt(eye, target, up) {\n        const te = this.elements;\n        z.subVectors(eye, target).normalize();\n        if (z.length() === 0) {\n            z.z = 1;\n        }\n        x.crossVectors(up, z).normalize();\n        if (x.length() === 0) {\n            z.x += 0.0001;\n            x.crossVectors(up, z).normalize();\n        }\n        y.crossVectors(z, x);\n        te[0] = x.x;\n        te[4] = y.x;\n        te[8] = z.x;\n        te[1] = x.y;\n        te[5] = y.y;\n        te[9] = z.y;\n        te[2] = x.z;\n        te[6] = y.z;\n        te[10] = z.z;\n        return this;\n    }\n    compose(translation, rotation, scale) {\n        const te = this.elements;\n        mRotation.identity();\n        mRotation.setRotationFromQuaternion(rotation);\n        mScale.makeScale(scale.x, scale.y, scale.z);\n        this.multiplyMatrices(mRotation, mScale);\n        te[12] = translation.x;\n        te[13] = translation.y;\n        te[14] = translation.z;\n        return this;\n    }\n}\nmRotation = new Matrix4();\nmScale = new Matrix4();\n/** @class\n *  @subcategory  Math\n * */\nclass Vector3 {\n    constructor(x, y, z) {\n        this.x = x || 0.0;\n        this.y = y || 0.0;\n        this.z = z || 0.0;\n        this.atomid = undefined;\n    }\n    set(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    }\n    copy(v) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        return this;\n    }\n    add(v) {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n        return this;\n    }\n    addVectors(a, b) {\n        this.x = a.x + b.x;\n        this.y = a.y + b.y;\n        this.z = a.z + b.z;\n        return this;\n    }\n    multiplyVectors(a, b) {\n        // elementwise\n        this.x = a.x * b.x;\n        this.y = a.y * b.y;\n        this.z = a.z * b.z;\n        return this;\n    }\n    sub(v) {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n        return this;\n    }\n    subVectors(a, b) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        this.z = a.z - b.z;\n        return this;\n    }\n    multiplyScalar(s) {\n        this.x *= s;\n        this.y *= s;\n        this.z *= s;\n        return this;\n    }\n    divideScalar(s) {\n        if (s !== 0) {\n            this.x /= s;\n            this.y /= s;\n            this.z /= s;\n        }\n        else {\n            this.x = 0;\n            this.y = 0;\n            this.z = 0;\n        }\n        return this;\n    }\n    // accumulate maximum\n    max(s) {\n        this.x = Math.max(this.x, s.x);\n        this.y = Math.max(this.y, s.y);\n        this.z = Math.max(this.z, s.z);\n        return this;\n    }\n    // accumulate min\n    min(s) {\n        this.x = Math.min(this.x, s.x);\n        this.y = Math.min(this.y, s.y);\n        this.z = Math.min(this.z, s.z);\n        return this;\n    }\n    distanceTo(v) {\n        return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n        const dx = this.x - v.x;\n        const dy = this.y - v.y;\n        const dz = this.z - v.z;\n        return dx * dx + dy * dy + dz * dz;\n    }\n    applyMatrix3(m) {\n        const { x } = this;\n        const { y } = this;\n        const { z } = this;\n        const e = m.elements;\n        // column major ordering\n        this.x = e[0] * x + e[3] * y + e[6] * z;\n        this.y = e[1] * x + e[4] * y + e[7] * z;\n        this.z = e[2] * x + e[5] * y + e[8] * z;\n        return this;\n    }\n    applyMatrix4(m) {\n        const { x } = this;\n        const { y } = this;\n        const { z } = this;\n        const e = m.elements;\n        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];\n        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];\n        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n        return this;\n    }\n    applyProjection(m) {\n        // input: Matrix4 projection matrix\n        const { x } = this;\n        const { y } = this;\n        const { z } = this;\n        const e = m.elements;\n        const d = e[3] * x + e[7] * y + e[11] * z + e[15];\n        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) / d;\n        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) / d;\n        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) / d;\n        return this;\n    }\n    applyQuaternion(q) {\n        // save values\n        const { x } = this;\n        const { y } = this;\n        const { z } = this;\n        const qx = q.x;\n        const qy = q.y;\n        const qz = q.z;\n        const qw = q.w;\n        // compute this as\n        // t = 2 * cross(q.xyz, v)\n        // newv = v + q.w * t + cross(q.xyz, t)\n        // this from molecularmusings\n        // http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n        const t = {};\n        t.x = 2 * (y * qz - z * qy);\n        t.y = 2 * (z * qx - x * qz);\n        t.z = 2 * (x * qy - y * qx);\n        // cross t with q\n        const t2 = {};\n        t2.x = t.y * qz - t.z * qy;\n        t2.y = t.z * qx - t.x * qz;\n        t2.z = t.x * qy - t.y * qx;\n        this.x = x + qw * t.x + t2.x;\n        this.y = y + qw * t.y + t2.y;\n        this.z = z + qw * t.z + t2.z;\n        return this;\n    }\n    negate() {\n        return this.multiplyScalar(-1);\n    }\n    dot(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    normalize() {\n        return this.divideScalar(this.length());\n    }\n    cross(v) {\n        const { x } = this;\n        const { y } = this;\n        const { z } = this;\n        this.x = y * v.z - z * v.y;\n        this.y = z * v.x - x * v.z;\n        this.z = x * v.y - y * v.x;\n        return this;\n    }\n    crossVectors(a, b) {\n        this.x = a.y * b.z - a.z * b.y;\n        this.y = a.z * b.x - a.x * b.z;\n        this.z = a.x * b.y - a.y * b.x;\n        return this;\n    }\n    equals(b) {\n        return this.x == b.x && this.y == b.y && this.z == b.z;\n    }\n    getPositionFromMatrix(m) {\n        this.x = m.elements[12];\n        this.y = m.elements[13];\n        this.z = m.elements[14];\n        return this;\n    }\n    setEulerFromRotationMatrix(m, order) {\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n        const te = m.elements;\n        const m11 = te[0];\n        const m12 = te[4];\n        const m13 = te[8];\n        // var m21 = te[1];\n        const m22 = te[5];\n        const m23 = te[9];\n        // var m31 = te[2];\n        const m32 = te[6];\n        const m33 = te[10];\n        if (order === undefined || order === \"XYZ\") {\n            this.y = Math.asin((0,_utils_clamp__WEBPACK_IMPORTED_MODULE_1__.clamp)(m13, -1, 1));\n            if (Math.abs(m13) < 0.99999) {\n                this.x = Math.atan2(-m23, m33);\n                this.z = Math.atan2(-m12, m11);\n            }\n            else {\n                this.x = Math.atan2(m32, m22);\n                this.z = 0;\n            }\n        }\n        else {\n            console.error(`Error with vector's setEulerFromRotationMatrix: Unknown order: ${order}`);\n        }\n        return this;\n    }\n    rotateAboutVector(axis, ang) {\n        axis.normalize();\n        const cosang = Math.cos(ang);\n        const sinang = Math.sin(ang);\n        // Rodrigues' rotation formula, from wikipedia\n        const term1 = this.clone().multiplyScalar(cosang);\n        const term2 = axis.clone().cross(this).multiplyScalar(sinang);\n        const term3 = axis\n            .clone()\n            .multiplyScalar(axis.clone().dot(this))\n            .multiplyScalar(1 - cosang);\n        const rot = term1.add(term2).add(term3);\n        this.x = rot.x;\n        this.y = rot.y;\n        this.z = rot.z;\n        return this;\n    }\n    setFromMatrixPosition(m) {\n        const e = m.elements;\n        this.x = e[12];\n        this.y = e[13];\n        this.z = e[14];\n        return this;\n    }\n    // unproject is defined after Matrix4\n    transformDirection(m) {\n        // input: THREE.Matrix4 affine matrix\n        // vector interpreted as a direction\n        const { x } = this;\n        const { y } = this;\n        const { z } = this;\n        const e = m.elements;\n        this.x = e[0] * x + e[4] * y + e[8] * z;\n        this.y = e[1] * x + e[5] * y + e[9] * z;\n        this.z = e[2] * x + e[6] * y + e[10] * z;\n        return this.normalize();\n    }\n    clone() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n    unproject(camera) {\n        const mat4 = mRotation;\n        mat4.multiplyMatrices(camera.matrixWorld, mat4.getInverse(camera.projectionMatrix));\n        return this.applyMatrix4(mat4);\n    }\n}\nx = new Vector3();\ny = new Vector3();\nz = new Vector3();\n/** @class\n *  @subcategory  Math\n * */\nclass Matrix3 {\n    constructor(n11 = 1, n12 = 0, n13 = 0, n21 = 0, n22 = 1, n23 = 0, n31 = 0, n32 = 0, n33 = 1) {\n        this.elements = new Float32Array(9);\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n    }\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n        const te = this.elements;\n        te[0] = n11;\n        te[3] = n12;\n        te[6] = n13;\n        te[1] = n21;\n        te[4] = n22;\n        te[7] = n23;\n        te[2] = n31;\n        te[5] = n32;\n        te[8] = n33;\n        return this;\n    }\n    identity() {\n        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        return this;\n    }\n    copy(m) {\n        const me = m.elements;\n        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);\n    }\n    multiplyScalar(s) {\n        const te = this.elements;\n        te[0] *= s;\n        te[3] *= s;\n        te[6] *= s;\n        te[1] *= s;\n        te[4] *= s;\n        te[7] *= s;\n        te[2] *= s;\n        te[5] *= s;\n        te[8] *= s;\n        return this;\n    }\n    getInverse3(matrix) {\n        // input: Matrix3\n        const me = matrix.elements;\n        const te = this.elements;\n        te[0] = me[4] * me[8] - me[5] * me[7];\n        te[3] = me[6] * me[5] - me[3] * me[8];\n        te[6] = me[3] * me[7] - me[6] * me[4];\n        te[1] = me[7] * me[2] - me[1] * me[8];\n        te[4] = me[0] * me[8] - me[6] * me[2];\n        te[7] = me[1] * me[6] - me[0] * me[7];\n        te[2] = me[1] * me[5] - me[2] * me[4];\n        te[5] = me[2] * me[3] - me[0] * me[5];\n        te[8] = me[0] * me[4] - me[1] * me[3];\n        const det = me[0] * te[0] + me[3] * te[1] + me[6] * te[2];\n        this.multiplyScalar(1.0 / det);\n        return this;\n    }\n    getInverse(matrix, throwOnInvertible) {\n        // input: Matrix4\n        const me = matrix.elements;\n        const te = this.elements;\n        te[0] = me[10] * me[5] - me[6] * me[9];\n        te[1] = -me[10] * me[1] + me[2] * me[9];\n        te[2] = me[6] * me[1] - me[2] * me[5];\n        te[3] = -me[10] * me[4] + me[6] * me[8];\n        te[4] = me[10] * me[0] - me[2] * me[8];\n        te[5] = -me[6] * me[0] + me[2] * me[4];\n        te[6] = me[9] * me[4] - me[5] * me[8];\n        te[7] = -me[9] * me[0] + me[1] * me[8];\n        te[8] = me[5] * me[0] - me[1] * me[4];\n        const det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];\n        // no inverse\n        if (det === 0) {\n            const msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n            if (throwOnInvertible || false) {\n                throw new Error(msg);\n            }\n            else {\n                console.warn(msg);\n            }\n            this.identity();\n            return this;\n        }\n        this.multiplyScalar(1.0 / det);\n        return this;\n    }\n    // https://en.wikipedia.org/wiki/Determinant\n    getDeterminant() {\n        const m = this.elements;\n        /*\n         * |a b c| |d e f| |g h i|\n         */\n        const determinant = m[0] * m[4] * m[8] + // +aei\n            m[1] * m[5] * m[6] + // +bfg\n            m[2] * m[3] * m[7] - // +cdh\n            m[2] * m[4] * m[6] - // -ceg\n            m[1] * m[3] * m[8] - // -bdi\n            m[0] * m[5] * m[7]; // -afh\n        return determinant;\n    }\n    transpose() {\n        let tmp;\n        const m = this.elements;\n        tmp = m[1];\n        m[1] = m[3];\n        m[3] = tmp;\n        tmp = m[2];\n        m[2] = m[6];\n        m[6] = tmp;\n        tmp = m[5];\n        m[5] = m[7];\n        m[7] = tmp;\n        return this;\n    }\n    clone() {\n        const te = this.elements;\n        return new Matrix3(te[0], te[3], te[6], te[1], te[4], te[7], te[2], te[5], te[8]);\n    }\n    getMatrix4() {\n        const m = this.elements;\n        return new Matrix4(m[0], m[3], m[6], 0, m[1], m[4], m[7], 0, m[2], m[5], m[8], 0);\n    }\n}\n/** @class\n *  @subcategory  Math\n * */\nclass Ray {\n    constructor(origin, direction) {\n        this.origin = origin !== undefined ? origin : new Vector3();\n        this.direction = direction !== undefined ? direction : new Vector3();\n    }\n    set(origin, direction) {\n        this.origin.copy(origin);\n        this.direction.copy(direction);\n        return this;\n    }\n    copy(ray) {\n        this.origin.copy(ray.origin);\n        this.direction.copy(ray.direction);\n        return this;\n    }\n    at(t, optionalTarget) {\n        const result = optionalTarget || new Vector3();\n        return result.copy(this.direction).multiplyScalar(t).add(this.origin);\n    }\n    recast(t) {\n        const v1 = x;\n        this.origin.copy(this.at(t, v1));\n        return this;\n    }\n    closestPointToPoint(point, optionalTarget) {\n        const result = optionalTarget || new Vector3();\n        result.subVectors(point, this.origin);\n        const directionDistance = result.dot(this.direction);\n        // returns a point on this ray\n        return result\n            .copy(this.direction)\n            .multiplyScalar(directionDistance)\n            .add(this.origin);\n    }\n    distanceToPoint(point) {\n        const v1 = x;\n        const directionDistance = v1\n            .subVectors(point, this.origin)\n            .dot(this.direction);\n        v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n        return v1.distanceTo(point);\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isIntersectionCylinder() { }\n    isIntersectionSphere(sphere) {\n        return this.distanceToPoint(sphere.center) <= sphere.radius;\n    }\n    isIntersectionPlane(plane) {\n        const denominator = plane.normal.dot(this.direction);\n        // plane and ray are not perpendicular\n        if (denominator !== 0)\n            return true;\n        if (plane.distanceToPoint(this.origin) === 0)\n            return true;\n        return false;\n    }\n    distanceToPlane(plane) {\n        const denominator = plane.normal.dot(this.direction);\n        if (denominator === 0) {\n            // line is coplanar\n            if (plane.distanceToPoint(this.origin) === 0)\n                return 0;\n            // ray is parallel\n            return undefined;\n        }\n        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n        return t;\n    }\n    intersectPlane(plane, optionalTarget) {\n        const t = this.distanceToPlane(plane);\n        if (t === undefined)\n            return undefined;\n        return this.at(t, optionalTarget);\n    }\n    applyMatrix4(matrix4) {\n        this.direction.add(this.origin).applyMatrix4(matrix4);\n        this.origin.applyMatrix4(matrix4);\n        this.direction.sub(this.origin);\n        return this;\n    }\n    clone() {\n        return new Ray().copy(this);\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/math/math.ts?");

/***/ }),

/***/ "./src/WebGL/math/utils/clamp.ts":
/*!***************************************!*\
  !*** ./src/WebGL/math/utils/clamp.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp)\n/* harmony export */ });\n/*\n * math-like functionality\n * quaternion, vector, matrix\n */\nfunction clamp(x, min, max) {\n    return Math.min(Math.max(x, min), max);\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/math/utils/clamp.ts?");

/***/ }),

/***/ "./src/WebGL/math/utils/conversionMatrix3.ts":
/*!***************************************************!*\
  !*** ./src/WebGL/math/utils/conversionMatrix3.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   conversionMatrix3: () => (/* binding */ conversionMatrix3)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/math.ts\");\n// return conversion matrix given crystal unit cell parameters\n\n/**\n *\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @param {number} alpha\n * @param {number} beta\n * @param {number} gamma\n * @returns {Matrix3}\n */\nfunction conversionMatrix3(a, b, c, alpha, beta, gamma) {\n    // Convert to radians\n    alpha = (alpha * Math.PI) / 180;\n    beta = (beta * Math.PI) / 180;\n    gamma = (gamma * Math.PI) / 180;\n    const sqr = (x) => {\n        return x * x;\n    };\n    const cosAlpha = Math.cos(alpha);\n    const cosBeta = Math.cos(beta);\n    const cosGamma = Math.cos(gamma);\n    const sinGamma = Math.sin(gamma);\n    const conversionMatrix = new _math__WEBPACK_IMPORTED_MODULE_0__.Matrix3(a, b * cosGamma, c * cosBeta, 0, b * sinGamma, (c * (cosAlpha - cosBeta * cosGamma)) / sinGamma, 0, 0, (c *\n        Math.sqrt(1 -\n            sqr(cosAlpha) -\n            sqr(cosBeta) -\n            sqr(cosGamma) +\n            2 * cosAlpha * cosBeta * cosGamma)) /\n        sinGamma);\n    return conversionMatrix;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/math/utils/conversionMatrix3.ts?");

/***/ }),

/***/ "./src/WebGL/math/utils/degToRad.ts":
/*!******************************************!*\
  !*** ./src/WebGL/math/utils/degToRad.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   degToRad: () => (/* binding */ degToRad)\n/* harmony export */ });\nconst degreeToRadiansFactor = Math.PI / 180;\nfunction degToRad(deg) {\n    return deg * degreeToRadiansFactor;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/math/utils/degToRad.ts?");

/***/ }),

/***/ "./src/WebGL/objects/Line.ts":
/*!***********************************!*\
  !*** ./src/WebGL/objects/Line.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   LineStyle: () => (/* binding */ LineStyle)\n/* harmony export */ });\n/* harmony import */ var _materials__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials */ \"./src/WebGL/materials/index.ts\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core */ \"./src/WebGL/core/index.ts\");\n\n\nvar LineStyle;\n(function (LineStyle) {\n    LineStyle[LineStyle[\"LineStrip\"] = 0] = \"LineStrip\";\n    LineStyle[LineStyle[\"LinePieces\"] = 1] = \"LinePieces\";\n})(LineStyle || (LineStyle = {}));\nclass Line extends _core__WEBPACK_IMPORTED_MODULE_1__.Object3D {\n    constructor(geometry, material = new _materials__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({\n        color: Math.random() * 0xffffff,\n    }), type = LineStyle.LineStrip) {\n        super();\n        this.geometry = geometry;\n        //TODO: update material and type to webgl\n        this.material = material;\n        this.type = type;\n    }\n    clone(object = new Line(this.geometry, this.material, this.type)) {\n        super.clone.call(this, object);\n        return object;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/objects/Line.ts?");

/***/ }),

/***/ "./src/WebGL/objects/Mesh.ts":
/*!***********************************!*\
  !*** ./src/WebGL/objects/Mesh.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mesh: () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core */ \"./src/WebGL/core/index.ts\");\n\n//Mesh Object\n/* @constructor */\nclass Mesh extends _core__WEBPACK_IMPORTED_MODULE_0__.Object3D {\n    constructor(geometry, material) {\n        super();\n        this.geometry = geometry;\n        this.material = material;\n    }\n    clone(object) {\n        if (object === undefined)\n            object = new Mesh(this.geometry, this.material);\n        super.clone.call(this, object);\n        return object;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/objects/Mesh.ts?");

/***/ }),

/***/ "./src/WebGL/objects/Sprite.ts":
/*!*************************************!*\
  !*** ./src/WebGL/objects/Sprite.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sprite: () => (/* binding */ Sprite)\n/* harmony export */ });\n/* harmony import */ var _materials__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials */ \"./src/WebGL/materials/index.ts\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core */ \"./src/WebGL/core/index.ts\");\n\n\n//Sprite object\n/* @constructor */\nclass Sprite extends _core__WEBPACK_IMPORTED_MODULE_1__.Object3D {\n    constructor(material = new _materials__WEBPACK_IMPORTED_MODULE_0__.SpriteMaterial()) {\n        super();\n        this.material = material;\n        this.rotation3d = this.rotation;\n        this.rotation = 0;\n    }\n    updateMatrix() {\n        this.matrix.setPosition(this.position);\n        this.rotation3d.set(0, 0, this.rotation);\n        this.matrix.setRotationFromEuler(this.rotation3d);\n        if (this.scale.x !== 1 || this.scale.y !== 1)\n            this.matrix.scale(this.scale);\n        this.matrixWorldNeedsUpdate = true;\n    }\n    clone(object = new Sprite(this.material)) {\n        _core__WEBPACK_IMPORTED_MODULE_1__.Object3D.prototype.clone.call(this, object);\n        return object;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/objects/Sprite.ts?");

/***/ }),

/***/ "./src/WebGL/objects/index.ts":
/*!************************************!*\
  !*** ./src/WebGL/objects/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* reexport safe */ _Line__WEBPACK_IMPORTED_MODULE_0__.Line),\n/* harmony export */   LineStyle: () => (/* reexport safe */ _Line__WEBPACK_IMPORTED_MODULE_0__.LineStyle),\n/* harmony export */   Mesh: () => (/* reexport safe */ _Mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh),\n/* harmony export */   Sprite: () => (/* reexport safe */ _Sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite)\n/* harmony export */ });\n/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line */ \"./src/WebGL/objects/Line.ts\");\n/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Mesh */ \"./src/WebGL/objects/Mesh.ts\");\n/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sprite */ \"./src/WebGL/objects/Sprite.ts\");\n\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/objects/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/ShaderType.ts":
/*!*****************************************!*\
  !*** ./src/WebGL/shaders/ShaderType.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/ShaderType.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/index.ts":
/*!************************************!*\
  !*** ./src/WebGL/shaders/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderLib: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderLib),\n/* harmony export */   ShaderUtils: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.ShaderUtils),\n/* harmony export */   basic: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.basic),\n/* harmony export */   clone: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.clone),\n/* harmony export */   instanced: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.instanced),\n/* harmony export */   lambert: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.lambert),\n/* harmony export */   lambertdouble: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.lambertdouble),\n/* harmony export */   outline: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.outline),\n/* harmony export */   screen: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.screen),\n/* harmony export */   screenaa: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.screenaa),\n/* harmony export */   sphereimposter: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.sphereimposter),\n/* harmony export */   sphereimposteroutline: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.sphereimposteroutline),\n/* harmony export */   sprite: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.sprite),\n/* harmony export */   stickimposter: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.stickimposter),\n/* harmony export */   stickimposteroutline: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.stickimposteroutline),\n/* harmony export */   volumetric: () => (/* reexport safe */ _lib__WEBPACK_IMPORTED_MODULE_0__.volumetric)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./src/WebGL/shaders/lib/index.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/WebGL/shaders/utils/index.ts\");\n/* harmony import */ var _ShaderType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShaderType */ \"./src/WebGL/shaders/ShaderType.ts\");\n\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/basic/index.ts":
/*!**********************************************!*\
  !*** ./src/WebGL/shaders/lib/basic/index.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   basic: () => (/* binding */ basic)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/basic/uniforms.ts\");\n/* harmony import */ var _basic_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic.frag */ \"./src/WebGL/shaders/lib/basic/basic.frag\");\n/* harmony import */ var _basic_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_basic_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _basic_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic.vert */ \"./src/WebGL/shaders/lib/basic/basic.vert\");\n/* harmony import */ var _basic_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_basic_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst basic = {\n    vertexShader: _basic_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    fragmentShader: _basic_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/basic/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/basic/uniforms.ts":
/*!*************************************************!*\
  !*** ./src/WebGL/shaders/lib/basic/uniforms.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 }\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/basic/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/index.ts":
/*!****************************************!*\
  !*** ./src/WebGL/shaders/lib/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderLib: () => (/* binding */ ShaderLib),\n/* harmony export */   basic: () => (/* reexport safe */ _basic__WEBPACK_IMPORTED_MODULE_0__.basic),\n/* harmony export */   instanced: () => (/* reexport safe */ _instanced__WEBPACK_IMPORTED_MODULE_1__.instanced),\n/* harmony export */   lambert: () => (/* reexport safe */ _lambert__WEBPACK_IMPORTED_MODULE_2__.lambert),\n/* harmony export */   lambertdouble: () => (/* reexport safe */ _lambertdouble__WEBPACK_IMPORTED_MODULE_3__.lambertdouble),\n/* harmony export */   outline: () => (/* reexport safe */ _outline__WEBPACK_IMPORTED_MODULE_4__.outline),\n/* harmony export */   screen: () => (/* reexport safe */ _screen__WEBPACK_IMPORTED_MODULE_5__.screen),\n/* harmony export */   screenaa: () => (/* reexport safe */ _screenaa__WEBPACK_IMPORTED_MODULE_6__.screenaa),\n/* harmony export */   sphereimposter: () => (/* reexport safe */ _sphereimposter__WEBPACK_IMPORTED_MODULE_7__.sphereimposter),\n/* harmony export */   sphereimposteroutline: () => (/* reexport safe */ _sphereimposteroutline__WEBPACK_IMPORTED_MODULE_8__.sphereimposteroutline),\n/* harmony export */   sprite: () => (/* reexport safe */ _sprite__WEBPACK_IMPORTED_MODULE_9__.sprite),\n/* harmony export */   stickimposter: () => (/* reexport safe */ _stickimposter__WEBPACK_IMPORTED_MODULE_10__.stickimposter),\n/* harmony export */   stickimposteroutline: () => (/* reexport safe */ _stickimposteroutline__WEBPACK_IMPORTED_MODULE_11__.stickimposteroutline),\n/* harmony export */   volumetric: () => (/* reexport safe */ _volumetric__WEBPACK_IMPORTED_MODULE_12__.volumetric)\n/* harmony export */ });\n/* harmony import */ var _basic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basic */ \"./src/WebGL/shaders/lib/basic/index.ts\");\n/* harmony import */ var _instanced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanced */ \"./src/WebGL/shaders/lib/instanced/index.ts\");\n/* harmony import */ var _lambert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lambert */ \"./src/WebGL/shaders/lib/lambert/index.ts\");\n/* harmony import */ var _lambertdouble__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lambertdouble */ \"./src/WebGL/shaders/lib/lambertdouble/index.ts\");\n/* harmony import */ var _outline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./outline */ \"./src/WebGL/shaders/lib/outline/index.ts\");\n/* harmony import */ var _screen__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./screen */ \"./src/WebGL/shaders/lib/screen/index.ts\");\n/* harmony import */ var _screenaa__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./screenaa */ \"./src/WebGL/shaders/lib/screenaa/index.ts\");\n/* harmony import */ var _sphereimposter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sphereimposter */ \"./src/WebGL/shaders/lib/sphereimposter/index.ts\");\n/* harmony import */ var _sphereimposteroutline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sphereimposteroutline */ \"./src/WebGL/shaders/lib/sphereimposteroutline/index.ts\");\n/* harmony import */ var _sprite__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sprite */ \"./src/WebGL/shaders/lib/sprite/index.ts\");\n/* harmony import */ var _stickimposter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./stickimposter */ \"./src/WebGL/shaders/lib/stickimposter/index.ts\");\n/* harmony import */ var _stickimposteroutline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./stickimposteroutline */ \"./src/WebGL/shaders/lib/stickimposteroutline/index.ts\");\n/* harmony import */ var _volumetric__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./volumetric */ \"./src/WebGL/shaders/lib/volumetric/index.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ShaderLib = {\n    basic: _basic__WEBPACK_IMPORTED_MODULE_0__.basic,\n    instanced: _instanced__WEBPACK_IMPORTED_MODULE_1__.instanced,\n    lambert: _lambert__WEBPACK_IMPORTED_MODULE_2__.lambert,\n    lambertdouble: _lambertdouble__WEBPACK_IMPORTED_MODULE_3__.lambertdouble,\n    outline: _outline__WEBPACK_IMPORTED_MODULE_4__.outline,\n    screen: _screen__WEBPACK_IMPORTED_MODULE_5__.screen,\n    screenaa: _screenaa__WEBPACK_IMPORTED_MODULE_6__.screenaa,\n    sphereimposter: _sphereimposter__WEBPACK_IMPORTED_MODULE_7__.sphereimposter,\n    sphereimposteroutline: _sphereimposteroutline__WEBPACK_IMPORTED_MODULE_8__.sphereimposteroutline,\n    sprite: _sprite__WEBPACK_IMPORTED_MODULE_9__.sprite,\n    stickimposter: _stickimposter__WEBPACK_IMPORTED_MODULE_10__.stickimposter,\n    stickimposteroutline: _stickimposteroutline__WEBPACK_IMPORTED_MODULE_11__.stickimposteroutline,\n    volumetric: _volumetric__WEBPACK_IMPORTED_MODULE_12__.volumetric,\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/instanced/index.ts":
/*!**************************************************!*\
  !*** ./src/WebGL/shaders/lib/instanced/index.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   instanced: () => (/* binding */ instanced)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/instanced/uniforms.ts\");\n/* harmony import */ var _instanced_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanced.frag */ \"./src/WebGL/shaders/lib/instanced/instanced.frag\");\n/* harmony import */ var _instanced_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_instanced_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _instanced_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanced.vert */ \"./src/WebGL/shaders/lib/instanced/instanced.vert\");\n/* harmony import */ var _instanced_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_instanced_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from \"fs\"\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"./instanced.frag\", \"utf8\")\n//const vertexShader = fs.readFileSync(__dirname + \"./instanced.vert\", \"utf8\") \nconst instanced = {\n    fragmentShader: _instanced_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: _instanced_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms,\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/instanced/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/instanced/uniforms.ts":
/*!*****************************************************!*\
  !*** ./src/WebGL/shaders/lib/instanced/uniforms.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 },\n    directionalLightColor: { type: 'fv', value: [] },\n    directionalLightDirection: { type: 'fv', value: [] }\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/instanced/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/lambert/index.ts":
/*!************************************************!*\
  !*** ./src/WebGL/shaders/lib/lambert/index.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lambert: () => (/* binding */ lambert)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/lambert/uniforms.ts\");\n/* harmony import */ var _lambert_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lambert.frag */ \"./src/WebGL/shaders/lib/lambert/lambert.frag\");\n/* harmony import */ var _lambert_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lambert_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lambert_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lambert.vert */ \"./src/WebGL/shaders/lib/lambert/lambert.vert\");\n/* harmony import */ var _lambert_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lambert_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from 'fs';\n//\n//const fragmentShader = fs.readFileSync(__dirname + '/lambert.frag', 'utf8');\n//const vertexShader = fs.readFileSync(__dirname + '/lambert.vert', 'utf8');\nconst lambert = {\n    fragmentShader: _lambert_frag__WEBPACK_IMPORTED_MODULE_1___default().replace('#define GLSLIFY 1', ''),\n    vertexShader: _lambert_vert__WEBPACK_IMPORTED_MODULE_2___default().replace('#define GLSLIFY 1', ''),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms,\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/lambert/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/lambert/uniforms.ts":
/*!***************************************************!*\
  !*** ./src/WebGL/shaders/lib/lambert/uniforms.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 },\n    directionalLightColor: { type: 'fv', value: [] },\n    directionalLightDirection: { type: 'fv', value: [] }\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/lambert/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/lambertdouble/index.ts":
/*!******************************************************!*\
  !*** ./src/WebGL/shaders/lib/lambertdouble/index.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lambertdouble: () => (/* binding */ lambertdouble)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/lambertdouble/uniforms.ts\");\n/* harmony import */ var _lambertdouble_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lambertdouble.frag */ \"./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag\");\n/* harmony import */ var _lambertdouble_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lambertdouble_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lambertdouble_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lambertdouble.vert */ \"./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert\");\n/* harmony import */ var _lambertdouble_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lambertdouble_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from 'fs';\n//\n//const fragmentShader = fs.readFileSync(__dirname + '/lambertdouble.frag', 'utf8');\n//const vertexShader = fs.readFileSync(__dirname + '/lambertdouble.vert', 'utf8');\nconst lambertdouble = {\n    fragmentShader: _lambertdouble_frag__WEBPACK_IMPORTED_MODULE_1___default().replace('#define GLSLIFY 1', ''),\n    vertexShader: _lambertdouble_vert__WEBPACK_IMPORTED_MODULE_2___default().replace('#define GLSLIFY 1', ''),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/lambertdouble/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts":
/*!*********************************************************!*\
  !*** ./src/WebGL/shaders/lib/lambertdouble/uniforms.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 },\n    directionalLightColor: { type: 'fv', value: [] },\n    directionalLightDirection: { type: 'fv', value: [] }\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/lambertdouble/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/outline/index.ts":
/*!************************************************!*\
  !*** ./src/WebGL/shaders/lib/outline/index.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   outline: () => (/* binding */ outline)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/outline/uniforms.ts\");\n/* harmony import */ var _outline_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./outline.frag */ \"./src/WebGL/shaders/lib/outline/outline.frag\");\n/* harmony import */ var _outline_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_outline_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _outline_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./outline.vert */ \"./src/WebGL/shaders/lib/outline/outline.vert\");\n/* harmony import */ var _outline_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_outline_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from \"fs\";\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"/outline.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"/outline.vert\", \"utf8\");\nconst outline = {\n    fragmentShader: _outline_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: _outline_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms,\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/outline/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/outline/uniforms.ts":
/*!***************************************************!*\
  !*** ./src/WebGL/shaders/lib/outline/uniforms.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: \"f\", value: 1.0 },\n    outlineColor: { type: \"c\", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0) },\n    fogColor: { type: \"c\", value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: \"f\", value: 1.0 },\n    fogFar: { type: \"f\", value: 2000 },\n    outlineWidth: { type: \"f\", value: 0.1 },\n    outlinePushback: { type: \"f\", value: 1.0 },\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/outline/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/screen/index.ts":
/*!***********************************************!*\
  !*** ./src/WebGL/shaders/lib/screen/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   screen: () => (/* binding */ screen)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/screen/uniforms.ts\");\n/* harmony import */ var _screen_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./screen.frag */ \"./src/WebGL/shaders/lib/screen/screen.frag\");\n/* harmony import */ var _screen_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_screen_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _screen_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./screen.vert */ \"./src/WebGL/shaders/lib/screen/screen.vert\");\n/* harmony import */ var _screen_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_screen_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst screen = {\n    fragmentShader: _screen_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: _screen_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/screen/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/screen/uniforms.ts":
/*!**************************************************!*\
  !*** ./src/WebGL/shaders/lib/screen/uniforms.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\nconst uniforms = {};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/screen/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/screenaa/index.ts":
/*!*************************************************!*\
  !*** ./src/WebGL/shaders/lib/screenaa/index.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   screenaa: () => (/* binding */ screenaa)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/screenaa/uniforms.ts\");\n/* harmony import */ var _screenaa_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./screenaa.frag */ \"./src/WebGL/shaders/lib/screenaa/screenaa.frag\");\n/* harmony import */ var _screenaa_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_screenaa_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _screenaa_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./screenaa.vert */ \"./src/WebGL/shaders/lib/screenaa/screenaa.vert\");\n/* harmony import */ var _screenaa_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_screenaa_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from \"fs\"\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"/screenaa.frag\", \"utf8\")\n//const vertexShader = fs.readFileSync(__dirname + \"/screenaa.vert\", \"utf8\")\nconst screenaa = {\n    fragmentShader: _screenaa_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: _screenaa_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/screenaa/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/screenaa/uniforms.ts":
/*!****************************************************!*\
  !*** ./src/WebGL/shaders/lib/screenaa/uniforms.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\nconst uniforms = {};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/screenaa/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sphereimposter/index.ts":
/*!*******************************************************!*\
  !*** ./src/WebGL/shaders/lib/sphereimposter/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sphereimposter: () => (/* binding */ sphereimposter)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/sphereimposter/uniforms.ts\");\n/* harmony import */ var _sphereimposter_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sphereimposter.frag */ \"./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag\");\n/* harmony import */ var _sphereimposter_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sphereimposter_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _sphereimposter_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sphereimposter.vert */ \"./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert\");\n/* harmony import */ var _sphereimposter_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_sphereimposter_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from \"fs\"\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"./sphereimposter.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"./sphereimposter.vert\", \"utf8\");\nconst sphereimposter = {\n    vertexShader: _sphereimposter_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    fragmentShader: _sphereimposter_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sphereimposter/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts":
/*!**********************************************************!*\
  !*** ./src/WebGL/shaders/lib/sphereimposter/uniforms.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 },\n    directionalLightColor: { type: 'fv', value: [] },\n    directionalLightDirection: { type: 'fv', value: [] }\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sphereimposter/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts":
/*!**************************************************************!*\
  !*** ./src/WebGL/shaders/lib/sphereimposteroutline/index.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sphereimposteroutline: () => (/* binding */ sphereimposteroutline)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts\");\n/* harmony import */ var _sphereimposteroutline_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sphereimposteroutline.frag */ \"./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag\");\n/* harmony import */ var _sphereimposteroutline_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sphereimposteroutline_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _sphereimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sphereimposteroutline.vert */ \"./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert\");\n/* harmony import */ var _sphereimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_sphereimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from 'fs';\n//const fragmentShader = fs.readFileSync(__dirname + \"/sphereimposteroutline.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"/sphereimposteroutline.vert\", \"utf8\");\nconst sphereimposteroutline = {\n    fragmentShader: _sphereimposteroutline_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: _sphereimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sphereimposteroutline/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts":
/*!*****************************************************************!*\
  !*** ./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    outlineColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0) },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 },\n    outlineWidth: { type: 'f', value: 0.1 },\n    outlinePushback: { type: 'f', value: 1.0 },\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sprite/index.ts":
/*!***********************************************!*\
  !*** ./src/WebGL/shaders/lib/sprite/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sprite: () => (/* binding */ sprite)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/sprite/uniforms.ts\");\n/* harmony import */ var _sprite_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sprite.frag */ \"./src/WebGL/shaders/lib/sprite/sprite.frag\");\n/* harmony import */ var _sprite_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sprite_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _sprite_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sprite.vert */ \"./src/WebGL/shaders/lib/sprite/sprite.vert\");\n/* harmony import */ var _sprite_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_sprite_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n//import { fragmentShader, vertexShader } from \"./shaders\"\n\n\n//const fragmentShader = fs.readFileSync(path.resove(__dirname, \"./sprite.frag\"), \"utf8\")\n//const vertexShader = fs.readFileSync(path.resove(__dirname, \"./sprite.vert\"), \"utf8\")\nconst sprite = {\n    fragmentShader: _sprite_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: _sprite_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sprite/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sprite/uniforms.ts":
/*!**************************************************!*\
  !*** ./src/WebGL/shaders/lib/sprite/uniforms.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\nconst uniforms = {};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sprite/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/stickimposter/index.ts":
/*!******************************************************!*\
  !*** ./src/WebGL/shaders/lib/stickimposter/index.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stickimposter: () => (/* binding */ stickimposter)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/stickimposter/uniforms.ts\");\n/* harmony import */ var _utils_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/stickimposterFragmentShader.partial.frag */ \"./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag\");\n/* harmony import */ var _utils_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _stickimposter_partial_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stickimposter.partial.frag */ \"./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag\");\n/* harmony import */ var _stickimposter_partial_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_stickimposter_partial_frag__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _stickimposter_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stickimposter.vert */ \"./src/WebGL/shaders/lib/stickimposter/stickimposter.vert\");\n/* harmony import */ var _stickimposter_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_stickimposter_vert__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n//import fs from \"fs\"\n//const stickimposterFragmentShaderStart = fs.readFileSync(__dirname + \"../../utils/stickimposterFragmentShader.partial.frag\", \"utf8\");\n//const stickimposterFragmentShaderEnd = fs.readFileSync(__dirname + \"./stickimposter.partial.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"./stickimposter.vert\", \"utf8\");\nconst fragmentShader = [(_utils_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1___default()), (_stickimposter_partial_frag__WEBPACK_IMPORTED_MODULE_2___default())].join('\\n');\nconst stickimposter = {\n    fragmentShader: fragmentShader.replace('#define GLSLIFY 1', ''),\n    vertexShader: _stickimposter_vert__WEBPACK_IMPORTED_MODULE_3___default().replace('#define GLSLIFY 1', ''),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/stickimposter/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/stickimposter/uniforms.ts":
/*!*********************************************************!*\
  !*** ./src/WebGL/shaders/lib/stickimposter/uniforms.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 },\n    directionalLightColor: { type: 'fv', value: [] },\n    directionalLightDirection: { type: 'fv', value: [] }\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/stickimposter/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/stickimposteroutline/index.ts":
/*!*************************************************************!*\
  !*** ./src/WebGL/shaders/lib/stickimposteroutline/index.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stickimposteroutline: () => (/* binding */ stickimposteroutline)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts\");\n/* harmony import */ var _utils_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/stickimposterFragmentShader.partial.frag */ \"./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag\");\n/* harmony import */ var _utils_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _stickimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stickimposteroutline.vert */ \"./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert\");\n/* harmony import */ var _stickimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_stickimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from 'fs';\n//const stickimposterFragmentShaderStart = fs.readFileSync(__dirname + '/stickimposterFragmentShader.partial.frag', 'utf8');\n//const vertexShader = fs.readFileSync(__dirname + '/stickimposteroutline.vert', 'utf8');\nconst fragmentShader = (_utils_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1___default()) + 'gl_FragColor = vec4(color,1.0);}';\nconst stickimposteroutline = {\n    fragmentShader: fragmentShader.replace('#define GLSLIFY 1', ''),\n    vertexShader: _stickimposteroutline_vert__WEBPACK_IMPORTED_MODULE_2___default().replace('#define GLSLIFY 1', ''),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/stickimposteroutline/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts":
/*!****************************************************************!*\
  !*** ./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 },\n    outlineColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0) },\n    outlineWidth: { type: 'f', value: 0.1 },\n    outlinePushback: { type: 'f', value: 1.0 },\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/volumetric/index.ts":
/*!***************************************************!*\
  !*** ./src/WebGL/shaders/lib/volumetric/index.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   volumetric: () => (/* binding */ volumetric)\n/* harmony export */ });\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniforms */ \"./src/WebGL/shaders/lib/volumetric/uniforms.ts\");\n/* harmony import */ var _volumetric_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./volumetric.frag */ \"./src/WebGL/shaders/lib/volumetric/volumetric.frag\");\n/* harmony import */ var _volumetric_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_volumetric_frag__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _volumetric_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./volumetric.vert */ \"./src/WebGL/shaders/lib/volumetric/volumetric.vert\");\n/* harmony import */ var _volumetric_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_volumetric_vert__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n//import fs from \"fs\";\n//\n//const fragmentShader = fs.readFileSync(__dirname + \"/volumetric.frag\", \"utf8\");\n//const vertexShader = fs.readFileSync(__dirname + \"/volumetric.vert\", \"utf8\");\nconst volumetric = {\n    fragmentShader: _volumetric_frag__WEBPACK_IMPORTED_MODULE_1___default().replace(\"#define GLSLIFY 1\", \"\"),\n    vertexShader: _volumetric_vert__WEBPACK_IMPORTED_MODULE_2___default().replace(\"#define GLSLIFY 1\", \"\"),\n    uniforms: _uniforms__WEBPACK_IMPORTED_MODULE_0__.uniforms\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/volumetric/index.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/volumetric/uniforms.ts":
/*!******************************************************!*\
  !*** ./src/WebGL/shaders/lib/volumetric/uniforms.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uniforms: () => (/* binding */ uniforms)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../colors */ \"./src/colors.ts\");\n\nconst uniforms = {\n    opacity: { type: 'f', value: 1.0 },\n    fogColor: { type: 'c', value: new _colors__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0) },\n    fogNear: { type: 'f', value: 1.0 },\n    fogFar: { type: 'f', value: 2000 },\n    data: { type: 'i', value: 3 },\n    colormap: { type: 'i', value: 4 },\n    depthmap: { type: 'i', value: 5 },\n    step: { type: 'f', value: 1.0 },\n    maxdepth: { type: 'f', value: 100.0 },\n    subsamples: { type: 'f', value: 5.0 },\n    textmat: { type: 'mat4', value: [] },\n    projinv: { type: 'mat4', value: [] },\n    transfermin: { type: 'f', value: -0.2 },\n    transfermax: { type: 'f', value: 0.2 },\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/volumetric/uniforms.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/utils/clone.ts":
/*!******************************************!*\
  !*** ./src/WebGL/shaders/utils/clone.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clone: () => (/* binding */ clone)\n/* harmony export */ });\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../colors */ \"./src/colors.ts\");\n\nfunction clone(uniforms_src) {\n    let uniforms_clone = {};\n    for (const u in uniforms_src) {\n        uniforms_clone[u] = {};\n        uniforms_clone[u].type = uniforms_src[u].type;\n        var srcValue = uniforms_src[u].value;\n        if (srcValue instanceof _colors__WEBPACK_IMPORTED_MODULE_0__.Color)\n            uniforms_clone[u].value = srcValue.clone();\n        else if (typeof srcValue === \"number\")\n            uniforms_clone[u].value = srcValue;\n        else if (srcValue instanceof Array)\n            uniforms_clone[u].value = [];\n        else\n            console.error(\"Error copying shader uniforms from ShaderLib: unknown type for uniform\");\n    }\n    return uniforms_clone;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/utils/clone.ts?");

/***/ }),

/***/ "./src/WebGL/shaders/utils/index.ts":
/*!******************************************!*\
  !*** ./src/WebGL/shaders/utils/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderUtils: () => (/* binding */ ShaderUtils),\n/* harmony export */   clone: () => (/* reexport safe */ _clone__WEBPACK_IMPORTED_MODULE_0__.clone)\n/* harmony export */ });\n/* harmony import */ var _clone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clone */ \"./src/WebGL/shaders/utils/clone.ts\");\n/* harmony import */ var _stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stickimposterFragmentShader.partial.frag */ \"./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag\");\n/* harmony import */ var _stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst ShaderUtils = {\n    clone: _clone__WEBPACK_IMPORTED_MODULE_0__.clone,\n    stickimposterFragmentShader: (_stickimposterFragmentShader_partial_frag__WEBPACK_IMPORTED_MODULE_1___default())\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/utils/index.ts?");

/***/ }),

/***/ "./src/WebGL/shapes/Cylinder.ts":
/*!**************************************!*\
  !*** ./src/WebGL/shapes/Cylinder.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cylinder: () => (/* binding */ Cylinder)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n\nlet vector = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n//Bounding cylinder for stick render\n/** @class\n *  @subcategory  Math\n * */\nclass Cylinder {\n    constructor(c1 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(), c2 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(), radius = 0) {\n        this.c1 = c1;\n        this.c2 = c2;\n        this.radius = radius;\n        this.direction = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n            .subVectors(this.c2, this.c1)\n            .normalize();\n    }\n    copy(cylinder) {\n        this.c1.copy(cylinder.c1);\n        this.c2.copy(cylinder.c2);\n        this.direction.copy(cylinder.direction);\n        this.radius = cylinder.radius;\n        return this;\n    }\n    lengthSq() {\n        return vector.subVectors(this.c2, this.c1).lengthSq();\n    }\n    applyMatrix4(matrix) {\n        this.direction.add(this.c1).applyMatrix4(matrix);\n        this.c1.applyMatrix4(matrix);\n        this.c2.applyMatrix4(matrix);\n        this.direction.sub(this.c1).normalize();\n        this.radius = this.radius * matrix.getMaxScaleOnAxis();\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shapes/Cylinder.ts?");

/***/ }),

/***/ "./src/WebGL/shapes/Sphere.ts":
/*!************************************!*\
  !*** ./src/WebGL/shapes/Sphere.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sphere: () => (/* binding */ Sphere)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n\n//Intersection sphere and box shapes.\n//Intersection sphere for sphere, stick render\n/** @class\n *  @subcategory  Math\n * */\nclass Sphere {\n    constructor(center = { x: 0, y: 0, z: 0 }, radius = 0) {\n        this.center = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(center.x, center.y, center.z);\n        this.radius = radius;\n    }\n    set(center, radius) {\n        this.center.copy(center);\n        this.radius = radius;\n        return this;\n    }\n    copy(sphere) {\n        this.center.copy(sphere.center);\n        this.radius = sphere.radius;\n        return this;\n    }\n    applyMatrix4(matrix) {\n        this.center.applyMatrix4(matrix);\n        this.radius = this.radius * matrix.getMaxScaleOnAxis();\n        return this;\n    }\n    translate(offset) {\n        this.center.add(offset);\n        return this;\n    }\n    equals(sphere) {\n        return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n    clone() {\n        return new Sphere().copy(this);\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shapes/Sphere.ts?");

/***/ }),

/***/ "./src/WebGL/shapes/Triangle.ts":
/*!**************************************!*\
  !*** ./src/WebGL/shapes/Triangle.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Triangle: () => (/* binding */ Triangle)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./src/WebGL/math/index.ts\");\n\nconst v1 = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n/**   plane specified by three points\n\n *  @class\n *  @subcategory  Math\n *\n *\n */\nclass Triangle {\n    constructor(a = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(), b = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3(), c = new _math__WEBPACK_IMPORTED_MODULE_0__.Vector3()) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    copy(triangle) {\n        this.a.copy(triangle.a);\n        this.b.copy(triangle.b);\n        this.c.copy(triangle.c);\n        return this;\n    }\n    applyMatrix4(matrix) {\n        this.a.applyMatrix4(matrix);\n        this.b.applyMatrix4(matrix);\n        this.c.applyMatrix4(matrix);\n        return this;\n    }\n    getNormal() {\n        var norm = this.a.clone();\n        norm.sub(this.b);\n        v1.subVectors(this.c, this.b);\n        norm.cross(v1);\n        norm.normalize();\n        return norm;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shapes/Triangle.ts?");

/***/ }),

/***/ "./src/WebGL/shapes/index.ts":
/*!***********************************!*\
  !*** ./src/WebGL/shapes/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cylinder: () => (/* reexport safe */ _Cylinder__WEBPACK_IMPORTED_MODULE_1__.Cylinder),\n/* harmony export */   Sphere: () => (/* reexport safe */ _Sphere__WEBPACK_IMPORTED_MODULE_0__.Sphere),\n/* harmony export */   Triangle: () => (/* reexport safe */ _Triangle__WEBPACK_IMPORTED_MODULE_2__.Triangle)\n/* harmony export */ });\n/* harmony import */ var _Sphere__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sphere */ \"./src/WebGL/shapes/Sphere.ts\");\n/* harmony import */ var _Cylinder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Cylinder */ \"./src/WebGL/shapes/Cylinder.ts\");\n/* harmony import */ var _Triangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Triangle */ \"./src/WebGL/shapes/Triangle.ts\");\n\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shapes/index.ts?");

/***/ }),

/***/ "./src/colors.ts":
/*!***********************!*\
  !*** ./src/colors.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CC: () => (/* binding */ CC),\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   builtinColorSchemes: () => (/* binding */ builtinColorSchemes),\n/* harmony export */   chains: () => (/* binding */ chains),\n/* harmony export */   elementColors: () => (/* binding */ elementColors),\n/* harmony export */   htmlColors: () => (/* binding */ htmlColors),\n/* harmony export */   residues: () => (/* binding */ residues),\n/* harmony export */   ssColors: () => (/* binding */ ssColors)\n/* harmony export */ });\n/**\n * @class\n   *\n   * @param r red 8bit number or numeric value of full color\n   * @param g green 8bit number\n   * @param b blue 8bit number\n   */\nclass Color {\n    constructor(r, g, b) {\n        this.r = 0.0;\n        this.g = 0.0;\n        this.b = 0.0;\n        if (arguments.length > 1 && typeof r === \"number\") {\n            this.r = r || 0.0;\n            this.g = g || 0.0;\n            this.b = b || 0.0;\n            return this;\n        }\n        return this.set(r || 0.0);\n    }\n    set(val) {\n        if (val instanceof Color)\n            return val.clone();\n        else if (typeof val === \"number\")\n            this.setHex(val);\n        else if (typeof val === \"object\") {\n            this.r = (val === null || val === void 0 ? void 0 : val.r) || 0.0;\n            this.g = (val === null || val === void 0 ? void 0 : val.g) || 0.0;\n            this.b = (val === null || val === void 0 ? void 0 : val.b) || 0.0;\n        }\n        return this;\n    }\n    setHex(hex) {\n        hex = Math.floor(hex);\n        this.r = ((hex >> 16) & 255) / 255;\n        this.g = ((hex >> 8) & 255) / 255;\n        this.b = (hex & 255) / 255;\n        return this;\n    }\n    getHex() {\n        var R = Math.round(this.r * 255);\n        var G = Math.round(this.g * 255);\n        var B = Math.round(this.b * 255);\n        return (R << 16) | (G << 8) | B;\n    }\n    clone() {\n        return new Color(this.r, this.g, this.b);\n    }\n    copy(color) {\n        this.r = color.r;\n        this.g = color.g;\n        this.b = color.b;\n        return this;\n    }\n    //return object that represents color components from 0 to 255\n    scaled() {\n        var ret = {};\n        ret.r = Math.round(this.r * 255);\n        ret.g = Math.round(this.g * 255);\n        ret.b = Math.round(this.b * 255);\n        ret.a = 1.0;\n        return ret;\n    }\n}\n// in an attempt to reduce memory overhead, cache all $3Dmol.Colors\n// this makes things a little faster\nclass CC {\n    static color(hex) {\n        // Undefined values default to black\n        if (!hex)\n            return CC.cache[0];\n        //noop\n        if (hex instanceof Color) {\n            return hex;\n        }\n        // cache hits\n        if (typeof hex === \"number\" && typeof CC.cache[hex] !== \"undefined\")\n            return CC.cache[hex];\n        // arrays\n        if (hex && Array.isArray(hex))\n            // parse elements recursively\n            return hex.map(CC.color);\n        // numbers and hex strings\n        let hexval = CC.getHex(hex);\n        let c = new Color(hexval);\n        CC.cache[hexval] = c;\n        return c;\n    }\n    static getHex(hex) {\n        var _a;\n        if (Array.isArray(hex))\n            return hex.map(CC.getHex);\n        if (typeof hex === \"string\") {\n            let hexs = hex;\n            if (!isNaN(parseInt(hexs)))\n                return parseInt(hexs);\n            hexs = hexs.trim();\n            if (hexs.length == 4 && hexs[0] == \"#\") {\n                hexs = \"#\" + hexs[1] + hexs[1] + hexs[2] + hexs[2] + hexs[3] + hexs[3]; //expand to full hex number\n            }\n            if (hexs.length == 7 && hexs[0] == \"#\") {\n                return parseInt(hexs.substring(1), 16);\n            }\n            let m = CC.rgbRegEx.exec(hexs);\n            if (m) {\n                if (m[1] != \"\") {\n                    console.log(\"WARNING: Opacity value in rgba ignored.  Specify separately as opacity attribute.\");\n                }\n                let ret = 0;\n                for (let i = 2; i < 5; i++) {\n                    ret *= 256;\n                    let val = m[i].endsWith(\"%\")\n                        ? (255 * parseFloat(m[i])) / 100\n                        : parseFloat(m[i]);\n                    ret += Math.round(val);\n                }\n                return ret;\n            }\n            return ((_a = window === null || window === void 0 ? void 0 : window.$3Dmol) === null || _a === void 0 ? void 0 : _a.htmlColors[hex.toLowerCase()]) || 0x000000;\n        }\n        return hex;\n    }\n}\nCC.rgbRegEx = /rgb(a?)\\(\\s*([^ ,\\)\\t]+)\\s*,\\s*([^ ,\\)\\t]+)\\s*,\\s*([^ ,\\)\\t]+)/i;\nCC.cache = { 0: new Color(0) };\nconst htmlColors = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgrey: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    grey: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgrey: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32,\n};\n/** Preset secondary structure color scheme\n * @struct\n */\nconst ssColors = {\n    //names are in helix-sheet-coil order\n    pyMol: { h: 0xff0000, s: 0xffff00, c: 0x00ff00 },\n    Jmol: { h: 0xff0080, s: 0xffc800, c: 0xffffff },\n};\nconst rasmol = {\n    H: 0xffffff,\n    He: 0xffc0cb,\n    HE: 0xffc0cb,\n    Li: 0xb22222,\n    LI: 0xb22222,\n    B: 0x00ff00,\n    C: 0xc8c8c8,\n    N: 0x8f8fff,\n    O: 0xf00000,\n    F: 0xdaa520,\n    Na: 0x0000ff,\n    NA: 0x0000ff,\n    Mg: 0x228b22,\n    MG: 0x228b22,\n    Al: 0x808090,\n    AL: 0x808090,\n    Si: 0xdaa520,\n    SI: 0xdaa520,\n    P: 0xffa500,\n    S: 0xffc832,\n    Cl: 0x00ff00,\n    CL: 0x00ff00,\n    Ca: 0x808090,\n    CA: 0x808090,\n    Ti: 0x808090,\n    TI: 0x808090,\n    Cr: 0x808090,\n    CR: 0x808090,\n    Mn: 0x808090,\n    MN: 0x808090,\n    Fe: 0xffa500,\n    FE: 0xffa500,\n    Ni: 0xa52a2a,\n    NI: 0xa52a2a,\n    Cu: 0xa52a2a,\n    CU: 0xa52a2a,\n    Zn: 0xa52a2a,\n    ZN: 0xa52a2a,\n    Br: 0xa52a2a,\n    BR: 0xa52a2a,\n    Ag: 0x808090,\n    AG: 0x808090,\n    I: 0xa020f0,\n    Ba: 0xffa500,\n    BA: 0xffa500,\n    Au: 0xdaa520,\n    AU: 0xdaa520,\n};\n/** Preset element coloring - from individual element colors to entire mappings (e.g. 'elementColors.Jmol' colors atoms with Jmol stylings)\n * @struct\n */\nconst elementColors = {\n    defaultColor: 0xff1493,\n    /** Jmol-like element colors*/\n    Jmol: {\n        H: 0xffffff,\n        He: 0xd9ffff,\n        HE: 0xd9ffff,\n        Li: 0xcc80ff,\n        LI: 0xcc80ff,\n        Be: 0xc2ff00,\n        BE: 0xc2ff00,\n        B: 0xffb5b5,\n        C: 0x909090,\n        N: 0x3050f8,\n        O: 0xff0d0d,\n        F: 0x90e050,\n        Ne: 0xb3e3f5,\n        NE: 0xb3e3f5,\n        Na: 0xab5cf2,\n        NA: 0xab5cf2,\n        Mg: 0x8aff00,\n        MG: 0x8aff00,\n        Al: 0xbfa6a6,\n        AL: 0xbfa6a6,\n        Si: 0xf0c8a0,\n        SI: 0xf0c8a0,\n        P: 0xff8000,\n        S: 0xffff30,\n        Cl: 0x1ff01f,\n        CL: 0x1ff01f,\n        Ar: 0x80d1e3,\n        AR: 0x80d1e3,\n        K: 0x8f40d4,\n        Ca: 0x3dff00,\n        CA: 0x3dff00,\n        Sc: 0xe6e6e6,\n        SC: 0xe6e6e6,\n        Ti: 0xbfc2c7,\n        TI: 0xbfc2c7,\n        V: 0xa6a6ab,\n        Cr: 0x8a99c7,\n        CR: 0x8a99c7,\n        Mn: 0x9c7ac7,\n        MN: 0x9c7ac7,\n        Fe: 0xe06633,\n        FE: 0xe06633,\n        Co: 0xf090a0,\n        CO: 0xf090a0,\n        Ni: 0x50d050,\n        NI: 0x50d050,\n        Cu: 0xc88033,\n        CU: 0xc88033,\n        Zn: 0x7d80b0,\n        ZN: 0x7d80b0,\n        Ga: 0xc28f8f,\n        GA: 0xc28f8f,\n        Ge: 0x668f8f,\n        GE: 0x668f8f,\n        As: 0xbd80e3,\n        AS: 0xbd80e3,\n        Se: 0xffa100,\n        SE: 0xffa100,\n        Br: 0xa62929,\n        BR: 0xa62929,\n        Kr: 0x5cb8d1,\n        KR: 0x5cb8d1,\n        Rb: 0x702eb0,\n        RB: 0x702eb0,\n        Sr: 0x00ff00,\n        SR: 0x00ff00,\n        Y: 0x94ffff,\n        Zr: 0x94e0e0,\n        ZR: 0x94e0e0,\n        Nb: 0x73c2c9,\n        NB: 0x73c2c9,\n        Mo: 0x54b5b5,\n        MO: 0x54b5b5,\n        Tc: 0x3b9e9e,\n        TC: 0x3b9e9e,\n        Ru: 0x248f8f,\n        RU: 0x248f8f,\n        Rh: 0x0a7d8c,\n        RH: 0x0a7d8c,\n        Pd: 0x006985,\n        PD: 0x006985,\n        Ag: 0xc0c0c0,\n        AG: 0xc0c0c0,\n        Cd: 0xffd98f,\n        CD: 0xffd98f,\n        In: 0xa67573,\n        IN: 0xa67573,\n        Sn: 0x668080,\n        SN: 0x668080,\n        Sb: 0x9e63b5,\n        SB: 0x9e63b5,\n        Te: 0xd47a00,\n        TE: 0xd47a00,\n        I: 0x940094,\n        Xe: 0x429eb0,\n        XE: 0x429eb0,\n        Cs: 0x57178f,\n        CS: 0x57178f,\n        Ba: 0x00c900,\n        BA: 0x00c900,\n        La: 0x70d4ff,\n        LA: 0x70d4ff,\n        Ce: 0xffffc7,\n        CE: 0xffffc7,\n        Pr: 0xd9ffc7,\n        PR: 0xd9ffc7,\n        Nd: 0xc7ffc7,\n        ND: 0xc7ffc7,\n        Pm: 0xa3ffc7,\n        PM: 0xa3ffc7,\n        Sm: 0x8fffc7,\n        SM: 0x8fffc7,\n        Eu: 0x61ffc7,\n        EU: 0x61ffc7,\n        Gd: 0x45ffc7,\n        GD: 0x45ffc7,\n        Tb: 0x30ffc7,\n        TB: 0x30ffc7,\n        Dy: 0x1fffc7,\n        DY: 0x1fffc7,\n        Ho: 0x00ff9c,\n        HO: 0x00ff9c,\n        Er: 0x00e675,\n        ER: 0x00e675,\n        Tm: 0x00d452,\n        TM: 0x00d452,\n        Yb: 0x00bf38,\n        YB: 0x00bf38,\n        Lu: 0x00ab24,\n        LU: 0x00ab24,\n        Hf: 0x4dc2ff,\n        HF: 0x4dc2ff,\n        Ta: 0x4da6ff,\n        TA: 0x4da6ff,\n        W: 0x2194d6,\n        Re: 0x267dab,\n        RE: 0x267dab,\n        Os: 0x266696,\n        OS: 0x266696,\n        Ir: 0x175487,\n        IR: 0x175487,\n        Pt: 0xd0d0e0,\n        PT: 0xd0d0e0,\n        Au: 0xffd123,\n        AU: 0xffd123,\n        Hg: 0xb8b8d0,\n        HG: 0xb8b8d0,\n        Tl: 0xa6544d,\n        TL: 0xa6544d,\n        Pb: 0x575961,\n        PB: 0x575961,\n        Bi: 0x9e4fb5,\n        BI: 0x9e4fb5,\n        Po: 0xab5c00,\n        PO: 0xab5c00,\n        At: 0x754f45,\n        AT: 0x754f45,\n        Rn: 0x428296,\n        RN: 0x428296,\n        Fr: 0x420066,\n        FR: 0x420066,\n        Ra: 0x007d00,\n        RA: 0x007d00,\n        Ac: 0x70abfa,\n        AC: 0x70abfa,\n        Th: 0x00baff,\n        TH: 0x00baff,\n        Pa: 0x00a1ff,\n        PA: 0x00a1ff,\n        U: 0x008fff,\n        Np: 0x0080ff,\n        NP: 0x0080ff,\n        Pu: 0x006bff,\n        PU: 0x006bff,\n        Am: 0x545cf2,\n        AM: 0x545cf2,\n        Cm: 0x785ce3,\n        CM: 0x785ce3,\n        Bk: 0x8a4fe3,\n        BK: 0x8a4fe3,\n        Cf: 0xa136d4,\n        CF: 0xa136d4,\n        Es: 0xb31fd4,\n        ES: 0xb31fd4,\n        Fm: 0xb31fba,\n        FM: 0xb31fba,\n        Md: 0xb30da6,\n        MD: 0xb30da6,\n        No: 0xbd0d87,\n        NO: 0xbd0d87,\n        Lr: 0xc70066,\n        LR: 0xc70066,\n        Rf: 0xcc0059,\n        RF: 0xcc0059,\n        Db: 0xd1004f,\n        DB: 0xd1004f,\n        Sg: 0xd90045,\n        SG: 0xd90045,\n        Bh: 0xe00038,\n        BH: 0xe00038,\n        Hs: 0xe6002e,\n        HS: 0xe6002e,\n        Mt: 0xeb0026,\n        MT: 0xeb0026,\n    },\n    /** rasmol-like element colors */\n    rasmol,\n    defaultColors: Object.assign({}, rasmol),\n    greenCarbon: Object.assign(Object.assign({}, rasmol), { C: 0x00ff00 }),\n    cyanCarbon: Object.assign(Object.assign({}, rasmol), { C: 0x00ffff }),\n    magentaCarbon: Object.assign(Object.assign({}, rasmol), { C: 0xff00ff }),\n    yellowCarbon: Object.assign(Object.assign({}, rasmol), { C: 0xffff00 }),\n    whiteCarbon: Object.assign(Object.assign({}, rasmol), { C: 0xffffff }),\n    orangeCarbon: Object.assign(Object.assign({}, rasmol), { C: 0xffa500 }),\n    purpleCarbon: Object.assign(Object.assign({}, rasmol), { C: 0x800080 }),\n    blueCarbon: Object.assign(Object.assign({}, rasmol), { C: 0x0000ff }),\n};\nconst residues = {\n    /** @property standard amino acid color scheme*/\n    amino: {\n        ALA: 0xc8c8c8,\n        ARG: 0x145aff,\n        ASN: 0x00dcdc,\n        ASP: 0xe60a0a,\n        CYS: 0xe6e600,\n        GLN: 0x00dcdc,\n        GLU: 0xe60a0a,\n        GLY: 0xebebeb,\n        HIS: 0x8282d2,\n        ILE: 0x0f820f,\n        LEU: 0x0f820f,\n        LYS: 0x145aff,\n        MET: 0xe6e600,\n        PHE: 0x3232aa,\n        PRO: 0xdc9682,\n        SER: 0xfa9600,\n        THR: 0xfa9600,\n        TRP: 0xb45ab4,\n        TYR: 0x3232aa,\n        VAL: 0x0f820f,\n        ASX: 0xff69b4,\n        GLX: 0xff69b4,\n    },\n    /** @property shapely amino acid color scheme*/\n    shapely: {\n        ALA: 0x8cff8c,\n        ARG: 0x00007c,\n        ASN: 0xff7c70,\n        ASP: 0xa00042,\n        CYS: 0xffff70,\n        GLN: 0xff4c4c,\n        GLU: 0x660000,\n        GLY: 0xffffff,\n        HIS: 0x7070ff,\n        ILE: 0x004c00,\n        LEU: 0x455e45,\n        LYS: 0x4747b8,\n        MET: 0xb8a042,\n        PHE: 0x534c52,\n        PRO: 0x525252,\n        SER: 0xff7042,\n        THR: 0xb84c00,\n        TRP: 0x4f4600,\n        TYR: 0x8c704c,\n        VAL: 0xff8cff,\n        ASX: 0xff00ff,\n        GLX: 0xff00ff,\n    },\n    /** @property nucleic acid color scheme*/\n    nucleic: {\n        A: 0xa0a0ff,\n        G: 0xff7070,\n        I: 0x80ffff,\n        C: 0xff8c4b,\n        T: 0xa0ffa0,\n        U: 0xff8080,\n    },\n};\nconst chains = {\n    /** @property chain based standard color scheme */\n    atom: {\n        A: 0xc0d0ff,\n        B: 0xb0ffb0,\n        C: 0xffc0c8,\n        D: 0xffff80,\n        E: 0xffc0ff,\n        F: 0xb0f0f0,\n        G: 0xffd070,\n        H: 0xf08080,\n        I: 0xf5deb3,\n        J: 0x00bfff,\n        K: 0xcd5c5c,\n        L: 0x66cdaa,\n        M: 0x9acd32,\n        N: 0xee82ee,\n        O: 0x00ced1,\n        P: 0x00ff7f,\n        Q: 0x3cb371,\n        R: 0x00008b,\n        S: 0xbdb76b,\n        T: 0x006400,\n        U: 0x800000,\n        V: 0x808000,\n        W: 0x800080,\n        X: 0x008080,\n        Y: 0xb8860b,\n        Z: 0xb22222,\n    },\n    /** @property hetatm color scheme */\n    hetatm: {\n        A: 0x90a0cf,\n        B: 0x80cf98,\n        C: 0xcf90b0,\n        D: 0xcfcf70,\n        E: 0xcf90cf,\n        F: 0x80c0c0,\n        G: 0xcfa060,\n        H: 0xc05070,\n        I: 0xc5ae83,\n        J: 0x00a7cf,\n        K: 0xb54c4c,\n        L: 0x56b592,\n        M: 0x8ab52a,\n        N: 0xbe72be,\n        O: 0x00b6a1,\n        P: 0x00cf6f,\n        Q: 0x349b61,\n        R: 0x0000bb,\n        S: 0xa59f5b,\n        T: 0x009400,\n        U: 0xb00000,\n        V: 0xb0b000,\n        W: 0xb000b0,\n        X: 0x00b0b0,\n        Y: 0xe8b613,\n        Z: 0xc23232,\n    },\n};\n/**\n * built in color schemes\n * The user can pass these strings directly as the colorscheme\n * @prop ssPyMol - pymol secondary structure\n * @prop  ssJmol - jmol secondary structure\n   @prop Jmol - jmol element defaults\n   @prop amino - amino acid coloring\n   @prop shapely - amino acid coloring\n   @prop nucleic - nucleic acid coloring\n   @prop chain - color by chain\n   @prop rasmol - rasmol default element coloring\n   @prop default - default element coloring\n   @prop greenCarbon - default element coloring with green carbon\n   @prop cyanCarbon - default element coloring with cyan carbon\n   @prop magentaCarbon - default element coloring with magenta carbon\n   @prop purpleCarbon - default element coloring with purple carbon\n   @prop whiteCarbon - default element coloring with white carbon\n   @prop orangeCarbon - default element coloring with orange carbon\n   @prop yellowCarbon - default element coloring with yellow carbon\n   @prop blueCarbon - default element coloring with blue carbon\n   @prop chainHetatm - color chains\n *\n * @example window.$3Dmol.download(\"pdb:4UAA\",viewer,{},function(){\n *    viewer.setBackgroundColor(0xffffffff);\n *    var colorAsSnake = function(atom) {\n *      return atom.resi % 2 ? 'white': 'green'\n *    };\n *    viewer.setStyle( {chain:'A'}, { cartoon: {colorfunc: colorAsSnake }});\n *    viewer.setStyle( {chain:'B'}, { stick: {colorscheme: 'yellowCarbon'}});\n *    viewer.render();\n *  });\n  */\nconst builtinColorSchemes = {\n    /** secondary structure pymol */\n    ssPyMol: { prop: \"ss\", map: ssColors.pyMol },\n    ssJmol: { prop: \"ss\", map: ssColors.Jmol },\n    Jmol: { prop: \"elem\", map: elementColors.Jmol },\n    amino: { prop: \"resn\", map: residues.amino },\n    shapely: { prop: \"resn\", map: residues.shapely },\n    nucleic: { prop: \"resn\", map: residues.nucleic },\n    chain: { prop: \"chain\", map: chains.atom },\n    rasmol: { prop: \"elem\", map: elementColors.rasmol },\n    default: { prop: \"elem\", map: elementColors.defaultColors },\n    greenCarbon: { prop: \"elem\", map: elementColors.greenCarbon },\n    chainHetatm: { prop: \"chain\", map: chains.hetatm },\n    cyanCarbon: { prop: \"elem\", map: elementColors.cyanCarbon },\n    magentaCarbon: { prop: \"elem\", map: elementColors.magentaCarbon },\n    purpleCarbon: { prop: \"elem\", map: elementColors.purpleCarbon },\n    whiteCarbon: { prop: \"elem\", map: elementColors.whiteCarbon },\n    orangeCarbon: { prop: \"elem\", map: elementColors.orangeCarbon },\n    yellowCarbon: { prop: \"elem\", map: elementColors.yellowCarbon },\n    blueCarbon: { prop: \"elem\", map: elementColors.blueCarbon },\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/colors.ts?");

/***/ }),

/***/ "./src/glcartoon.ts":
/*!**************************!*\
  !*** ./src/glcartoon.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawCartoon: () => (/* binding */ drawCartoon),\n/* harmony export */   subdivide_spline: () => (/* binding */ subdivide_spline)\n/* harmony export */ });\n/* harmony import */ var _WebGL_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGL/math */ \"./src/WebGL/math/index.ts\");\n/* harmony import */ var _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGL/shapes */ \"./src/WebGL/shapes/index.ts\");\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _Gradient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Gradient */ \"./src/Gradient.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n/* harmony import */ var _GLDraw__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GLDraw */ \"./src/GLDraw.ts\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utilities */ \"./src/utilities.ts\");\n//glcartoon.js\n//This contains all the routines for rendering a cartoon given a set\n//of atoms with assigned secondary structure\n\n\n\n\n\n\n\n;\n// helper functions\n// Catmull-Rom subdivision\nfunction subdivide_spline(_points, DIV) {\n    var ret = [];\n    var points = _points;\n    points = []; // Smoothing test\n    points.push(_points[0]);\n    var i, lim, size;\n    var p0, p1, p2, p3, v0, v1;\n    for (i = 1, lim = _points.length - 1; i < lim; i++) {\n        p1 = _points[i];\n        p2 = _points[i + 1];\n        if (p1.smoothen) {\n            var np = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n            np.atom = p1.atom;\n            points.push(np);\n        }\n        else\n            points.push(p1);\n    }\n    points.push(_points[_points.length - 1]);\n    for (i = -1, size = points.length; i <= size - 3; i++) {\n        p0 = points[(i === -1) ? 0 : i];\n        p1 = points[i + 1];\n        p2 = points[i + 2];\n        p3 = points[(i === size - 3) ? size - 1 : i + 3];\n        v0 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(p2, p0).multiplyScalar(0.5);\n        v1 = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(p3, p1).multiplyScalar(0.5);\n        if (p2.skip)\n            continue;\n        for (var j = 0; j < DIV; j++) {\n            var t = 1.0 / DIV * j;\n            var x = p1.x + t * v0.x + t * t *\n                (-3 * p1.x + 3 * p2.x - 2 * v0.x - v1.x) + t * t * t *\n                (2 * p1.x - 2 * p2.x + v0.x + v1.x);\n            var y = p1.y + t * v0.y + t * t *\n                (-3 * p1.y + 3 * p2.y - 2 * v0.y - v1.y) + t * t * t *\n                (2 * p1.y - 2 * p2.y + v0.y + v1.y);\n            var z = p1.z + t * v0.z + t * t *\n                (-3 * p1.z + 3 * p2.z - 2 * v0.z - v1.z) + t * t * t *\n                (2 * p1.z - 2 * p2.z + v0.z + v1.z);\n            var pt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z);\n            if (j < DIV / 2) {\n                pt.atom = p1.atom;\n            }\n            else {\n                pt.atom = p2.atom;\n            }\n            ret.push(pt);\n        }\n    }\n    ret.push(points[points.length - 1]);\n    return ret;\n}\n;\nconst coilWidth = 0.5;\nconst helixSheetWidth = 1.3;\nconst nucleicAcidWidth = 0.8;\nconst defaultThickness = 0.4;\nconst baseThickness = 0.4;\nfunction drawThinStrip(geo, p1, p2, colors) {\n    var offset, vertoffset;\n    var color, colori;\n    for (var i = 0, lim = p1.length; i < lim; i++) {\n        colori = Math.round(i * (colors.length - 1) / lim);\n        color = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(colors[colori]);\n        var geoGroup = geo.updateGeoGroup(2);\n        var vertexArray = geoGroup.vertexArray;\n        var colorArray = geoGroup.colorArray;\n        var faceArray = geoGroup.faceArray;\n        offset = geoGroup.vertices;\n        vertoffset = offset * 3;\n        vertexArray[vertoffset] = p1[i].x;\n        vertexArray[vertoffset + 1] = p1[i].y;\n        vertexArray[vertoffset + 2] = p1[i].z;\n        vertexArray[vertoffset + 3] = p2[i].x;\n        vertexArray[vertoffset + 4] = p2[i].y;\n        vertexArray[vertoffset + 5] = p2[i].z;\n        for (var j = 0; j < 6; ++j) {\n            colorArray[vertoffset + 3 * j] = color.r;\n            colorArray[vertoffset + 1 + 3 * j] = color.g;\n            colorArray[vertoffset + 2 + 3 * j] = color.b;\n        }\n        if (i > 0) {\n            var faces = [offset, offset + 1, offset - 1, offset - 2];\n            var faceoffset = geoGroup.faceidx;\n            faceArray[faceoffset] = faces[0];\n            faceArray[faceoffset + 1] = faces[1];\n            faceArray[faceoffset + 2] = faces[3];\n            faceArray[faceoffset + 3] = faces[1];\n            faceArray[faceoffset + 4] = faces[2];\n            faceArray[faceoffset + 5] = faces[3];\n            geoGroup.faceidx += 6;\n        }\n        geoGroup.vertices += 2;\n    }\n}\n;\nfunction drawShapeStrip(geo, points, colors, div, thickness, opacity, shape) {\n    // points is a 2D array, dimensionality given by [num = cross-sectional\n    // resolution][len = length of strip]\n    var i, j, num, len;\n    num = points.length;\n    if (num < 2 || points[0].length < 2)\n        return;\n    for (i = 0; i < num; i++) { // spline to generate greater length-wise\n        // resolution\n        points[i] = subdivide_spline(points[i], div);\n    }\n    len = points[0].length;\n    if (!thickness) // if thickness is 0, we can use a smaller geometry than\n        // this function generates\n        return drawThinStrip(geo, points[0], points[num - 1], colors);\n    var axis, cs_shape, cs_bottom, cs_top, last_cs_bottom, last_cs_top;\n    // cache the available cross-sectional shapes\n    var cs_ellipse = [], cs_rectangle = [], cs_parabola = [];\n    for (j = 0; j < num; j++) {\n        cs_ellipse.push(0.25 + 1.5 *\n            Math.sqrt((num - 1) * j - Math.pow(j, 2)) / (num - 1));\n        cs_rectangle.push(0.5);\n        cs_parabola.push(2 * (Math.pow(j / num, 2) - j / num) + 0.6);\n    }\n    /*\n     * face_refs array is used to generate faces from vertexArray\n     * iteratively. As we move through each cross-sectional segment of\n     * points, we draw lateral faces backwards to the previous\n     * cross-sectional segment.\n     *\n     * To correctly identify the points needed to make each face we use this\n     * array as a lookup table for the relative indices of each needed point\n     * in the vertices array.\n     *\n     * 4 points are used to create 2 faces.\n     */\n    var face_refs = [];\n    for (j = 0; j < num * 2 - 1; j++) {\n        /*\n         * [curr vertex in curr cross-section, next vertex in curr\n         * cross-section, next vertex in prev cross-section, curr vertex in\n         * prev cross-section]\n         */\n        face_refs[j] = [j, j + 1, j + 1 - 2 * num, j - 2 * num];\n    }\n    // last face is different. easier to conceptualize this by drawing a\n    // diagram\n    face_refs[num * 2 - 1] = [j, j + 1 - 2 * num, j + 1 - 4 * num,\n        j - 2 * num];\n    var v_offset, va_offset, f_offset;\n    var currentAtom;\n    var color, colori;\n    var vertexArray, colorArray, faceArray, face;\n    let geoGroup = geo.updateGeoGroup();\n    for (i = 0; i < len; i++) {\n        let gnum = geo.groups;\n        let replicating = false;\n        geoGroup = geo.updateGeoGroup(2 * num); // ensure vertex capacity\n        if (gnum != geo.groups && i > 0) {\n            //we created a new geo - need to replicate vertices at edge \n            //(but not faces)\n            i = i - 1;\n            replicating = true;\n        }\n        colori = Math.round(i * (colors.length - 1) / len);\n        color = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(colors[colori]);\n        last_cs_bottom = cs_bottom;\n        last_cs_top = cs_top;\n        cs_bottom = [];\n        cs_top = [];\n        axis = [];\n        if (points[0][i].atom !== undefined) // TODO better edge case\n         \n        // handling\n        {\n            currentAtom = points[0][i].atom;\n            if (shape === \"oval\")\n                cs_shape = cs_ellipse;\n            else if (shape === \"rectangle\")\n                cs_shape = cs_rectangle;\n            else if (shape === \"parabola\")\n                cs_shape = cs_parabola;\n        }\n        if (!cs_shape)\n            cs_shape = cs_rectangle;\n        // calculate thickness at each width point, from cross-sectional\n        // shape\n        var toNext, toSide;\n        for (j = 0; j < num; j++) {\n            if (i < len - 1)\n                toNext = points[j][i + 1].clone().sub(points[j][i]);\n            else\n                toNext = points[j][i - 1].clone().sub(points[j][i])\n                    .negate();\n            if (j < num - 1)\n                toSide = points[j + 1][i].clone().sub(points[j][i]);\n            else\n                toSide = points[j - 1][i].clone().sub(points[j][i])\n                    .negate();\n            axis[j] = toSide.cross(toNext).normalize().multiplyScalar(thickness * cs_shape[j]);\n        }\n        // generate vertices by applying cross-sectional shape thickness to\n        // input points\n        for (j = 0; j < num; j++)\n            cs_bottom[j] = points[j][i].clone().add(axis[j].clone().negate());\n        for (j = 0; j < num; j++)\n            cs_top[j] = points[j][i].clone().add(axis[j]);\n        /*\n         * Until this point the vertices have been dealt with as\n         * Vector3() objects, but we need to serialize them into the\n         * geoGroup.vertexArray, where every three indices represents the\n         * next vertex. The colorArray is analogous.\n         *\n         * In the following for-loops, j iterates through VERTICES so we\n         * need to index them in vertexArray by 3*j + either 0, 1, or 2 for\n         * xyz or rgb component.\n         */\n        vertexArray = geoGroup.vertexArray;\n        colorArray = geoGroup.colorArray;\n        faceArray = geoGroup.faceArray;\n        v_offset = geoGroup.vertices;\n        va_offset = v_offset * 3; // in case geoGroup already contains\n        // vertices\n        // bottom edge of cross-section, vertices [0, num)\n        for (j = 0; j < num; j++) {\n            vertexArray[va_offset + 3 * j + 0] = cs_bottom[j].x;\n            vertexArray[va_offset + 3 * j + 1] = cs_bottom[j].y;\n            vertexArray[va_offset + 3 * j + 2] = cs_bottom[j].z;\n        }\n        // top edge of cross-section, vertices [num, 2*num)\n        // add these backwards, so that each cross-section's vertices are\n        // added sequentially to vertexArray\n        for (j = 0; j < num; j++) {\n            vertexArray[va_offset + 3 * j + 0 + 3 * num] = cs_top[num - 1 - j].x;\n            vertexArray[va_offset + 3 * j + 1 + 3 * num] = cs_top[num - 1 - j].y;\n            vertexArray[va_offset + 3 * j + 2 + 3 * num] = cs_top[num - 1 - j].z;\n        }\n        for (j = 0; j < 2 * num; ++j) {\n            colorArray[va_offset + 3 * j + 0] = color.r;\n            colorArray[va_offset + 3 * j + 1] = color.g;\n            colorArray[va_offset + 3 * j + 2] = color.b;\n        }\n        if (i > 0 && !replicating) {\n            for (j = 0; j < num * 2; j++) {\n                // get VERTEX indices of the 4 points of a rectangular face\n                // (as opposed to literal vertexArray indices)\n                face = [v_offset + face_refs[j][0],\n                    v_offset + face_refs[j][1],\n                    v_offset + face_refs[j][2],\n                    v_offset + face_refs[j][3]];\n                f_offset = geoGroup.faceidx;\n                // need 2 triangles to draw a face between 4 points\n                faceArray[f_offset] = face[0];\n                faceArray[f_offset + 1] = face[1];\n                faceArray[f_offset + 2] = face[3];\n                faceArray[f_offset + 3] = face[1];\n                faceArray[f_offset + 4] = face[2];\n                faceArray[f_offset + 5] = face[3];\n                geoGroup.faceidx += 6;\n                // TODO implement clickable the right way. midpoints of\n                // strand between consecutive atoms\n            }\n            if (currentAtom.clickable || currentAtom.hoverable) {\n                var faces = [];\n                faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(last_cs_bottom[0], cs_bottom[0], cs_bottom[num - 1]));\n                faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(last_cs_bottom[0], cs_bottom[num - 1], last_cs_bottom[num - 1]));\n                faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(last_cs_bottom[num - 1], cs_bottom[num - 1], cs_top[num - 1]));\n                faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(last_cs_bottom[num - 1], cs_top[num - 1], last_cs_top[num - 1]));\n                faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(cs_top[0], last_cs_top[0], last_cs_top[num - 1]));\n                faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(cs_top[num - 1], cs_top[0], last_cs_top[num - 1]));\n                faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(cs_bottom[0], last_cs_bottom[0], last_cs_top[0]));\n                faces.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(cs_top[0], cs_bottom[0], last_cs_top[0]));\n                for (j in faces) {\n                    currentAtom.intersectionShape.triangle.push(faces[j]);\n                }\n            }\n        }\n        geoGroup.vertices += 2 * num;\n    }\n    // for terminal faces\n    vertexArray = geoGroup.vertexArray;\n    colorArray = geoGroup.colorArray;\n    faceArray = geoGroup.faceArray;\n    v_offset = geoGroup.vertices;\n    va_offset = v_offset * 3;\n    f_offset = geoGroup.faceidx;\n    for (i = 0; i < num - 1; i++) // \"rear\" face\n     {\n        face = [i, i + 1, 2 * num - 2 - i, 2 * num - 1 - i];\n        f_offset = geoGroup.faceidx;\n        faceArray[f_offset] = face[0];\n        faceArray[f_offset + 1] = face[1];\n        faceArray[f_offset + 2] = face[3];\n        faceArray[f_offset + 3] = face[1];\n        faceArray[f_offset + 4] = face[2];\n        faceArray[f_offset + 5] = face[3];\n        geoGroup.faceidx += 6;\n    }\n    for (i = 0; i < num - 1; i++) // \"front\" face\n     {\n        face = [v_offset - 1 - i, v_offset - 2 - i,\n            v_offset - 2 * num + i + 1, v_offset - 2 * num + i];\n        f_offset = geoGroup.faceidx;\n        faceArray[f_offset] = face[0];\n        faceArray[f_offset + 1] = face[1];\n        faceArray[f_offset + 2] = face[3];\n        faceArray[f_offset + 3] = face[1];\n        faceArray[f_offset + 4] = face[2];\n        faceArray[f_offset + 5] = face[3];\n        geoGroup.faceidx += 6;\n    }\n}\n;\nfunction drawPlainStrip(geo, points, colors, div, thickness, opacity) {\n    if ((points.length) < 2)\n        return;\n    var p1, p2;\n    p1 = points[0];\n    p2 = points[points.length - 1];\n    p1 = subdivide_spline(p1, div);\n    p2 = subdivide_spline(p2, div);\n    if (!thickness)\n        return drawThinStrip(geo, p1, p2, colors);\n    // var vs = geo.vertices, fs = geo.faces;\n    var vs = [];\n    var axis, p1v, p2v, a1v, a2v;\n    var faces = [[0, 2, -6, -8], [-4, -2, 6, 4], [7, -1, -5, 3],\n        [-3, 5, 1, -7]];\n    var offset, vertoffset, faceoffset;\n    var color, colori;\n    var currentAtom, lastAtom;\n    var i, lim, j;\n    var face1, face2, face3;\n    var geoGroup, vertexArray, colorArray, faceArray;\n    for (i = 0, lim = p1.length; i < lim; i++) {\n        colori = Math.round(i * (colors.length - 1) / lim);\n        color = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(colors[colori]);\n        vs.push(p1v = p1[i]); // 0\n        vs.push(p1v); // 1\n        vs.push(p2v = p2[i]); // 2\n        vs.push(p2v); // 3\n        if (i < lim - 1) {\n            var toNext = p1[i + 1].clone().sub(p1[i]);\n            var toSide = p2[i].clone().sub(p1[i]);\n            axis = toSide.cross(toNext).normalize().multiplyScalar(thickness);\n        }\n        vs.push(a1v = p1[i].clone().add(axis)); // 4\n        vs.push(a1v); // 5\n        vs.push(a2v = p2[i].clone().add(axis)); // 6\n        vs.push(a2v); // 7\n        if (p1v.atom !== undefined)\n            currentAtom = p1v.atom;\n        geoGroup = geo.updateGeoGroup(8);\n        vertexArray = geoGroup.vertexArray;\n        colorArray = geoGroup.colorArray;\n        faceArray = geoGroup.faceArray;\n        offset = geoGroup.vertices;\n        vertoffset = offset * 3;\n        vertexArray[vertoffset] = p1v.x;\n        vertexArray[vertoffset + 1] = p1v.y;\n        vertexArray[vertoffset + 2] = p1v.z;\n        vertexArray[vertoffset + 3] = p1v.x;\n        vertexArray[vertoffset + 4] = p1v.y;\n        vertexArray[vertoffset + 5] = p1v.z;\n        vertexArray[vertoffset + 6] = p2v.x;\n        vertexArray[vertoffset + 7] = p2v.y;\n        vertexArray[vertoffset + 8] = p2v.z;\n        vertexArray[vertoffset + 9] = p2v.x;\n        vertexArray[vertoffset + 10] = p2v.y;\n        vertexArray[vertoffset + 11] = p2v.z;\n        vertexArray[vertoffset + 12] = a1v.x;\n        vertexArray[vertoffset + 13] = a1v.y;\n        vertexArray[vertoffset + 14] = a1v.z;\n        vertexArray[vertoffset + 15] = a1v.x;\n        vertexArray[vertoffset + 16] = a1v.y;\n        vertexArray[vertoffset + 17] = a1v.z;\n        vertexArray[vertoffset + 18] = a2v.x;\n        vertexArray[vertoffset + 19] = a2v.y;\n        vertexArray[vertoffset + 20] = a2v.z;\n        vertexArray[vertoffset + 21] = a2v.x;\n        vertexArray[vertoffset + 22] = a2v.y;\n        vertexArray[vertoffset + 23] = a2v.z;\n        for (j = 0; j < 8; ++j) {\n            colorArray[vertoffset + 3 * j] = color.r;\n            colorArray[vertoffset + 1 + 3 * j] = color.g;\n            colorArray[vertoffset + 2 + 3 * j] = color.b;\n        }\n        if (i > 0) {\n            // both points have distinct atoms\n            var diffAtoms = ((lastAtom !== undefined && currentAtom !== undefined) && lastAtom.serial !== currentAtom.serial);\n            for (j = 0; j < 4; j++) {\n                var face = [offset + faces[j][0], offset + faces[j][1],\n                    offset + faces[j][2], offset + faces[j][3]];\n                faceoffset = geoGroup.faceidx;\n                faceArray[faceoffset] = face[0];\n                faceArray[faceoffset + 1] = face[1];\n                faceArray[faceoffset + 2] = face[3];\n                faceArray[faceoffset + 3] = face[1];\n                faceArray[faceoffset + 4] = face[2];\n                faceArray[faceoffset + 5] = face[3];\n                geoGroup.faceidx += 6;\n                if (currentAtom.clickable || lastAtom.clickable || currentAtom.hoverable || lastAtom.hoverable) {\n                    var p1a = vs[face[3]].clone(), p1b = vs[face[0]]\n                        .clone(), p2a = vs[face[2]].clone(), p2b = vs[face[1]]\n                        .clone();\n                    p1a.atom = vs[face[3]].atom || null; // should be\n                    // same\n                    p2a.atom = vs[face[2]].atom || null;\n                    p1b.atom = vs[face[0]].atom || null; // should be\n                    // same\n                    p2b.atom = vs[face[1]].atom || null;\n                    if (diffAtoms) {\n                        var m1 = p1a.clone().add(p1b).multiplyScalar(0.5);\n                        var m2 = p2a.clone().add(p2b).multiplyScalar(0.5);\n                        var m = p1a.clone().add(p2b).multiplyScalar(0.5);\n                        if (j % 2 === 0) {\n                            if (lastAtom.clickable || lastAtom.hoverable) {\n                                face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m1, m, p1a);\n                                face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m2, p2a, m);\n                                face3 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m, p2a, p1a);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face1);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face2);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face3);\n                            }\n                            if (currentAtom.clickable || currentAtom.hoverable) {\n                                face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, p2b, m);\n                                face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p2b, m2, m);\n                                face3 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, m, m1);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face1);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face2);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face3);\n                            }\n                        }\n                        else {\n                            if (currentAtom.clickable || currentAtom.hoverable) {\n                                face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m1, m, p1a);\n                                face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m2, p2a, m);\n                                face3 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(m, p2a, p1a);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face1);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face2);\n                                currentAtom.intersectionShape.triangle\n                                    .push(face3);\n                            }\n                            if (lastAtom.clickable || lastAtom.hoverable) {\n                                face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, p2b, m);\n                                face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p2b, m2, m);\n                                face3 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, m, m1);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face1);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face2);\n                                lastAtom.intersectionShape.triangle\n                                    .push(face3);\n                            }\n                        }\n                    }\n                    // face for single atom\n                    else if (currentAtom.clickable || currentAtom.hoverable) {\n                        face1 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p1b, p2b, p1a);\n                        face2 = new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Triangle(p2b, p2a, p1a);\n                        currentAtom.intersectionShape.triangle.push(face1);\n                        currentAtom.intersectionShape.triangle.push(face2);\n                    }\n                }\n            }\n        }\n        geoGroup.vertices += 8;\n        lastAtom = currentAtom;\n    }\n    var vsize = vs.length - 8; // Cap\n    geoGroup = geo.updateGeoGroup(8);\n    vertexArray = geoGroup.vertexArray;\n    colorArray = geoGroup.colorArray;\n    faceArray = geoGroup.faceArray;\n    offset = geoGroup.vertices;\n    vertoffset = offset * 3;\n    faceoffset = geoGroup.faceidx;\n    for (i = 0; i < 4; i++) {\n        vs.push(vs[i * 2]);\n        vs.push(vs[vsize + i * 2]);\n        var v1 = vs[i * 2], v2 = vs[vsize + i * 2];\n        vertexArray[vertoffset + 6 * i] = v1.x;\n        vertexArray[vertoffset + 1 + 6 * i] = v1.y;\n        vertexArray[vertoffset + 2 + 6 * i] = v1.z;\n        vertexArray[vertoffset + 3 + 6 * i] = v2.x;\n        vertexArray[vertoffset + 4 + 6 * i] = v2.y;\n        vertexArray[vertoffset + 5 + 6 * i] = v2.z;\n        colorArray[vertoffset + 6 * i] = color.r;\n        colorArray[vertoffset + 1 + 6 * i] = color.g;\n        colorArray[vertoffset + 2 + 6 * i] = color.b;\n        colorArray[vertoffset + 3 + 6 * i] = color.r;\n        colorArray[vertoffset + 4 + 6 * i] = color.g;\n        colorArray[vertoffset + 5 + 6 * i] = color.b;\n    }\n    vsize += 8;\n    face1 = [offset, offset + 2, offset + 6, offset + 4];\n    face2 = [offset + 1, offset + 5, offset + 7, offset + 3];\n    faceArray[faceoffset] = face1[0];\n    faceArray[faceoffset + 1] = face1[1];\n    faceArray[faceoffset + 2] = face1[3];\n    faceArray[faceoffset + 3] = face1[1];\n    faceArray[faceoffset + 4] = face1[2];\n    faceArray[faceoffset + 5] = face1[3];\n    faceArray[faceoffset + 6] = face2[0];\n    faceArray[faceoffset + 7] = face2[1];\n    faceArray[faceoffset + 8] = face2[3];\n    faceArray[faceoffset + 9] = face2[1];\n    faceArray[faceoffset + 10] = face2[2];\n    faceArray[faceoffset + 11] = face2[3];\n    geoGroup.faceidx += 12;\n    geoGroup.vertices += 8;\n    // TODO: Add intersection planes for caps\n}\n;\nfunction drawStrip(geo, points, colors, div, thickness, opacity, shape) {\n    if (!shape || shape === \"default\")\n        shape = \"rectangle\";\n    if (shape === 'edged')\n        drawPlainStrip(geo, points, colors, div, thickness, opacity);\n    else if (shape === \"rectangle\" || shape === \"oval\" || shape === \"parabola\")\n        drawShapeStrip(geo, points, colors, div, thickness, opacity, shape);\n}\n;\n// check if given atom is an alpha carbon\nfunction isAlphaCarbon(atom) {\n    return atom && atom.elem === \"C\" && atom.atom === \"CA\"; // note that\n    // calcium is\n    // also CA\n}\n;\n// check whether two atoms are members of the same residue or subsequent,\n// connected residues (a before b)\nfunction inConnectedResidues(a, b) {\n    if (a && b && a.chain === b.chain) {\n        if (!a.hetflag && !b.hetflag && (a.reschain === b.reschain) &&\n            (a.resi === b.resi || a.resi === b.resi - 1))\n            return true;\n        if (a.resi < b.resi) {\n            // some PDBs have gaps in the numbering but the residues are\n            // still connected\n            // assume if within 4A they are connected\n            var dx = a.x - b.x;\n            var dy = a.y - b.y;\n            var dz = a.z - b.z;\n            var dist = dx * dx + dy * dy + dz * dz;\n            if (a.atom == \"CA\" && b.atom == \"CA\" && dist < 16.0) //protein residues not connected\n                return true; // calpha dist\n            else if ((a.atom == \"P\" || b.atom == \"P\") && dist < 64.0) //dna\n                return true;\n        }\n    }\n    return false;\n}\n;\n// add geo to the group\nfunction setGeo(group, geo, opacity, outline, setNormals) {\n    if (geo == null || geo.vertices == 0)\n        return;\n    if (setNormals) {\n        geo.initTypedArrays();\n        geo.setUpNormals();\n    }\n    var cartoonMaterial = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.MeshDoubleLambertMaterial();\n    cartoonMaterial.vertexColors = _WebGL__WEBPACK_IMPORTED_MODULE_2__.Coloring.FaceColors;\n    if (typeof (opacity) === \"number\" && opacity >= 0 && opacity < 1) {\n        cartoonMaterial.transparent = true;\n        cartoonMaterial.opacity = opacity;\n    }\n    cartoonMaterial.outline = outline;\n    var cartoonMesh = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, cartoonMaterial);\n    group.add(cartoonMesh);\n}\n;\nfunction addBackbonePoints(points, num, smoothen, backbonePt, orientPt, prevOrientPt, backboneAtom, atoms, atomi) {\n    var widthScalar, i, delta, v, addArrowPoints, testStyle;\n    if (!backbonePt || !orientPt || !backboneAtom)\n        return;\n    // the side vector points along the axis from backbone atom to\n    // orientation atom (eg. CA to O, in peptides)\n    var sideVec = orientPt.sub(backbonePt);\n    sideVec.normalize();\n    //find next atom like this one\n    var forwardVec = atoms[atomi];\n    for (i = atomi + 1; i < atoms.length; i++) {\n        forwardVec = atoms[i];\n        if (forwardVec.atom == backboneAtom.atom)\n            break;\n    }\n    // the forward vector points along the axis from backbone atom to next\n    // backbone atom\n    forwardVec = forwardVec ? new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(forwardVec.x, forwardVec.y, forwardVec.z) : new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    forwardVec.sub(backbonePt);\n    // adjustments for proper beta arrow appearance\n    if (backboneAtom.ss === \"arrow start\") {\n        var adjustment = forwardVec.clone().multiplyScalar(0.3).cross(orientPt); // adjust perpendicularly to strand face\n        backbonePt.add(adjustment);\n        var upVec = forwardVec.clone().cross(sideVec).normalize();\n        sideVec.rotateAboutVector(upVec, 0.43);\n    }\n    // determine from cartoon style or secondary structure how wide the\n    // strand should be here\n    // ribbon shape should have same width as thickness\n    if (backboneAtom.style.cartoon.ribbon) {\n        widthScalar = backboneAtom.style.cartoon.thickness || defaultThickness;\n    }\n    else // depending on secondary structure, multiply the orientation\n     \n    // vector by some scalar\n    {\n        if (!backboneAtom.style.cartoon.width) {\n            if (backboneAtom.ss === \"c\") {\n                if (backboneAtom.atom === \"P\")\n                    widthScalar = nucleicAcidWidth;\n                else\n                    widthScalar = coilWidth;\n            }\n            else if (backboneAtom.ss === \"arrow start\") {\n                widthScalar = helixSheetWidth;\n                addArrowPoints = true;\n            }\n            else if (backboneAtom.ss === \"arrow end\")\n                widthScalar = coilWidth;\n            else if (backboneAtom.ss === \"h\" &&\n                backboneAtom.style.cartoon.tubes ||\n                backboneAtom.ss === \"tube start\")\n                widthScalar = coilWidth;\n            else\n                widthScalar = helixSheetWidth;\n        }\n        else\n            widthScalar = backboneAtom.style.cartoon.width;\n    }\n    // make sure the strand orientation doesn't twist more than 90 degrees\n    if (prevOrientPt != null && sideVec.dot(prevOrientPt) < 0)\n        sideVec.negate();\n    sideVec.multiplyScalar(widthScalar);\n    for (i = 0; i < num; i++) {\n        // produces NUM incremental points from backbone atom minus\n        // orientation vector\n        // to backbone atom plus orientation vector\n        delta = -1 + i * 2 / (num - 1); // -1 to 1 incrementing by num\n        v = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(backbonePt.x + delta * sideVec.x, backbonePt.y + delta * sideVec.y, backbonePt.z + delta * sideVec.z);\n        v.atom = backboneAtom;\n        if (smoothen && backboneAtom.ss === \"s\")\n            v.smoothen = true;\n        points[i].push(v); // a num-length array of arrays, where each\n        // inner array contains length-wise points\n        // along the backbone offset by some constant pertaining to its cell\n        // in the outer array\n    }\n    if (addArrowPoints) {\n        sideVec.multiplyScalar(2);\n        for (i = 0; i < num; i++) {\n            delta = -1 + i * 2 / (num - 1); // -1 to 1 incrementing by num\n            v = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(backbonePt.x + delta * sideVec.x, backbonePt.y + delta * sideVec.y, backbonePt.z + delta * sideVec.z);\n            v.atom = backboneAtom;\n            v.smoothen = false;\n            v.skip = true;\n            points[i].push(v);\n        }\n    }\n    // make sure the strand is all the same style\n    testStyle = backboneAtom.style.cartoon.style || 'default';\n    if (points.style) {\n        if (points.style != testStyle) {\n            console\n                .log(\"Warning: a cartoon chain's strand-style is ambiguous\");\n            points.style = 'default';\n        }\n    }\n    else\n        points.style = testStyle;\n    // revert ss keywords used for arrow rendering back to original value\n    if (backboneAtom.ss === \"arrow start\" || backboneAtom.ss === \"arrow end\")\n        backboneAtom.ss = \"s\";\n    return addArrowPoints;\n}\n;\n// proteins na backbone na terminus nucleobases\nconst cartoonAtoms = {\n    \"C\": true, \"CA\": true, \"O\": true, \"P\": true, \"OP2\": true,\n    \"O2P\": true, \"O5'\": true, \"O3'\": true, \"C5'\": true,\n    \"C2'\": true, \"O5*\": true, \"O3*\": true, \"C5*\": true,\n    \"C2*\": true, \"N1\": true, \"N3\": true\n};\nconst purResns = { \"DA\": true, \"DG\": true, \"A\": true, \"G\": true };\nconst pyrResns = { \"DT\": true, \"DC\": true, \"U\": true, \"C\": true, \"T\": true };\nconst naResns = { \"DA\": true, \"DG\": true, \"A\": true, \"G\": true, \"DT\": true, \"DC\": true, \"U\": true, \"C\": true, \"T\": true };\nfunction drawCartoon(group, atomList, gradientrange, quality = 10) {\n    let num = quality;\n    let div = quality;\n    var cartoon, prev, curr, next, currColor, nextColor, thickness, i;\n    var backbonePt, orientPt, prevOrientPt, terminalPt, termOrientPt, baseStartPt, baseEndPt;\n    var tubeStart, tubeEnd, drawingTube;\n    var shapeGeo = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Geometry(true); // for shapes that don't need normals computed\n    var geo = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Geometry(true);\n    var colors = [];\n    var points = [];\n    var opacity = 1;\n    var outline = false;\n    var gradients = {};\n    for (var g in _Gradient__WEBPACK_IMPORTED_MODULE_3__.Gradient.builtinGradients) {\n        if (_Gradient__WEBPACK_IMPORTED_MODULE_3__.Gradient.builtinGradients.hasOwnProperty(g)) {\n            //COUNTER INTUITIVE - spectrum reverses direction to gradient to match other tools\n            gradients[g] = new _Gradient__WEBPACK_IMPORTED_MODULE_3__.Gradient.builtinGradients[g](gradientrange[1], gradientrange[0]);\n        }\n    }\n    var cartoonColor = function (next, cartoon) {\n        if (gradientrange && cartoon.color === 'spectrum') {\n            if (cartoon.colorscheme in gradients) {\n                return gradients[cartoon.colorscheme].valueToHex(next.resi);\n            }\n            else {\n                return gradients.sinebow.valueToHex(next.resi);\n            }\n        }\n        else {\n            return (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(next, cartoon).getHex();\n        }\n    };\n    for (i = 0; i < num; i++)\n        points[i] = [];\n    // first determine where beta sheet arrows and alpha helix tubes belong\n    var inSheet = false;\n    var inHelix = false; //only considering tube styled helices\n    var atoms = [];\n    for (i in atomList) {\n        next = atomList[i];\n        if (next.elem === 'C' && next.atom === 'CA') {\n            var connected = inConnectedResidues(curr, next);\n            // last two residues in a beta sheet become arrowhead\n            if (connected && next.ss === \"s\") {\n                inSheet = true;\n            }\n            else if (inSheet) {\n                if (curr && prev && curr.style.cartoon.arrows && prev.style.cartoon.arrows) {\n                    curr.ss = \"arrow end\";\n                    prev.ss = \"arrow start\";\n                }\n                inSheet = false;\n            }\n            // first and last residues in a helix are used to draw tube\n            if (connected && (curr.ss === \"h\" || curr.ss == \"tube start\") && curr.style.cartoon.tubes) {\n                if (!inHelix && curr.ss != \"tube start\" && next.style.cartoon.tubes) {\n                    next.ss = \"tube start\";\n                    inHelix = true;\n                }\n            }\n            else if (inHelix) {\n                if (curr.ss === \"tube start\") {\n                    curr.ss = \"tube end\"; //only one residue\n                }\n                else if (prev && prev.style.cartoon.tubes) {\n                    prev.ss = \"tube end\";\n                }\n                inHelix = false;\n            }\n            prev = curr;\n            curr = next;\n        }\n        if (next && next.atom in cartoonAtoms) {\n            atoms.push(next);\n        }\n    }\n    if (inHelix && curr.style.cartoon.tubes) {\n        curr.ss = \"tube end\";\n        inHelix = false;\n    }\n    var flushGeom = function (connect) {\n        //write out points, update geom,etc\n        if (points[0].length > 0) {\n            drawStrip(geo, points, colors, div, thickness, opacity, points.style);\n        }\n        var saved = [], savedc = null;\n        if (connect) {\n            //recycle last point to first point of next points array\n            for (i = 0; i < num; i++) {\n                saved[i] = points[i][points[i].length - 1];\n            }\n            savedc = colors[colors.length - 1];\n        }\n        points = [];\n        for (i = 0; i < num; i++)\n            points[i] = [];\n        colors = [];\n        if (connect) {\n            for (i = 0; i < num; i++) {\n                points[i].push(saved[i]);\n            }\n            colors.push(savedc);\n        }\n        setGeo(group, geo, opacity, outline, true);\n        setGeo(group, shapeGeo, opacity, outline, false);\n        geo = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Geometry(true);\n        shapeGeo = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Geometry(true);\n    };\n    // then accumulate points\n    curr = undefined;\n    for (var a = 0; a < atoms.length; a++) {\n        next = atoms[a];\n        var nextresn = next.resn.trim();\n        var inNucleicAcid = nextresn in naResns;\n        opacity = 1;\n        // determine cartoon style\n        cartoon = next.style.cartoon;\n        if (curr && curr.style.cartoon)\n            opacity = curr.style.cartoon.opacity;\n        if (curr && curr.style.cartoon && curr.style.cartoon.outline)\n            outline = curr.style.cartoon.outline;\n        // create a new geometry when opacity changes\n        //this should work fine if opacity is set by chain, but will\n        //break if it changes within the chain\n        if (curr && curr.style.cartoon && (!next.style.cartoon ||\n            curr.style.cartoon.opacity != next.style.cartoon.opacity)) {\n            flushGeom(curr.chain == next.chain);\n        }\n        if (cartoon.style === \"trace\") // draw cylinders connecting\n         \n        // consecutive 'backbone' atoms\n        {\n            /*\n             * \"trace\" style just draws cylinders between consecutive\n             * 'backbone' atoms, such as alpha carbon for polypeptides and\n             * phosphorus for DNA.\n             */\n            if (next.hetflag) {\n                ; //ignore non-protein atoms\n            }\n            else if (next.elem === 'C' && next.atom === 'CA' ||\n                inNucleicAcid && next.atom === \"P\" ||\n                next.atom === 'BB') {\n                // determine cylinder color\n                nextColor = cartoonColor(next, cartoon);\n                // determine cylinder thickness\n                if ((0,_utilities__WEBPACK_IMPORTED_MODULE_6__.isNumeric)(cartoon.thickness))\n                    thickness = cartoon.thickness;\n                else\n                    thickness = defaultThickness;\n                if (inConnectedResidues(curr, next)) {\n                    // if both atoms are same color, draw single cylinder\n                    if (nextColor == currColor) {\n                        var color = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(nextColor);\n                        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, curr, next, thickness, color, 2, 2);\n                    }\n                    else // otherwise draw cylinders for each color\n                     \n                    // (split down the middle)\n                    {\n                        var midpoint = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().addVectors(curr, next).multiplyScalar(0.5);\n                        var color1 = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(currColor);\n                        var color2 = _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(nextColor);\n                        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, curr, midpoint, thickness, color1, 2, 0);\n                        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, midpoint, next, thickness, color2, 0, 2);\n                    } // note that an atom object can be duck-typed as a\n                    // Vector3 in this case\n                }\n                if ((next.clickable === true || next.hoverable) && (next.intersectionShape !== undefined)) {\n                    //can click on joints to get alpha carbons\n                    var center = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);\n                    next.intersectionShape.sphere.push(new _WebGL_shapes__WEBPACK_IMPORTED_MODULE_1__.Sphere(center, thickness));\n                }\n                curr = next;\n                currColor = nextColor;\n            }\n        }\n        else // draw default-style cartoons based on secondary structure\n         {\n            // draw backbone through these atoms\n            if (isAlphaCarbon(next) || inNucleicAcid && (next.atom === \"P\" || next.atom.indexOf('O5') == 0)) {\n                if (drawingTube) {\n                    if (next.ss === \"tube end\") {\n                        drawingTube = false;\n                        tubeEnd = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);\n                        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, tubeStart, tubeEnd, 2, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(currColor), 1, 1);\n                        next.ss = \"h\";\n                    }\n                    else if (curr.chain != next.chain || curr.ss === \"tube end\") { //don't span chains no matter what, check for short tubes (less than ideal)\n                        drawingTube = false;\n                        curr.ss = \"h\";\n                        tubeEnd = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);\n                        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, tubeStart, tubeEnd, 2, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(currColor), 1, 1);\n                    }\n                    else\n                        continue; // don't accumulate strand points while\n                    // in the middle of drawing a tube\n                }\n                // end of a chain of connected residues (of same style)\n                if (curr && (!inConnectedResidues(curr, next) || curr.ss === \"tube start\")) {\n                    if (curr.ss === \"tube start\") {\n                        drawingTube = true;\n                        tubeStart = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);\n                        curr.ss = \"h\";\n                    }\n                    if (baseEndPt) // draw the last base if it's a NA chain\n                     {\n                        if (terminalPt)\n                            baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().addVectors(curr, terminalPt).multiplyScalar(0.5);\n                        else\n                            baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);\n                        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, baseStartPt, baseEndPt, baseThickness, _colors__WEBPACK_IMPORTED_MODULE_4__.CC\n                            .color(baseEndPt.color), 0, 2);\n                        addBackbonePoints(points, num, true, terminalPt, termOrientPt, prevOrientPt, curr, atoms, a);\n                        colors.push(nextColor);\n                        baseStartPt = null;\n                        baseEndPt = null;\n                    }\n                    // draw accumulated strand points\n                    if (points[0].length > 0)\n                        drawStrip(geo, points, colors, div, thickness, opacity, points.style);\n                    // clear arrays for points and colors\n                    points = [];\n                    for (i = 0; i < num; i++)\n                        points[i] = [];\n                    colors = [];\n                }\n                // reached next residue (potentially the first residue)\n                if (curr === undefined || curr.rescode != next.rescode || curr.resi != next.resi) {\n                    if (baseEndPt && curr != undefined) // draw last NA residue's base\n                     {\n                        // start the cylinder at the midpoint between\n                        // consecutive backbone atoms\n                        baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().addVectors(curr, next).multiplyScalar(0.5);\n                        var startFix = baseStartPt.clone().sub(baseEndPt)\n                            .multiplyScalar(0.02); // TODO: apply this\n                        // as function of\n                        // thickness\n                        baseStartPt.add(startFix);\n                        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, baseStartPt, baseEndPt, baseThickness, _colors__WEBPACK_IMPORTED_MODULE_4__.CC\n                            .color(baseEndPt.color), 0, 2);\n                        baseStartPt = null;\n                        baseEndPt = null;\n                    }\n                    // determine color and thickness of the next strand\n                    // segment\n                    nextColor = cartoonColor(next, cartoon);\n                    colors.push(nextColor);\n                    if ((0,_utilities__WEBPACK_IMPORTED_MODULE_6__.isNumeric)(cartoon.thickness))\n                        thickness = cartoon.thickness;\n                    else\n                        thickness = defaultThickness;\n                    curr = next; // advance backbone\n                    backbonePt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);\n                    backbonePt.resi = curr.resi;\n                    currColor = nextColor;\n                }\n                // click handling\n                if ((next.clickable === true || next.hoverable === true) &&\n                    (next.intersectionShape === undefined || next.intersectionShape.triangle === undefined))\n                    next.intersectionShape = {\n                        sphere: null,\n                        cylinder: [],\n                        line: [],\n                        triangle: []\n                    };\n            }\n            // atoms used to orient the backbone strand\n            else if (curr != undefined && (isAlphaCarbon(curr) && next.atom === \"O\" ||\n                inNucleicAcid && curr.atom === \"P\" &&\n                    (next.atom === \"OP2\" || next.atom === \"O2P\") ||\n                inNucleicAcid && curr.atom.indexOf(\"O5\") == 0 &&\n                    next.atom.indexOf(\"C5\") == 0)) {\n                orientPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);\n                orientPt.resi = next.resi;\n                if (next.atom === \"OP2\" || next.atom === \"O2P\") // for NA 3'\n                    // terminus\n                    termOrientPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);\n            }\n            // NA 3' terminus is an edge case, need a vector for most recent\n            // O3'\n            else if (inNucleicAcid && next.atom.indexOf(\"O3\") == 0) {\n                terminalPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);\n            }\n            // atoms used for drawing the NA base cylinders (diff for\n            // purines and pyramidines)\n            else if ((next.atom === \"N1\" && (nextresn in purResns)) ||\n                (next.atom === \"N3\" && (nextresn in pyrResns))) {\n                baseEndPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(next.x, next.y, next.z);\n                baseEndPt.color = (0,_utilities__WEBPACK_IMPORTED_MODULE_6__.getColorFromStyle)(next, cartoon)\n                    .getHex();\n            }\n            // when we have a backbone point and orientation point in the\n            // same residue, accumulate strand points\n            if (orientPt && backbonePt && orientPt.resi === backbonePt.resi) {\n                addBackbonePoints(points, num, true, backbonePt, orientPt, prevOrientPt, curr, atoms, a);\n                prevOrientPt = orientPt;\n                backbonePt = null;\n                orientPt = null;\n                colors.push(nextColor);\n            }\n        }\n    }\n    if (baseEndPt) // draw last NA base if needed\n     {\n        if (terminalPt)\n            baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3().addVectors(curr, terminalPt)\n                .multiplyScalar(0.5);\n        else\n            baseStartPt = new _WebGL_math__WEBPACK_IMPORTED_MODULE_0__.Vector3(curr.x, curr.y, curr.z);\n        _GLDraw__WEBPACK_IMPORTED_MODULE_5__.GLDraw.drawCylinder(shapeGeo, baseStartPt, baseEndPt, baseThickness, _colors__WEBPACK_IMPORTED_MODULE_4__.CC.color(baseEndPt.color), 0, 2);\n        addBackbonePoints(points, num, true, terminalPt, termOrientPt, prevOrientPt, curr, atoms, a);\n        colors.push(nextColor);\n    }\n    // for default style, draw the last strand\n    flushGeom(false);\n}\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/glcartoon.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ThreeDmol: () => (/* binding */ ThreeDmol)\n/* harmony export */ });\n/* harmony import */ var _GLViewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GLViewer */ \"./src/GLViewer.ts\");\n/* harmony import */ var _GLModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLModel */ \"./src/GLModel.ts\");\n\n\n\n// Bundle them into a single object\nconst ThreeDmol = {\n    GLViewer: _GLViewer__WEBPACK_IMPORTED_MODULE_0__.GLViewer,\n    GLModel: _GLModel__WEBPACK_IMPORTED_MODULE_1__.GLModel,\n    createViewer: _GLViewer__WEBPACK_IMPORTED_MODULE_0__.createViewer\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/index.ts?");

/***/ }),

/***/ "./src/parsers/CDJSON.ts":
/*!*******************************!*\
  !*** ./src/parsers/CDJSON.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CDJSON: () => (/* binding */ CDJSON)\n/* harmony export */ });\n/**\n * This parses the ChemDoodle json file format. Although this is registered\n * for the json file extension, other chemical json file formats exist that\n * this can not parse. Check which one you have and do not assume that\n * .json can be parsed\n *\n * @param {string} str\n * @param {ParserOptionsSpec} options\n * @category Parsers\n*/\nfunction CDJSON(str, options) {\n    var atoms = [[]];\n    if (typeof str === \"string\") {\n        // Str is usually automatically parsed by JQuery\n        str = JSON.parse(str);\n    }\n    var molecules = str.m;\n    var atomsInFile = molecules[0].a; // Assumes there is at least one\n    var bondsInFile = molecules[0].b; // molecule and ignores any more\n    // Ignores any shapes\n    var styles = molecules[0].s;\n    var parseStyle = options !== undefined && options.parseStyle !== undefined\n        ? options.parseStyle\n        : styles !== undefined;\n    var offset = atoms[atoms.length - 1].length; // When adding atoms their index will be\n    // Offset by the number of existing atoms\n    for (var i = 0; i < atomsInFile.length; i++) {\n        var currentAtom = atomsInFile[i];\n        var atom = {};\n        atom.id = currentAtom.i; // Probably won't exist. Doesn't seem to\n        // break anything.\n        atom.x = currentAtom.x;\n        atom.y = currentAtom.y;\n        atom.z = currentAtom.z || 0; // Default value if file is 2D\n        atom.bonds = [];\n        atom.bondOrder = [];\n        var elem = currentAtom.l || \"C\";\n        atom.elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n        atom.serial = atoms[atoms.length - 1].length;\n        if (parseStyle) {\n            atom.style = styles[currentAtom.s || 0];\n        }\n        atoms[atoms.length - 1].push(atom);\n    }\n    for (let i = 0; i < bondsInFile.length; i++) {\n        let currentBond = bondsInFile[i];\n        let beginIndex = currentBond.b + offset;\n        let endIndex = currentBond.e + offset;\n        let bondOrder = currentBond.o || 1;\n        let firstAtom = atoms[atoms.length - 1][beginIndex];\n        let secondAtom = atoms[atoms.length - 1][endIndex];\n        firstAtom.bonds.push(endIndex);\n        firstAtom.bondOrder.push(bondOrder);\n        secondAtom.bonds.push(beginIndex);\n        secondAtom.bondOrder.push(bondOrder);\n    }\n    return atoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/CDJSON.ts?");

/***/ }),

/***/ "./src/parsers/CIF.ts":
/*!****************************!*\
  !*** ./src/parsers/CIF.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CIF: () => (/* binding */ CIF)\n/* harmony export */ });\n/* harmony import */ var _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/computeSecondaryStructure */ \"./src/parsers/utils/computeSecondaryStructure.ts\");\n/* harmony import */ var _utils_processSymmetries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/processSymmetries */ \"./src/parsers/utils/processSymmetries.ts\");\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/assignPDBBonds */ \"./src/parsers/utils/assignPDBBonds.ts\");\n\n\n\n\n/**\n * Puts atoms specified in mmCIF fromat in str into atoms\n *\n * @param {string} str\n * @param {ParserOptionsSpec} options\n * @category Parsers\n */\n//coordinate conversion\nconst fractionalToCartesian = function (cmat, x, y, z) {\n    return new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z).applyMatrix3(cmat);\n};\nfunction CIF(str, options = {}) {\n    const atoms = [];\n    const noAssembly = !options.doAssembly; // don't assemble by default\n    const modelData = (atoms.modelData = []);\n    const assignbonds = options.assignBonds === undefined ? true : options.assignBonds;\n    // Used to handle quotes correctly\n    function splitRespectingQuotes(string, separator) {\n        const sections = [];\n        let sectionStart = 0;\n        let sectionEnd = 0;\n        while (sectionEnd < string.length) {\n            while (string.substring(sectionEnd, sectionEnd + separator.length) !==\n                separator &&\n                sectionEnd < string.length) {\n                // currently does not support escaping quotes\n                if (string[sectionEnd] === \"'\") {\n                    sectionEnd++;\n                    while (sectionEnd < string.length && string[sectionEnd] !== \"'\") {\n                        sectionEnd++;\n                    }\n                    //biopython apparently generates invalid string literals so if we think we are done but aren't at a separator keep going\n                    while (string.substring(sectionEnd, sectionEnd + separator.length) !==\n                        separator &&\n                        sectionEnd < string.length) {\n                        sectionEnd++;\n                    }\n                }\n                else if (string[sectionEnd] === '\"') {\n                    sectionEnd++;\n                    while (sectionEnd < string.length && string[sectionEnd] !== '\"') {\n                        sectionEnd++;\n                    }\n                    sectionEnd++;\n                }\n                else {\n                    sectionEnd++;\n                }\n            }\n            sections.push(string.substring(sectionStart, sectionEnd));\n            sectionStart = sectionEnd = sectionEnd + separator.length;\n        }\n        return sections;\n    }\n    const lines = str.split(/\\r?\\n|\\r/);\n    // Filter text to remove comments, trailing spaces, and empty lines\n    const linesFiltered = [];\n    let trimDisabled = false;\n    for (let lineNum = 0; lineNum < lines.length; lineNum++) {\n        // first remove comments\n        // incorrect if #'s are allowed in strings\n        // comments might only be allowed at beginning of line, not sure\n        var line = lines[lineNum].split(\"#\")[0];\n        // inside data blocks, the string must be left verbatim\n        // datablocks are started with a ';' at the beginning of a line\n        // and ended with a ';' on its own line.\n        if (trimDisabled) {\n            if (line[0] === \";\") {\n                trimDisabled = false;\n            }\n        }\n        else {\n            if (line[0] === \";\") {\n                trimDisabled = true;\n            }\n        }\n        if (trimDisabled || line !== \"\") {\n            if (!trimDisabled) {\n                line = line.trim();\n                if (line[0] === \"_\") {\n                    // Replace dot separating category from data item with underscore. Dots aren't guarenteed, to makes\n                    // files consistent.\n                    const dot = line.split(/\\s/)[0].indexOf(\".\");\n                    if (dot > -1) {\n                        let lineArr = line.split(\"\");\n                        lineArr[dot] = \"_\";\n                        line = lineArr.join(\"\");\n                        line = line.substring(0, dot) + \"_\" + line.substring(dot + 1);\n                    }\n                }\n            }\n            linesFiltered.push(line);\n        }\n    }\n    let lineNum = 0;\n    while (lineNum < linesFiltered.length) {\n        while (!linesFiltered[lineNum].startsWith(\"data_\") ||\n            linesFiltered[lineNum] === \"data_global\") {\n            lineNum++;\n        }\n        lineNum++;\n        // Process the lines and puts all of the data into an object.\n        const mmCIF = {};\n        while (lineNum < linesFiltered.length &&\n            !linesFiltered[lineNum].startsWith(\"data_\")) {\n            if (linesFiltered[lineNum][0] === undefined) {\n                lineNum++;\n            }\n            else if (linesFiltered[lineNum][0] === \"_\") {\n                const dataItemName = linesFiltered[lineNum]\n                    .split(/\\s/)[0]\n                    .toLowerCase();\n                const dataItem = (mmCIF[dataItemName] = mmCIF[dataItemName] || []);\n                // if nothing left on the line go to the next one\n                const restOfLine = linesFiltered[lineNum].substring(linesFiltered[lineNum].indexOf(dataItemName) + dataItemName.length);\n                if (restOfLine === \"\") {\n                    lineNum++;\n                    if (linesFiltered[lineNum][0] === \";\") {\n                        let dataBlock = linesFiltered[lineNum].substring(1);\n                        lineNum++;\n                        while (linesFiltered[lineNum] !== \";\") {\n                            dataBlock = dataBlock + \"\\n\" + linesFiltered[lineNum];\n                            lineNum++;\n                        }\n                        dataItem.push(dataBlock);\n                    }\n                    else {\n                        dataItem.push(linesFiltered[lineNum]);\n                    }\n                }\n                else {\n                    dataItem.push(restOfLine.trim());\n                }\n                lineNum++;\n            }\n            else if (linesFiltered[lineNum].substring(0, 5) === \"loop_\") {\n                lineNum++;\n                const dataItems = [];\n                while (linesFiltered[lineNum] === \"\" ||\n                    linesFiltered[lineNum][0] === \"_\") {\n                    if (linesFiltered[lineNum] !== \"\") {\n                        let dataItemName = linesFiltered[lineNum]\n                            .split(/\\s/)[0]\n                            .toLowerCase();\n                        let dataItem = (mmCIF[dataItemName] = mmCIF[dataItemName] || []);\n                        dataItems.push(dataItem);\n                    }\n                    lineNum++;\n                }\n                let currentDataItem = 0;\n                while (lineNum < linesFiltered.length &&\n                    linesFiltered[lineNum][0] !== \"_\" &&\n                    !linesFiltered[lineNum].startsWith(\"loop_\") &&\n                    !linesFiltered[lineNum].startsWith(\"data_\")) {\n                    let line = splitRespectingQuotes(linesFiltered[lineNum], \" \");\n                    for (let field = 0; field < line.length; field++) {\n                        if (line[field] !== \"\") {\n                            dataItems[currentDataItem].push(line[field]);\n                            currentDataItem = (currentDataItem + 1) % dataItems.length;\n                        }\n                    }\n                    lineNum++;\n                }\n            }\n            else {\n                lineNum++;\n            }\n        }\n        modelData.push({ symmetries: [] });\n        // Pulls atom information out of the data\n        atoms.push([]);\n        const atomCount = mmCIF._atom_site_id !== undefined\n            ? mmCIF._atom_site_id.length\n            : mmCIF._atom_site_label.length;\n        let conversionMatrix;\n        if (mmCIF._cell_length_a !== undefined) {\n            const a = parseFloat(mmCIF._cell_length_a);\n            const b = parseFloat(mmCIF._cell_length_b);\n            const c = parseFloat(mmCIF._cell_length_c);\n            const alpha_deg = parseFloat(mmCIF._cell_angle_alpha) || 90;\n            const beta_deg = parseFloat(mmCIF._cell_angle_beta) || 90;\n            const gamma_deg = parseFloat(mmCIF._cell_angle_gamma) || 90;\n            conversionMatrix = (0,_WebGL__WEBPACK_IMPORTED_MODULE_2__.conversionMatrix3)(a, b, c, alpha_deg, beta_deg, gamma_deg);\n            modelData[modelData.length - 1].cryst = {\n                a: a,\n                b: b,\n                c: c,\n                alpha: alpha_deg,\n                beta: beta_deg,\n                gamma: gamma_deg,\n            };\n        }\n        for (let i = 0; i < atomCount; i++) {\n            if (mmCIF._atom_site_group_pdb !== undefined &&\n                mmCIF._atom_site_group_pdb[i] === \"TER\")\n                continue;\n            const atom = {};\n            if (mmCIF._atom_site_cartn_x !== undefined) {\n                atom.x = parseFloat(mmCIF._atom_site_cartn_x[i]);\n                atom.y = parseFloat(mmCIF._atom_site_cartn_y[i]);\n                atom.z = parseFloat(mmCIF._atom_site_cartn_z[i]);\n            }\n            else {\n                const coords = fractionalToCartesian(conversionMatrix, parseFloat(mmCIF._atom_site_fract_x[i]), parseFloat(mmCIF._atom_site_fract_y[i]), parseFloat(mmCIF._atom_site_fract_z[i]));\n                atom.x = coords.x;\n                atom.y = coords.y;\n                atom.z = coords.z;\n            }\n            atom.chain = mmCIF._atom_site_auth_asym_id\n                ? mmCIF._atom_site_auth_asym_id[i]\n                : mmCIF._atom_site_label_asym_id\n                    ? mmCIF._atom_site_label_asym_id[i]\n                    : undefined;\n            atom.resi = mmCIF._atom_site_auth_seq_id\n                ? parseInt(mmCIF._atom_site_auth_seq_id[i])\n                : mmCIF._atom_site_label_seq_id\n                    ? mmCIF._atom_site_label_seq_id[i]\n                    : undefined;\n            atom.resn = mmCIF._atom_site_auth_comp_id\n                ? mmCIF._atom_site_auth_comp_id[i].trim()\n                : mmCIF._atom_site_label_comp_id\n                    ? mmCIF._atom_site_label_comp_id[i].trim()\n                    : undefined;\n            atom.atom = mmCIF._atom_site_auth_atom_id\n                ? mmCIF._atom_site_auth_atom_id[i].replace(/\"/gm, \"\")\n                : mmCIF._atom_site_label_atom_id\n                    ? mmCIF._atom_site_label_atom_id[i].replace(/\"/gm, \"\")\n                    : undefined; //\"primed\" names are in quotes\n            atom.hetflag =\n                !mmCIF._atom_site_group_pdb ||\n                    mmCIF._atom_site_group_pdb[i] === \"HETA\" ||\n                    mmCIF._atom_site_group_pdb[i] === \"HETATM\";\n            let elem = \"X\";\n            if (mmCIF._atom_site_type_symbol) {\n                elem = mmCIF._atom_site_type_symbol[i].replace(/\\(?\\+?\\d+.*/, \"\");\n            }\n            else if (mmCIF._atom_site_label) {\n                //first two components are concatenated, then separated by underscore\n                //best I can do is assume second component, if present, starts with a number\n                elem = mmCIF._atom_site_label[i].split(\"_\")[0].replace(/\\(?\\d+.*/, \"\");\n            }\n            atom.elem = elem[0].toUpperCase() + elem.substring(1, 2).toLowerCase();\n            atom.bonds = [];\n            atom.ss = \"c\";\n            atom.serial = i;\n            atom.bondOrder = [];\n            atom.properties = {};\n            atoms[atoms.length - 1].push(atom);\n        }\n        if (mmCIF._pdbx_struct_oper_list_id !== undefined && !noAssembly) {\n            for (let i = 0; i < mmCIF._pdbx_struct_oper_list_id.length; i++) {\n                const matrix11 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[1][1]\"][i]);\n                const matrix12 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[1][2]\"][i]);\n                const matrix13 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[1][3]\"][i]);\n                const vector1 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_vector[1]\"][i]);\n                const matrix21 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[2][1]\"][i]);\n                const matrix22 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[2][2]\"][i]);\n                const matrix23 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[2][3]\"][i]);\n                const vector2 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_vector[2]\"][i]);\n                const matrix31 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[3][1]\"][i]);\n                const matrix32 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[3][2]\"][i]);\n                const matrix33 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_matrix[3][3]\"][i]);\n                const vector3 = parseFloat(mmCIF[\"_pdbx_struct_oper_list_vector[3]\"][i]);\n                const matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4(matrix11, matrix12, matrix13, vector1, matrix21, matrix22, matrix23, vector2, matrix31, matrix32, matrix33, vector3);\n                modelData[modelData.length - 1].symmetries.push(matrix);\n            }\n        }\n        const parseTerm = function (term) {\n            const negative = term.match(\"-\");\n            term = term.replace(/[-xyz]/g, \"\");\n            const fractionParts = term.split(\"/\");\n            let numerator, denominator;\n            if (fractionParts[1] === undefined) {\n                denominator = 1;\n            }\n            else {\n                denominator = parseInt(fractionParts[1]);\n            }\n            if (fractionParts[0] === \"\") {\n                numerator = 1;\n            }\n            else {\n                numerator = parseInt(fractionParts[0]);\n            }\n            return (numerator / denominator) * (negative ? -1 : 1);\n        };\n        if (mmCIF._symmetry_equiv_pos_as_xyz !== undefined && !noAssembly) {\n            for (let sym = 0; sym < mmCIF._symmetry_equiv_pos_as_xyz.length; sym++) {\n                const transform = mmCIF._symmetry_equiv_pos_as_xyz[sym].replace(/[\"' ]/g, \"\");\n                const componentStrings = transform\n                    .split(\",\")\n                    .map(function (val) {\n                    return val.replace(/-/g, \"+-\");\n                });\n                let matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n                for (let coord = 0; coord < 3; coord++) {\n                    const terms = componentStrings[coord].split(\"+\");\n                    for (let t = 0; t < terms.length; t++) {\n                        const term = terms[t];\n                        if (term === \"\")\n                            continue;\n                        const coefficient = parseTerm(term);\n                        if (term.match(\"x\")) {\n                            matrix.elements[coord + 0] = coefficient;\n                        }\n                        else if (term.match(\"y\")) {\n                            matrix.elements[coord + 4] = coefficient;\n                        }\n                        else if (term.match(\"z\")) {\n                            matrix.elements[coord + 8] = coefficient;\n                        }\n                        else {\n                            matrix.elements[coord + 12] = coefficient;\n                        }\n                    }\n                }\n                const conversionMatrix4 = conversionMatrix.getMatrix4();\n                const conversionInverse = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4().getInverse(conversionMatrix4, true);\n                matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4().multiplyMatrices(matrix, conversionInverse);\n                matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_2__.Matrix4().multiplyMatrices(conversionMatrix4, matrix);\n                modelData[modelData.length - 1].symmetries.push(matrix);\n            }\n        }\n    }\n    for (let i = 0; i < atoms.length; i++) {\n        if (assignbonds &&\n            !(options.duplicateAssemblyAtoms && !options.dontConnectDuplicatedAtoms)) {\n            (0,_utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_3__.assignPDBBonds)(atoms[i], options);\n        }\n        (0,_utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_0__.computeSecondaryStructure)(atoms[i], options.hbondCutoff);\n        (0,_utils_processSymmetries__WEBPACK_IMPORTED_MODULE_1__.processSymmetries)(modelData[i].symmetries, atoms[i], options, modelData[i].cryst);\n        if (options.duplicateAssemblyAtoms &&\n            !options.dontConnectDuplicatedAtoms &&\n            assignbonds)\n            (0,_utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_3__.assignPDBBonds)(atoms[i], options);\n    }\n    return atoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/CIF.ts?");

/***/ }),

/***/ "./src/parsers/CUBE.ts":
/*!*****************************!*\
  !*** ./src/parsers/CUBE.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CUBE: () => (/* binding */ CUBE)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/assignBonds */ \"./src/parsers/utils/assignBonds.ts\");\n/* harmony import */ var _utils_anumToSymbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/anumToSymbol */ \"./src/parsers/utils/anumToSymbol.ts\");\n\n\n\n/**\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options\n * @category Parsers\n */\nfunction CUBE(str, options) {\n    options = options || {};\n    const atoms = [[]];\n    let lines = str.split(/\\r?\\n/);\n    const assignbonds = options.assignBonds === undefined ? true : options.assignBonds;\n    if (lines.length < 6)\n        return atoms;\n    let lineArr = lines[2].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n    const natoms = Math.abs(parseFloat(lineArr[0]));\n    let cryst = {\n        origin: undefined,\n        size: undefined,\n        unit: undefined,\n        matrix4: undefined,\n        matrix: undefined,\n    };\n    const origin = (cryst.origin = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(lineArr[1]), parseFloat(lineArr[2]), parseFloat(lineArr[3])));\n    lineArr = lines[3].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n    lineArr = lines[3].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n    // might have to convert from bohr units to angstroms\n    // there is a great deal of confusion here:\n    // n>0 means angstroms: http://www.gaussian.com/g_tech/g_ur/u_cubegen.htm\n    // n<0 means angstroms: http://paulbourke.net/dataformats/cube/\n    // always assume bohr: openbabel source code\n    // always assume angstrom: http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/cubeplugin.html\n    // we are going to go with n<0 means angstrom - note this is just the first n\n    const convFactor = lineArr[0] > 0 ? 0.529177 : 1;\n    origin.multiplyScalar(convFactor);\n    const nX = Math.abs(lineArr[0]);\n    const xVec = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(lineArr[1]), parseFloat(lineArr[2]), parseFloat(lineArr[3])).multiplyScalar(convFactor);\n    lineArr = lines[4].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n    const nY = Math.abs(lineArr[0]);\n    const yVec = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(lineArr[1]), parseFloat(lineArr[2]), parseFloat(lineArr[3])).multiplyScalar(convFactor);\n    lineArr = lines[5].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n    const nZ = Math.abs(lineArr[0]);\n    const zVec = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(lineArr[1]), parseFloat(lineArr[2]), parseFloat(lineArr[3])).multiplyScalar(convFactor);\n    cryst.size = { x: nX, y: nY, z: nZ };\n    cryst.unit = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(xVec.x, yVec.y, zVec.z);\n    if (xVec.y != 0 ||\n        xVec.z != 0 ||\n        yVec.x != 0 ||\n        yVec.z != 0 ||\n        zVec.x != 0 ||\n        zVec.y != 0) {\n        //need a transformation matrix\n        cryst.matrix4 = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix4(xVec.x, yVec.x, zVec.x, 0, xVec.y, yVec.y, zVec.y, 0, xVec.z, yVec.z, zVec.z, 0, 0, 0, 0, 1);\n        // include translation in matrix\n        let t = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(origin.x, origin.y, origin.z);\n        cryst.matrix4 = cryst.matrix4.multiplyMatrices(t, cryst.matrix4);\n        cryst.matrix = cryst.matrix4.matrix3FromTopLeft();\n        // all translation and scaling done by matrix, so reset origin and unit\n        cryst.origin = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        cryst.unit = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n    }\n    atoms.modelData = [{ cryst: cryst }];\n    // Extract atom portion; send to new GLModel...\n    lines = lines.splice(6, natoms);\n    var start = atoms[atoms.length - 1].length;\n    var end = start + lines.length;\n    for (var i = start; i < end; ++i) {\n        var atom = {};\n        atom.serial = i;\n        var line = lines[i - start];\n        var tokens = line.replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n        atom.elem = _utils_anumToSymbol__WEBPACK_IMPORTED_MODULE_2__.anumToSymbol[tokens[0]];\n        atom.x = parseFloat(tokens[2]) * convFactor;\n        atom.y = parseFloat(tokens[3]) * convFactor;\n        atom.z = parseFloat(tokens[4]) * convFactor;\n        atom.hetflag = true;\n        atom.bonds = [];\n        atom.bondOrder = [];\n        atom.properties = {};\n        atoms[atoms.length - 1].push(atom);\n    }\n    if (assignbonds) {\n        for (let i = 0; i < atoms.length; i++)\n            (0,_utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__.assignBonds)(atoms[i], options);\n    }\n    return atoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/CUBE.ts?");

/***/ }),

/***/ "./src/parsers/GRO.ts":
/*!****************************!*\
  !*** ./src/parsers/GRO.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GRO: () => (/* binding */ GRO)\n/* harmony export */ });\n/* harmony import */ var _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/assignPDBBonds */ \"./src/parsers/utils/assignPDBBonds.ts\");\n/* harmony import */ var _utils_atomNameToElem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/atomNameToElem */ \"./src/parsers/utils/atomNameToElem.ts\");\n\n\n/**\n * Parse a gro file from str and create atoms\n *\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options*\n * @category Parsers\n*/\nfunction GRO(str, options) {\n    var allatoms = [];\n    var lines = str.split(/\\r?\\n|\\r/);\n    while (lines.length > 0) {\n        if (lines.length < 3)\n            break;\n        var atomCount = parseInt(lines[1]);\n        if (isNaN(atomCount) || atomCount <= 0)\n            break;\n        if (lines.length < atomCount + 3)\n            break;\n        var atoms = [];\n        allatoms.push(atoms);\n        var offset = 2;\n        var start = atoms.length;\n        var end = start + atomCount;\n        for (var i = start; i < end; i++) {\n            var line = lines[offset++];\n            var atom = {};\n            atom.serial = i;\n            atom.atom = line.slice(10, 15).trim();\n            atom.elem = (0,_utils_atomNameToElem__WEBPACK_IMPORTED_MODULE_1__.atomNameToElem)(atom.atom, true);\n            //coordinates are in nM, convert to A\n            atom.x = 10.0 * parseFloat(line.slice(20, 28));\n            atom.y = 10.0 * parseFloat(line.slice(28, 36));\n            atom.z = 10.0 * parseFloat(line.slice(36, 44));\n            atom.resi = parseInt(line.slice(0, 5));\n            atom.resn = line.slice(5, 10).trim();\n            atom.bonds = [];\n            atom.bondOrder = [];\n            atom.properties = {};\n            if (line.length > 44) {\n                atom.dx = 10.0 * parseFloat(line.slice(44, 52));\n                atom.dy = 10.0 * parseFloat(line.slice(52, 60));\n                atom.dz = 10.0 * parseFloat(line.slice(60, 68));\n            }\n            atoms[i] = atom;\n        } //for all atoms\n        if (lines.length <= offset + 3) {\n            //single line left, assume it is the box\n            var last = lines[offset++];\n            var box = last.trim().split(/\\s+/);\n            if (box.length == 3) {\n                for (var b = 0; b < 3; b++) {\n                    box[b] = parseFloat(box[b]) * 10.0;\n                }\n                allatoms.box = box;\n            }\n        }\n        lines.splice(0, ++offset);\n    }\n    for (let i = 0; i < allatoms.length; i++) {\n        (0,_utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_0__.assignPDBBonds)(allatoms[i], options);\n    }\n    return allatoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/GRO.ts?");

/***/ }),

/***/ "./src/parsers/LAMMPSTRJ.ts":
/*!**********************************!*\
  !*** ./src/parsers/LAMMPSTRJ.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LAMMPSTRJ: () => (/* binding */ LAMMPSTRJ)\n/* harmony export */ });\n/* harmony import */ var _utils_assignBonds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/assignBonds */ \"./src/parsers/utils/assignBonds.ts\");\n\n/**\n * Parse a lammps trajectory file from str and create atoms\n *\n * @category Parsers\n*/\nfunction LAMMPSTRJ(str, options) {\n    var atoms = [];\n    var dic = {\n        id: \"serial\",\n        type: \"atom\",\n        element: \"elem\",\n        q: \"charge\",\n        radius: \"radius\",\n        x: \"x\",\n        xu: \"x\",\n        xs: \"x\",\n        xsu: \"x\",\n        y: \"y\",\n        yu: \"y\",\n        ys: \"y\",\n        ysu: \"y\",\n        z: \"z\",\n        zu: \"z\",\n        zs: \"z\",\n        zsu: \"z\",\n    };\n    var lines = str.split(/\\r?\\n|\\r/);\n    var offset = 0;\n    var atomCount = 0;\n    var start = 0;\n    while (start < lines.length - 9) {\n        for (var j = start; j < lines.length; j++) {\n            if (lines[j].match(/ITEM: NUMBER OF ATOMS/))\n                atomCount = parseInt(lines[j + 1]);\n            if (lines[j].match(/ITEM: ATOMS/)) {\n                offset = j + 1;\n                break;\n            }\n        }\n        var types = lines[offset - 1].replace(\"ITEM: ATOMS \", \"\").split(\" \");\n        atoms.push([]);\n        for (let j = offset; j < offset + atomCount; j++) {\n            var atom = {};\n            var properties = {};\n            var tokens = lines[j].split(\" \");\n            for (var k = 0; k < tokens.length; k++) {\n                var prop = dic[types[k]];\n                if (prop != undefined) {\n                    if (prop == \"serial\")\n                        atom[prop] = parseInt(tokens[k]);\n                    else if (prop == \"x\" || prop == \"y\" || prop === \"z\")\n                        atom[prop] = parseFloat(tokens[k]);\n                    else if (prop == \"charge\" || prop == \"radius\")\n                        properties[prop] = parseFloat(tokens[k]);\n                    else\n                        atom[prop] = tokens[k];\n                }\n                atom.properties = properties;\n                atom.bonds = [];\n                atom.bondOrder = [];\n            }\n            atoms[atoms.length - 1][j - offset] = atom;\n        }\n        start = offset + atomCount - 1;\n    }\n    if (options.assignBonds) {\n        for (var i = 0; i < atoms.length; i++)\n            (0,_utils_assignBonds__WEBPACK_IMPORTED_MODULE_0__.assignBonds)(atoms[i], options);\n    }\n    return atoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/LAMMPSTRJ.ts?");

/***/ }),

/***/ "./src/parsers/MMTF.ts":
/*!*****************************!*\
  !*** ./src/parsers/MMTF.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MMTFparser: () => (/* binding */ MMTFparser)\n/* harmony export */ });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ \"./src/utilities.ts\");\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/computeSecondaryStructure */ \"./src/parsers/utils/computeSecondaryStructure.ts\");\n/* harmony import */ var _utils_processSymmetries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/processSymmetries */ \"./src/parsers/utils/processSymmetries.ts\");\n\n\n\n\nvar fromCharCode = function (charCodeArray) {\n    return String.fromCharCode.apply(null, charCodeArray).replace(/\\0/g, '');\n};\nvar convertSS = function (val) {\n    // Convert mmtf code to 3dmol code\n    /*\n      0:  pi helix\n      1:  bend\n      2:  alpha helix\n      3:  sheet extended\n      4:  3-10 helix\n      5:  bridge\n      6:  turn\n      7:  coil\n     */\n    if (val == 0 || val == 2 || val == 4)\n        return 'h';\n    if (val == 3)\n        return 's';\n    return 'c';\n};\nlet mmtfHETATMtypes = new Set([\n    \"D-SACCHARIDE\",\n    \"D-SACCHARIDE 1,4 AND 1,4 LINKING\",\n    \"D-SACCHARIDE 1,4 AND 1,6 LINKING\",\n    \"L-SACCHARIDE\",\n    \"L-SACCHARIDE 1,4 AND 1,4 LINKING\",\n    \"L-SACCHARIDE 1,4 AND 1,6 LINKING\",\n    \"NON-POLYMER\",\n    \"OTHER\",\n    \"PEPTIDE-LIKE\",\n    \"SACCHARIDE\"\n]);\n/**\n * @param bindata - binary UInt8Array buffer or a base64 encoded string\n * @param ParserOptionsSpec\n * @category Parsers\n*/\nfunction MMTFparser(bindata, options) {\n    var noH = !options.keepH; // suppress hydrogens by default\n    var selAltLoc = options.altLoc ? options.altLoc : 'A'; //default alternate location to select if present\n    var ignoreStruct = !!options.noSecondaryStructure;\n    var computeStruct = !options.noComputeSecondaryStructure;\n    //extract symmetries - only take first assembly, apply to all models (ignoring changes for now)\n    var noAssembly = !options.doAssembly; // don't assemble by default\n    var assemblyIndex = options.assemblyIndex ? options.assemblyIndex : 0;\n    if (typeof (bindata) == \"string\") {\n        //assume base64 encoded\n        bindata = (0,_utilities__WEBPACK_IMPORTED_MODULE_0__.base64ToArray)(bindata);\n    }\n    else {\n        bindata = new Uint8Array(bindata);\n    }\n    var mmtfData = MMTF.decode(bindata);\n    var atoms = [[]];\n    var modelData = atoms.modelData = [];\n    // setup index counters\n    var chainIndex = 0;\n    var groupIndex = 0;\n    var atomIndex = 0;\n    // setup optional fields\n    var secStructList = mmtfData.secStructList;\n    var bFactorList = mmtfData.bFactorList;\n    var altLocList = mmtfData.altLocList;\n    var occupancyList = mmtfData.occupancyList;\n    var bondAtomList = mmtfData.bondAtomList;\n    var bondOrderList = mmtfData.bondOrderList;\n    var numModels = mmtfData.numModels;\n    if (numModels == 0)\n        return atoms;\n    if (!options.multimodel)\n        numModels = 1; //first only\n    // hoisted loop variables\n    var i, j, k, kl, m, n;\n    var symmetries = [];\n    if (!noAssembly && mmtfData.bioAssemblyList && mmtfData.bioAssemblyList.length > 0) {\n        var transforms = mmtfData.bioAssemblyList[assemblyIndex].transformList;\n        for (i = 0, n = transforms.length; i < n; i++) {\n            var matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_1__.Matrix4(transforms[i].matrix);\n            matrix.transpose();\n            symmetries.push(matrix);\n        }\n    }\n    var unitCell = null;\n    //unit cell info\n    if (mmtfData.unitCell) {\n        var u = mmtfData.unitCell;\n        unitCell = { 'a': u[0], 'b': u[1], 'c': u[2], 'alpha': u[3], 'beta': u[4], 'gamma': u[5] };\n    }\n    let chainIsPolymer = [];\n    mmtfData.entityList.forEach((entity) => {\n        entity.chainIndexList.forEach(ch => {\n            chainIsPolymer[ch] = entity.type == \"polymer\";\n        });\n    });\n    var bondAtomListStart = 0; //for current model\n    //loop over models, \n    for (m = 0; m < numModels; m++) {\n        var modelChainCount = mmtfData.chainsPerModel[m];\n        var matoms = atoms[atoms.length - 1];\n        var serialToIndex = []; // map to matoms index, needed for noh\n        modelData.push({ symmetries: symmetries, cryst: unitCell });\n        for (i = 0; i < modelChainCount; ++i) {\n            var chainGroupCount = mmtfData.groupsPerChain[chainIndex];\n            var chainId = fromCharCode(mmtfData.chainIdList.subarray(chainIndex * 4, chainIndex * 4 + 4));\n            if (mmtfData.chainNameList) {\n                chainId = fromCharCode(mmtfData.chainNameList.subarray(chainIndex * 4, chainIndex * 4 + 4));\n            }\n            var startGroup = groupIndex;\n            var prevSS = '';\n            for (j = 0; j < chainGroupCount; ++j) { //over residues (groups)\n                var groupData = mmtfData.groupList[mmtfData.groupTypeList[groupIndex]];\n                var groupAtomCount = groupData.atomNameList.length;\n                var secStruct = 0;\n                var secStructBegin = false;\n                var secStructEnd = false;\n                if (secStructList) {\n                    secStruct = secStructList[groupIndex];\n                    var sscode = convertSS(secStruct);\n                    if (groupIndex == 0 || sscode != prevSS) {\n                        secStructBegin = true;\n                    }\n                    prevSS = sscode;\n                    var nextgroup = groupIndex + 1;\n                    if (nextgroup >= secStructList.length || convertSS(secStructList[nextgroup] != sscode)) {\n                        secStructEnd = true;\n                    }\n                }\n                var groupId = mmtfData.groupIdList[groupIndex];\n                var groupName = groupData.groupName;\n                let groupType = groupData.chemCompType;\n                var startAtom = atomIndex;\n                // Note the following is not identical to respecting HETATM records\n                // this information isn't available in MMTF.  \n                let isHETATM = mmtfHETATMtypes.has(groupType) || !chainIsPolymer[chainIndex];\n                for (k = 0; k < groupAtomCount; ++k) {\n                    var element = groupData.elementList[k];\n                    if (noH && element == 'H') {\n                        atomIndex += 1;\n                        continue;\n                    }\n                    var bFactor = '';\n                    if (bFactorList) {\n                        bFactor = bFactorList[atomIndex];\n                    }\n                    var altLoc = '';\n                    if (altLocList && altLocList[atomIndex]) { //not zero\n                        altLoc = String.fromCharCode(altLocList[atomIndex]);\n                    }\n                    var occupancy = '';\n                    if (occupancyList) {\n                        occupancy = occupancyList[atomIndex];\n                    }\n                    if (altLoc != '' && altLoc != selAltLoc && selAltLoc != '*') {\n                        atomIndex += 1;\n                        continue;\n                    }\n                    var atomId = mmtfData.atomIdList[atomIndex];\n                    var atomName = groupData.atomNameList[k];\n                    var atomCharge = 0;\n                    if (groupData.atomChargeList)\n                        atomCharge = groupData.atomChargeList[k];\n                    var xCoord = mmtfData.xCoordList[atomIndex];\n                    var yCoord = mmtfData.yCoordList[atomIndex];\n                    var zCoord = mmtfData.zCoordList[atomIndex];\n                    serialToIndex[atomIndex] = matoms.length;\n                    matoms.push({\n                        'resn': groupName,\n                        'x': xCoord,\n                        'y': yCoord,\n                        'z': zCoord,\n                        'elem': element,\n                        'hetflag': isHETATM,\n                        'chain': chainId,\n                        'resi': groupId,\n                        'icode': altLoc,\n                        'rescode': groupId + (altLoc != ' ' ? \"^\" + altLoc : \"\"),\n                        // resi\n                        // and\n                        // icode\n                        'serial': atomId,\n                        'altLoc': altLoc,\n                        'index': atomIndex,\n                        'atom': atomName,\n                        'bonds': [],\n                        'ss': convertSS(secStruct),\n                        'ssbegin': secStructBegin,\n                        'ssend': secStructEnd,\n                        'bondOrder': [],\n                        'properties': { charge: atomCharge, occupancy: occupancy },\n                        'b': bFactor,\n                    });\n                    atomIndex += 1;\n                }\n                // intra group bonds\n                var groupBondAtomList = groupData.bondAtomList;\n                for (k = 0, kl = groupData.bondOrderList.length; k < kl; ++k) {\n                    var atomIndex1 = startAtom + groupBondAtomList[k * 2];\n                    var atomIndex2 = startAtom + groupBondAtomList[k * 2 + 1];\n                    var bondOrder = groupData.bondOrderList[k];\n                    //I assume bonds are only recorded once\n                    var i1 = serialToIndex[atomIndex1];\n                    var i2 = serialToIndex[atomIndex2];\n                    var a1 = matoms[i1];\n                    var a2 = matoms[i2];\n                    if (a1 && a2) {\n                        a1.bonds.push(i2);\n                        a1.bondOrder.push(bondOrder);\n                        a2.bonds.push(i1);\n                        a2.bondOrder.push(bondOrder);\n                    }\n                }\n                groupIndex += 1;\n            }\n            //reset for bonds\n            groupIndex = startGroup;\n            for (j = 0; j < chainGroupCount; ++j) { //over residues (groups)\n                groupIndex += 1;\n            }\n            chainIndex += 1;\n        }\n        // inter group bonds\n        if (bondAtomList) {\n            for (let k = bondAtomListStart, kl = bondAtomList.length; k < kl; k += 2) {\n                let atomIndex1 = bondAtomList[k];\n                let atomIndex2 = bondAtomList[k + 1];\n                let bondOrder = bondOrderList ? bondOrderList[k / 2] : 1;\n                if (atomIndex1 >= atomIndex) {\n                    bondAtomListStart = k;\n                    break; //on next model\n                }\n                //I assume bonds are only recorded once\n                let i1 = serialToIndex[atomIndex1];\n                let i2 = serialToIndex[atomIndex2];\n                let a1 = matoms[i1];\n                let a2 = matoms[i2];\n                if (a1 && a2) {\n                    a1.bonds.push(i2);\n                    a1.bondOrder.push(bondOrder);\n                    a2.bonds.push(i1);\n                    a2.bondOrder.push(bondOrder);\n                }\n            }\n        }\n        if (options.multimodel) {\n            if (!options.onemol)\n                atoms.push([]);\n        }\n    }\n    if (!noAssembly) {\n        for (let n = 0; n < atoms.length; n++) {\n            (0,_utils_processSymmetries__WEBPACK_IMPORTED_MODULE_3__.processSymmetries)(modelData[n].symmetries, atoms[n], options, modelData[n].cryst);\n        }\n    }\n    if (computeStruct && !ignoreStruct) {\n        (0,_utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_2__.computeSecondaryStructure)(atoms, options.hbondCutoff);\n    }\n    return atoms;\n}\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/MMTF.ts?");

/***/ }),

/***/ "./src/parsers/MOL2.ts":
/*!*****************************!*\
  !*** ./src/parsers/MOL2.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MOL2: () => (/* binding */ MOL2)\n/* harmony export */ });\nlet SYBYLtoElem = {\n    'C.1': 'C',\n    'C1': 'C',\n    'C.2': 'C',\n    'C2': 'C',\n    'C.3': 'C',\n    'C3': 'C',\n    'C.ar': 'C',\n    'Car': 'C',\n    'C.cat': 'C',\n    'Ccat': 'C',\n    'H.spc': 'H',\n    'Hspc': 'H',\n    'H.t3p': 'H',\n    'Ht3p': 'H',\n    'N.1': 'N',\n    'N1': 'N',\n    'N.2': 'N',\n    'N2': 'N',\n    'N.3': 'N',\n    'N3': 'N',\n    'N.4': 'N',\n    'N4': 'N',\n    'N.am': 'N',\n    'Nam': 'N',\n    'N.ar': 'N',\n    'Nar': 'N',\n    'N.p13': 'N',\n    'Np13': 'N',\n    'O.2': 'O',\n    'O2': 'O',\n    'O.3': 'O',\n    'O3': 'O',\n    'O.co2': 'O',\n    'Oco2': 'O',\n    'O.spc': 'O',\n    'Ospc': 'O',\n    'O.t3p': 'O',\n    'Ot3p': 'O',\n    'P.3': 'P',\n    'P3': 'P',\n    'S.2': 'S',\n    'S2': 'S',\n    'S.3': 'S',\n    'S3': 'S',\n    'S.o': 'S',\n    'So': 'S',\n    'S.o2': 'S',\n    'So2': 'S'\n};\n// Parse SYBYL mol2 file from string - assumed to only contain one molecule tag\n/**\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options\n * @category Parsers\n*/\nfunction MOL2(str, options) {\n    var atoms = [[]];\n    var noH = false;\n    if (typeof options.keepH !== \"undefined\")\n        noH = !options.keepH;\n    // Note: these regex's work, though they don't match '<TRIPOS>'\n    // correctly - something to do with angle brackets\n    var mol_pos = str.search(/@<TRIPOS>MOLECULE/);\n    var atom_pos = str.search(/@<TRIPOS>ATOM/);\n    // Assuming both Molecule and Atom sections exist\n    if (mol_pos == -1 || atom_pos == -1)\n        return atoms;\n    var lines = str.substring(mol_pos).split(/\\r?\\n|\\r/);\n    while (lines.length > 0) {\n        // serial is atom's index in file; index is atoms index in 'atoms'\n        var serialToIndex = [];\n        var tokens = lines[2].replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n        var natoms = parseInt(tokens[0]);\n        var nbonds = 0;\n        if (tokens.length > 1)\n            nbonds = parseInt(tokens[1]);\n        var offset = 4;\n        var i;\n        // Continue until 'Atom' section\n        for (i = 3; i < lines.length; i++) {\n            if (lines[i] == \"@<TRIPOS>ATOM\") {\n                offset = i + 1;\n                break;\n            }\n        }\n        var start = atoms[atoms.length - 1].length;\n        var end = start + natoms;\n        var line;\n        // Process ATOMS\n        for (i = start; i < end; i++) {\n            line = lines[offset++];\n            tokens = line.replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n            var atom = {};\n            // get element\n            var elem = tokens[5];\n            if (SYBYLtoElem[elem] !== undefined) {\n                elem = SYBYLtoElem[elem];\n            }\n            else {\n                elem = elem.split(\".\")[0];\n                elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n            }\n            atom.atom = tokens[1];\n            atom.elem = elem;\n            if (atom.elem == \"H\" && noH) {\n                // ignore\n            }\n            else {\n                // 'index' is this atom's index in 'atoms'; 'serial' is this\n                // atom's\n                // serial id in mol2 file\n                var index = atoms[atoms.length - 1].length;\n                var serial = parseInt(tokens[0]);\n                atom.serial = serial;\n                // atom.serial = i;\n                atom.x = parseFloat(tokens[2]);\n                atom.y = parseFloat(tokens[3]);\n                atom.z = parseFloat(tokens[4]);\n                atom.atom = tokens[5];\n                var charge = parseFloat(tokens[8]);\n                atom.index = index;\n                atom.bonds = [];\n                atom.bondOrder = [];\n                atom.properties = {\n                    charge: charge,\n                    partialCharge: charge,\n                };\n                serialToIndex[serial] = index;\n                atoms[atoms.length - 1].push(atom);\n            }\n        }\n        // Process BONDS\n        var bonds_found = false;\n        while (offset < lines.length) {\n            if (lines[offset++] == \"@<TRIPOS>BOND\") {\n                bonds_found = true;\n                break;\n            }\n        }\n        if (bonds_found && nbonds) {\n            for (i = 0; i < nbonds; i++) {\n                line = lines[offset++];\n                tokens = line.replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n                var from = parseInt(tokens[1]);\n                var fromAtom = atoms[atoms.length - 1][serialToIndex[from]];\n                var to = parseInt(tokens[2]);\n                var toAtom = atoms[atoms.length - 1][serialToIndex[to]];\n                // Won't be able to read aromatic bonds correctly...\n                var order = parseInt(tokens[3]);\n                if (isNaN(order))\n                    order = 1;\n                if (fromAtom !== undefined && toAtom !== undefined) {\n                    fromAtom.bonds.push(serialToIndex[to]);\n                    fromAtom.bondOrder.push(order);\n                    toAtom.bonds.push(serialToIndex[from]);\n                    toAtom.bondOrder.push(order);\n                }\n            }\n        }\n        if (options.multimodel) {\n            if (!options.onemol)\n                atoms.push([]);\n            lines.splice(0, offset);\n            str = lines.join(\"\\n\"); //update for str.search\n            continue;\n        }\n        else {\n            break;\n        }\n    }\n    return atoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/MOL2.ts?");

/***/ }),

/***/ "./src/parsers/PDB.ts":
/*!****************************!*\
  !*** ./src/parsers/PDB.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PDB: () => (/* binding */ PDB)\n/* harmony export */ });\n/* harmony import */ var _utils_getSinglePDB__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getSinglePDB */ \"./src/parsers/utils/getSinglePDB.ts\");\n\n/**\n * Parse pdb file from str and create atoms if computeStruct is true will always perform secondary structure analysis,\n * otherwise only do analysis of SHEET/HELIX comments are missing\n *\n * @param {string} str\n * @param {ParserOptionsSpec} options - keepH (do not strip hydrogens), noSecondaryStructure,\n *            assignbonds (default true, calculate implicit bonds)\n *            (do not compute ss), altLoc (which alternate location to select, if present; '*' to load all)\n * @category Parsers\n *\n*/\nfunction PDB(str, options) {\n    options = options || {};\n    var atoms = []; //a separate list for each model\n    var sslookup = {}; //stores SHEET and HELIX info, which is shared across models\n    atoms.modelData = [];\n    var lines = str.split(/\\r?\\n|\\r/);\n    while (lines.length > 0) {\n        var pdbinfo = (0,_utils_getSinglePDB__WEBPACK_IMPORTED_MODULE_0__.getSinglePDB)(lines, options, sslookup);\n        var modelatoms = pdbinfo[0];\n        var modelData = pdbinfo[1];\n        lines = pdbinfo[2];\n        if (modelatoms.length == 0) {\n            continue; //happens when there are blank lines\n        }\n        if (options.multimodel && options.onemol && atoms.length > 0) {\n            //merge into existing atoms\n            var inc = atoms[0].length;\n            for (var i = 0; i < modelatoms.length; i++) {\n                //renumber\n                var atom = modelatoms[i];\n                atom.index = i;\n                for (var b = 0; b < atom.bonds.length; b++) {\n                    atom.bonds[b] += inc;\n                }\n                atoms[0].push(atom);\n            }\n        }\n        else {\n            atoms.modelData.push(modelData);\n            atoms.push(modelatoms);\n        }\n        if (!options.multimodel) {\n            break;\n        }\n    }\n    return atoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/PDB.ts?");

/***/ }),

/***/ "./src/parsers/PQR.ts":
/*!****************************!*\
  !*** ./src/parsers/PQR.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PQR: () => (/* binding */ PQR)\n/* harmony export */ });\n/* harmony import */ var _utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/assignPDBBonds */ \"./src/parsers/utils/assignPDBBonds.ts\");\n/* harmony import */ var _utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/computeSecondaryStructure */ \"./src/parsers/utils/computeSecondaryStructure.ts\");\n\n\n/**\n * Parse a pqr file from str and create atoms. A pqr file is assumed to be a whitespace delimited PDB with charge and radius fields.\n *\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options - noSecondaryStructure (do not compute ss)\n * @category Parsers\n*/\nfunction PQR(str, options) {\n    var atoms = [[]];\n    var computeStruct = !options.noSecondaryStructure;\n    atoms.modelData = [{ symmetries: [] }];\n    var serialToIndex = []; // map from pdb serial to index in atoms\n    var lines = str.split(/\\r?\\n|\\r/);\n    var line;\n    for (let i = 0; i < lines.length; i++) {\n        line = lines[i].replace(/^\\s*/, ''); // remove indent\n        var recordName = line.substring(0, 6);\n        if (recordName.indexOf(\"END\") == 0) {\n            if (options.multimodel) {\n                if (!options.onemol)\n                    atoms.push([]);\n                continue;\n            }\n            else {\n                break;\n            }\n        }\n        else if (recordName == 'ATOM  ' || recordName == 'HETATM') {\n            // I would have liked to split based solely on whitespace, but\n            // it seems that there is no guarantee that all the fields will\n            // be filled out (e.g. the chain) so this doesn't work\n            var hetflag;\n            let serial = parseInt(line.substring(6, 11));\n            let atom = line.substring(12, 16).replace(/ /g, \"\");\n            let resn = line.substring(17, 20).trim();\n            let chain = line.substring(21, 22);\n            let resi = parseInt(line.substring(22, 26));\n            // however let's split the coordinates, charge and radius by\n            // whitespace\n            // to support extra precision\n            var vals = line.substring(30).trim().split(/\\s+/);\n            var x = parseFloat(vals[0]);\n            var y = parseFloat(vals[1]);\n            var z = parseFloat(vals[2]);\n            var charge = parseFloat(vals[3]);\n            var radius = parseFloat(vals[4]);\n            var elem = atom[0];\n            if (atom.length > 1 && atom[1].toUpperCase() != atom[1]) {\n                // slight hack - identify two character elements by the\n                // second character in the atom name being lowercase\n                elem = atom.substring(0, 2);\n            }\n            if (line[0] == 'H')\n                hetflag = true;\n            else\n                hetflag = false;\n            serialToIndex[serial] = atoms[atoms.length - 1].length;\n            atoms[atoms.length - 1].push({\n                'resn': resn,\n                'x': x,\n                'y': y,\n                'z': z,\n                'elem': elem,\n                'hetflag': hetflag,\n                'chain': chain,\n                'resi': resi,\n                'serial': serial,\n                'atom': atom,\n                'bonds': [],\n                'ss': 'c',\n                'bondOrder': [],\n                'properties': {\n                    'charge': charge,\n                    'partialCharge': charge,\n                    'radius': radius\n                },\n                'pdbline': line\n            });\n        }\n        else if (recordName == 'CONECT') {\n            // MEMO: We don't have to parse SSBOND, LINK because both are\n            // also\n            // described in CONECT. But what about 2JYT???\n            var from = parseInt(line.substring(6, 11));\n            var fromAtom = atoms[atoms.length - 1][serialToIndex[from]];\n            for (let j = 0; j < 4; j++) {\n                var to = parseInt(line.substring([11, 16, 21, 26][j], [11, 16, 21, 26][j] + 5));\n                var toAtom = atoms[atoms.length - 1][serialToIndex[to]];\n                if (fromAtom !== undefined && toAtom !== undefined) {\n                    fromAtom.bonds.push(serialToIndex[to]);\n                    fromAtom.bondOrder.push(1);\n                }\n            }\n        }\n    }\n    // assign bonds - yuck, can't count on connect records\n    for (let i = 0; i < atoms.length; i++) {\n        (0,_utils_assignPDBBonds__WEBPACK_IMPORTED_MODULE_0__.assignPDBBonds)(atoms[i], options);\n        if (computeStruct)\n            (0,_utils_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_1__.computeSecondaryStructure)(atoms[i], options.hbondCutoff);\n    }\n    return atoms;\n}\n;\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/PQR.ts?");

/***/ }),

/***/ "./src/parsers/PRMTOP.ts":
/*!*******************************!*\
  !*** ./src/parsers/PRMTOP.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PRMTOP: () => (/* binding */ PRMTOP)\n/* harmony export */ });\n// @ts-nocheck\n/**\n * Parse a prmtop file from str and create atoms\n *\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options - noSecondaryStructure (do not compute ss)\n * @category Parsers\n*/\nfunction PRMTOP(str /*, options*/) {\n    var atoms = [];\n    var atomIndex;\n    var count = 0;\n    var lines = str.split(/\\r?\\n|\\r/);\n    if (lines.length > 0 && lines[0].includes(\"VERSION\")) {\n        var sectionList = lines.filter(function (line) {\n            //store the relevant section lists\n            return (line.includes(\"POINTERS\") ||\n                line.includes(\"ATOM_NAME\") ||\n                line.includes(\"CHARGE\") ||\n                line.includes(\"RADII\") ||\n                line.includes(\"BONDS_INC_HYDROGEN\") ||\n                line.includes(\"BONDS_WITHOUT_HYDROGEN\"));\n        });\n        var index = getIndex(\"POINTERS\");\n        if (index == -1)\n            return [];\n        var col = getColEleSize(index);\n        var atomCount = parseInt(lines[index + 1].slice(0, col[1]));\n        if (isNaN(atomCount) || atomCount <= 0)\n            return [];\n        index = getIndex(\"ATOM_NAME\");\n        if (index == -1)\n            return [];\n        col = getColEleSize(index);\n        var noOfCol = col[0];\n        for (let i = 0; i < atomCount / col[0]; i++) {\n            if (i == parseInt(atomCount / col[0]))\n                noOfCol = atomCount % col[0];\n            for (let j = 0; j < noOfCol; j++) {\n                let atom = {};\n                let properties = { charge: \"\", radii: \"\" };\n                atom.serial = count;\n                atom.x = 0;\n                atom.y = 0;\n                atom.z = 0;\n                atom.atom = lines[index + 1].slice(col[1] * j, col[1] * (j + 1)).trim();\n                atom.elem = lines[index + 1].slice(col[1] * j, col[1] * j + 1).trim();\n                atom.properties = properties;\n                atom.bonds = [];\n                atom.bondOrder = [];\n                atoms.push(atom);\n                count++;\n            }\n            index++;\n        }\n        index = getIndex(\"CHARGE\");\n        if (index != -1) {\n            col = getColEleSize(index);\n            count = 0;\n            noOfCol = col[0];\n            for (let i = 0; i < atomCount / col[0]; i++) {\n                if (i == parseInt(atomCount / col[0]))\n                    noOfCol = atomCount % col[0];\n                for (let j = 0; j < noOfCol; j++) {\n                    atoms[count].properties.charge = parseFloat(lines[index + 1].slice(col[1] * j, col[1] * (j + 1)));\n                    count++;\n                }\n                index++;\n            }\n        }\n        index = getIndex(\"RADII\");\n        if (index != -1) {\n            col = getColEleSize(index);\n            count = 0;\n            noOfCol = col[0];\n            for (let i = 0; i < atomCount / col[0]; i++) {\n                if (i == parseInt(atomCount / col[0]))\n                    noOfCol = atomCount % col[0];\n                for (let j = 0; j < noOfCol; j++) {\n                    atoms[count].properties.radii = parseFloat(lines[index + 1].slice(col[1] * j, col[1] * (j + 1)));\n                    count++;\n                }\n                index++;\n            }\n        }\n        index = getIndex(\"BONDS_WITHOUT_HYDROGEN\");\n        if (index != -1) {\n            col = getColEleSize(index);\n            count = 0;\n            noOfCol = col[0];\n            index = index + 1;\n            while (!lines[index].match(/^%FLAG/)) {\n                if (lines[index + 1].match(/^%FLAG/))\n                    //its the last line\n                    noOfCol = atomCount % col[0];\n                for (let j = 0; j < noOfCol; j++) {\n                    if (count % 3 == 0) {\n                        atomIndex = parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3);\n                    }\n                    else if (count % 3 == 1) {\n                        atoms[atomIndex].bonds.push(parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3));\n                    }\n                    count++;\n                }\n                index++;\n            }\n        }\n        index = getIndex(\"BONDS_INC_HYDROGEN\");\n        if (index != -1) {\n            col = getColEleSize(index);\n            count = 0;\n            noOfCol = col[0];\n            index = index + 1;\n            while (!lines[index].match(/^%FLAG/)) {\n                if (lines[index + 1].match(/^%FLAG/))\n                    //its the last line\n                    noOfCol = atomCount % col[0];\n                for (let j = 0; j < noOfCol; j++) {\n                    if (count % 3 == 0) {\n                        atomIndex = parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3);\n                    }\n                    else if (count % 3 == 1) {\n                        atoms[atomIndex].bonds.push(parseInt(lines[index].slice(col[1] * j, col[1] * (j + 1)) / 3));\n                    }\n                    count++;\n                }\n                index++;\n            }\n        }\n    }\n    else {\n        return [];\n    }\n    function getIndex(section) {\n        var index = lines.indexOf(sectionList.filter(function (line) {\n            return line.includes(section);\n        })[0]); //returns the index of the line containing FLAG POINTERS\n        if (Number.isInteger(index) && index > 0) {\n            while (!lines[index].includes(\"FORMAT\"))\n                //doing this so as to take comments into consideration\n                index++;\n            return index;\n        }\n        else {\n            return -1;\n        }\n    }\n    function getColEleSize(i) {\n        var numberOfCol = lines[i].match(/\\((\\d*)\\S*/); // stores the number of columns\n        var elementSize = lines[i].match(/[a-zA-Z](\\d*)\\)\\s*/);\n        if (elementSize == null) {\n            elementSize = lines[i].match(/[a-zA-Z](\\d*)\\.\\d*\\)\\s*/); //stores the element size\n        }\n        return [numberOfCol[1], elementSize[1]];\n    }\n    return [atoms];\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/PRMTOP.ts?");

/***/ }),

/***/ "./src/parsers/SDF.ts":
/*!****************************!*\
  !*** ./src/parsers/SDF.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SDF: () => (/* binding */ SDF)\n/* harmony export */ });\nvar parseV2000 = function (lines, options) {\n    var atoms = [[]];\n    var noH = false;\n    if (typeof options.keepH !== \"undefined\")\n        noH = !options.keepH;\n    while (lines.length > 0) {\n        if (lines.length < 4)\n            break;\n        var atomCount = parseInt(lines[3].substring(0, 3));\n        if (isNaN(atomCount) || atomCount <= 0)\n            break;\n        var bondCount = parseInt(lines[3].substring(3, 6));\n        var offset = 4;\n        if (lines.length < 4 + atomCount + bondCount)\n            break;\n        // Serial is atom's index in file; index is atoms index in 'atoms'\n        var serialToIndex = [];\n        var start = atoms[atoms.length - 1].length;\n        var end = start + atomCount;\n        var i, line;\n        for (i = start; i < end; i++, offset++) {\n            line = lines[offset];\n            var atom = {};\n            var elem = line.substring(31, 34).replace(/ /g, \"\");\n            atom.atom = atom.elem =\n                elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n            if (atom.elem !== \"H\" || !noH) {\n                atom.serial = i;\n                serialToIndex[i] = atoms[atoms.length - 1].length;\n                atom.x = parseFloat(line.substring(0, 10));\n                atom.y = parseFloat(line.substring(10, 20));\n                atom.z = parseFloat(line.substring(20, 30));\n                atom.hetflag = true;\n                atom.bonds = [];\n                atom.bondOrder = [];\n                atom.properties = {};\n                atom.index = atoms[atoms.length - 1].length;\n                atoms[atoms.length - 1].push(atom);\n            }\n        }\n        for (i = 0; i < bondCount; i++, offset++) {\n            line = lines[offset];\n            var from = serialToIndex[parseInt(line.substring(0, 3)) - 1 + start];\n            var to = serialToIndex[parseInt(line.substring(3, 6)) - 1 + start];\n            var order = parseFloat(line.substring(6));\n            if (typeof from != \"undefined\" && typeof to != \"undefined\") {\n                atoms[atoms.length - 1][from].bonds.push(to);\n                atoms[atoms.length - 1][from].bondOrder.push(order);\n                atoms[atoms.length - 1][to].bonds.push(from);\n                atoms[atoms.length - 1][to].bondOrder.push(order);\n            }\n        }\n        if (options.multimodel) {\n            if (!options.onemol)\n                atoms.push([]);\n            while (lines[offset] !== \"$$$$\" && offset < lines.length)\n                offset++;\n            lines.splice(0, ++offset);\n        }\n        else {\n            break;\n        }\n    }\n    return atoms;\n};\n/**\n * @param {!Array.<string>} lines\n * @param {ParserOptionsSpec} options\n * @returns {!Array.<!Array<!Object>>}\n*/\nvar parseV3000 = function (lines, options) {\n    var atoms = [[]];\n    var noH = false;\n    if (typeof options.keepH !== \"undefined\")\n        noH = !options.keepH;\n    while (lines.length > 0) {\n        if (lines.length < 8)\n            break;\n        if (!lines[4].startsWith(\"M  V30 BEGIN CTAB\"))\n            break;\n        if (!lines[5].startsWith(\"M  V30 COUNTS\") || lines[5].length < 14)\n            break;\n        var counts = lines[5].substring(13).match(/\\S+/g);\n        if (counts.length < 2)\n            break;\n        var atomCount = parseInt(counts[0]);\n        if (isNaN(atomCount) || atomCount <= 0)\n            break;\n        var bondCount = parseInt(counts[1]);\n        var offset = 7;\n        if (lines.length < 8 + atomCount + bondCount)\n            //header, bgn+end CTAB, counts, END\n            break;\n        // serial is atom's index in file; index is atoms index in 'atoms'\n        var serialToIndex = [];\n        var start = atoms[atoms.length - 1].length;\n        var end = start + atomCount;\n        var i, line;\n        for (i = start; i < end; i++, offset++) {\n            line = lines[offset];\n            var atomParts = line.substring(6).match(/\\S+/g);\n            if (atomParts.length > 4) {\n                var atom = {};\n                var elem = atomParts[1].replace(/ /g, \"\");\n                atom.atom = atom.elem =\n                    elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n                if (atom.elem !== \"H\" || !noH) {\n                    atom.serial = i;\n                    serialToIndex[i] = atoms[atoms.length - 1].length;\n                    atom.x = parseFloat(atomParts[2]);\n                    atom.y = parseFloat(atomParts[3]);\n                    atom.z = parseFloat(atomParts[4]);\n                    atom.hetflag = true;\n                    atom.bonds = [];\n                    atom.bondOrder = [];\n                    atom.properties = {};\n                    atom.index = atoms[atoms.length - 1].length;\n                    atoms[atoms.length - 1].push(atom);\n                }\n            }\n        }\n        if (lines[offset] === \"M  V30 END ATOM\")\n            offset++;\n        else\n            break;\n        if (bondCount !== 0 && lines[offset] === \"M  V30 BEGIN BOND\")\n            offset++;\n        else\n            break;\n        for (i = 0; i < bondCount; i++, offset++) {\n            line = lines[offset];\n            var bondParts = line.substring(6).match(/\\S+/g);\n            if (bondParts.length > 3) {\n                var from = serialToIndex[parseInt(bondParts[2]) - 1 + start];\n                var to = serialToIndex[parseInt(bondParts[3]) - 1 + start];\n                var order = parseFloat(bondParts[1]);\n                if (typeof from != \"undefined\" && typeof to != \"undefined\") {\n                    atoms[atoms.length - 1][from].bonds.push(to);\n                    atoms[atoms.length - 1][from].bondOrder.push(order);\n                    atoms[atoms.length - 1][to].bonds.push(from);\n                    atoms[atoms.length - 1][to].bondOrder.push(order);\n                }\n            }\n        }\n        if (options.multimodel) {\n            if (!options.onemol) {\n                atoms.push([]);\n            }\n            while (lines[offset] !== \"$$$$\" && offset < lines.length) {\n                offset++;\n            }\n            lines.splice(0, ++offset);\n        }\n        else {\n            break;\n        }\n    }\n    return atoms;\n};\n/**\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options\n * @category Parsers\n*/\nfunction SDF(str, options) {\n    var molformat = \"V2000\";\n    var lines = str.split(/\\r?\\n|\\r/);\n    if (lines.length > 3 && lines[3].length > 38) {\n        molformat = lines[3].substring(34, 39);\n    }\n    if (molformat === \"V2000\") {\n        return parseV2000(lines, options);\n    }\n    else if (molformat === \"V3000\") {\n        return parseV3000(lines, options);\n    }\n    return [['']];\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/SDF.ts?");

/***/ }),

/***/ "./src/parsers/VASP.ts":
/*!*****************************!*\
  !*** ./src/parsers/VASP.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VASP: () => (/* binding */ VASP)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../WebGL */ \"./src/WebGL/index.ts\");\n\n/**\n * @param {string}\n *            str\n * @param {ParserOptionsSpec}\n *            options\n * @category Parsers\n*/\nfunction VASP(str /*,options*/) {\n    var atoms = [[]];\n    var lattice = {};\n    var lines = str.replace(/^\\s+/, \"\").split(/\\r?\\n/);\n    if (lines.length < 3) {\n        return atoms;\n    }\n    if (lines[1].match(/\\d+/)) {\n        lattice.length = parseFloat(lines[1]);\n    }\n    else {\n        console.log(\"Warning: second line of the vasp structure file must be a number\");\n        return atoms;\n    }\n    if (lattice.length < 0) {\n        console.log(\"Warning: Vasp implementation for negative lattice lengths is not yet available\");\n        return atoms;\n    }\n    lattice.xVec = new Float32Array(lines[2].replace(/^\\s+/, \"\").split(/\\s+/));\n    lattice.yVec = new Float32Array(lines[3].replace(/^\\s+/, \"\").split(/\\s+/));\n    lattice.zVec = new Float32Array(lines[4].replace(/^\\s+/, \"\").split(/\\s+/));\n    var matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix3(lattice.xVec[0], lattice.xVec[1], lattice.xVec[2], lattice.yVec[0], lattice.yVec[1], lattice.yVec[2], lattice.zVec[0], lattice.zVec[1], lattice.zVec[2]);\n    matrix.multiplyScalar(lattice.length);\n    atoms.modelData = [{ symmetries: [], cryst: { matrix: matrix } }];\n    var atomSymbols = lines[5]\n        .replace(/\\s+/, \"\")\n        .replace(/\\s+$/, \"\")\n        .split(/\\s+/);\n    var atomSpeciesNumber = new Int16Array(lines[6].replace(/^\\s+/, \"\").split(/\\s+/));\n    var vaspMode = lines[7].replace(/\\s+/, \"\");\n    if (vaspMode.match(/C/)) {\n        vaspMode = \"cartesian\";\n    }\n    else if (vaspMode.match(/D/)) {\n        vaspMode = \"direct\";\n    }\n    else {\n        console.log(\"Warning: Unknown vasp mode in POSCAR file: mode must be either C(artesian) or D(irect)\");\n        return atoms;\n    }\n    if (atomSymbols.length != atomSpeciesNumber.length) {\n        console.log(\"Warning: declaration of atomary species wrong:\");\n        console.log(atomSymbols);\n        console.log(atomSpeciesNumber);\n        return atoms;\n    }\n    lines.splice(0, 8);\n    var atomCounter = 0;\n    for (var i = 0, len = atomSymbols.length; i < len; i++) {\n        var atomSymbol = atomSymbols[i];\n        for (var j = 0, atomLen = atomSpeciesNumber[i]; j < atomLen; j++) {\n            var coords = new Float32Array(lines[atomCounter + j].replace(/^\\s+/, \"\").split(/\\s+/));\n            var atom = {};\n            atom.elem = atomSymbol;\n            if (vaspMode == \"cartesian\") {\n                atom.x = lattice.length * coords[0];\n                atom.y = lattice.length * coords[1];\n                atom.z = lattice.length * coords[2];\n            }\n            else {\n                atom.x =\n                    lattice.length *\n                        (coords[0] * lattice.xVec[0] +\n                            coords[1] * lattice.yVec[0] +\n                            coords[2] * lattice.zVec[0]);\n                atom.y =\n                    lattice.length *\n                        (coords[0] * lattice.xVec[1] +\n                            coords[1] * lattice.yVec[1] +\n                            coords[2] * lattice.zVec[1]);\n                atom.z =\n                    lattice.length *\n                        (coords[0] * lattice.xVec[2] +\n                            coords[1] * lattice.yVec[2] +\n                            coords[2] * lattice.zVec[2]);\n            }\n            atom.bonds = [];\n            atoms[0].push(atom);\n        }\n        atomCounter += atomSpeciesNumber[i];\n    }\n    return atoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/VASP.ts?");

/***/ }),

/***/ "./src/parsers/XYZ.ts":
/*!****************************!*\
  !*** ./src/parsers/XYZ.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XYZ: () => (/* binding */ XYZ)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/assignBonds */ \"./src/parsers/utils/assignBonds.ts\");\n\n\n/**\n * Read an XYZ file from str and return result\n *\n * @param {string} str\n * @param {ParserOptionsSpec} options\n * @category Parsers\n*/\nfunction XYZ(str, options) {\n    options = options || {};\n    var atoms = [[]];\n    var assignbonds = options.assignBonds === undefined ? true : options.assignBonds;\n    var lines = str.split(/\\r?\\n|\\r/);\n    while (lines.length > 0) {\n        if (lines.length < 3)\n            break;\n        var atomCount = parseInt(lines[0]);\n        if (isNaN(atomCount) || atomCount <= 0)\n            break;\n        if (lines.length < atomCount + 2)\n            break;\n        var lattice_re = /Lattice\\s*=\\s*[\"\\{\\}]([^\"\\{\\}]+)[\"\\{\\}]\\s*/gi;\n        var lattice_match = lattice_re.exec(lines[1]);\n        if (lattice_match != null && lattice_match.length > 1) {\n            var lattice = new Float32Array(lattice_match[1].split(/\\s+/));\n            var matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix3(lattice[0], lattice[3], lattice[6], lattice[1], lattice[4], lattice[7], lattice[2], lattice[5], lattice[8]);\n            atoms.modelData = [{ cryst: { matrix: matrix } }];\n        }\n        var offset = 2;\n        var start = atoms[atoms.length - 1].length;\n        var end = start + atomCount;\n        for (var i = start; i < end; i++) {\n            var line = lines[offset++];\n            var tokens = line.replace(/^\\s+/, \"\").replace(/\\s+/g, \" \").split(\" \");\n            var atom = {};\n            atom.serial = i;\n            var elem = tokens[0];\n            atom.atom = atom.elem =\n                elem[0].toUpperCase() + elem.substring(1, 2).toLowerCase();\n            atom.x = parseFloat(tokens[1]);\n            atom.y = parseFloat(tokens[2]);\n            atom.z = parseFloat(tokens[3]);\n            atom.hetflag = true;\n            atom.bonds = [];\n            atom.bondOrder = [];\n            atom.properties = {};\n            atoms[atoms.length - 1][i] = atom;\n            if (tokens.length >= 7) {\n                atom.dx = parseFloat(tokens[4]);\n                atom.dy = parseFloat(tokens[5]);\n                atom.dz = parseFloat(tokens[6]);\n            }\n        }\n        if (options.multimodel) {\n            atoms.push([]);\n            lines.splice(0, offset);\n        }\n        else {\n            break;\n        }\n    }\n    if (assignbonds) {\n        for (let i = 0; i < atoms.length; i++) {\n            (0,_utils_assignBonds__WEBPACK_IMPORTED_MODULE_1__.assignBonds)(atoms[i], options);\n        }\n    }\n    if (options.onemol) {\n        var temp = atoms;\n        atoms = [];\n        atoms.push(temp[0]);\n        for (let i = 1; i < temp.length; i++) {\n            let offset = atoms[0].length;\n            for (let j = 0; j < temp[i].length; j++) {\n                let a = temp[i][j];\n                for (let k = 0; k < a.bonds.length; k++) {\n                    a.bonds[k] = a.bonds[k] + offset;\n                }\n                a.index = atoms[0].length;\n                a.serial = atoms[0].length;\n                atoms[0].push(a);\n            }\n        }\n    }\n    return atoms;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/XYZ.ts?");

/***/ }),

/***/ "./src/parsers/index.ts":
/*!******************************!*\
  !*** ./src/parsers/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Parsers: () => (/* binding */ Parsers),\n/* harmony export */   bondLength: () => (/* reexport safe */ _utils_bondLength__WEBPACK_IMPORTED_MODULE_13__.bondLength),\n/* harmony export */   setBondLength: () => (/* reexport safe */ _utils_bondLength__WEBPACK_IMPORTED_MODULE_13__.setBondLength)\n/* harmony export */ });\n/* harmony import */ var _VASP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VASP */ \"./src/parsers/VASP.ts\");\n/* harmony import */ var _CUBE__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CUBE */ \"./src/parsers/CUBE.ts\");\n/* harmony import */ var _XYZ__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XYZ */ \"./src/parsers/XYZ.ts\");\n/* harmony import */ var _SDF__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SDF */ \"./src/parsers/SDF.ts\");\n/* harmony import */ var _CDJSON__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CDJSON */ \"./src/parsers/CDJSON.ts\");\n/* harmony import */ var _CIF__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CIF */ \"./src/parsers/CIF.ts\");\n/* harmony import */ var _MOL2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MOL2 */ \"./src/parsers/MOL2.ts\");\n/* harmony import */ var _PDB__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PDB */ \"./src/parsers/PDB.ts\");\n/* harmony import */ var _PQR__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PQR */ \"./src/parsers/PQR.ts\");\n/* harmony import */ var _MMTF__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./MMTF */ \"./src/parsers/MMTF.ts\");\n/* harmony import */ var _PRMTOP__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PRMTOP */ \"./src/parsers/PRMTOP.ts\");\n/* harmony import */ var _GRO__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./GRO */ \"./src/parsers/GRO.ts\");\n/* harmony import */ var _LAMMPSTRJ__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./LAMMPSTRJ */ \"./src/parsers/LAMMPSTRJ.ts\");\n/* harmony import */ var _utils_bondLength__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/bondLength */ \"./src/parsers/utils/bondLength.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// @category Parsers\nconst Parsers = {\n    vasp: _VASP__WEBPACK_IMPORTED_MODULE_0__.VASP,\n    VASP: _VASP__WEBPACK_IMPORTED_MODULE_0__.VASP,\n    cube: _CUBE__WEBPACK_IMPORTED_MODULE_1__.CUBE,\n    CUBE: _CUBE__WEBPACK_IMPORTED_MODULE_1__.CUBE,\n    xyz: _XYZ__WEBPACK_IMPORTED_MODULE_2__.XYZ,\n    XYZ: _XYZ__WEBPACK_IMPORTED_MODULE_2__.XYZ,\n    sdf: _SDF__WEBPACK_IMPORTED_MODULE_3__.SDF,\n    SDF: _SDF__WEBPACK_IMPORTED_MODULE_3__.SDF,\n    json: _CDJSON__WEBPACK_IMPORTED_MODULE_4__.CDJSON,\n    cdjson: _CDJSON__WEBPACK_IMPORTED_MODULE_4__.CDJSON,\n    CDJSON: _CDJSON__WEBPACK_IMPORTED_MODULE_4__.CDJSON,\n    mcif: _CIF__WEBPACK_IMPORTED_MODULE_5__.CIF,\n    cif: _CIF__WEBPACK_IMPORTED_MODULE_5__.CIF,\n    CIF: _CIF__WEBPACK_IMPORTED_MODULE_5__.CIF,\n    mol2: _MOL2__WEBPACK_IMPORTED_MODULE_6__.MOL2,\n    MOL2: _MOL2__WEBPACK_IMPORTED_MODULE_6__.MOL2,\n    pdb: _PDB__WEBPACK_IMPORTED_MODULE_7__.PDB,\n    PDB: _PDB__WEBPACK_IMPORTED_MODULE_7__.PDB,\n    pdbqt: _PDB__WEBPACK_IMPORTED_MODULE_7__.PDB,\n    PDBQT: _PDB__WEBPACK_IMPORTED_MODULE_7__.PDB,\n    pqr: _PQR__WEBPACK_IMPORTED_MODULE_8__.PQR,\n    PQR: _PQR__WEBPACK_IMPORTED_MODULE_8__.PQR,\n    mmtf: _MMTF__WEBPACK_IMPORTED_MODULE_9__.MMTFparser,\n    MMTF: _MMTF__WEBPACK_IMPORTED_MODULE_9__.MMTFparser,\n    prmtop: _PRMTOP__WEBPACK_IMPORTED_MODULE_10__.PRMTOP,\n    PRMTOP: _PRMTOP__WEBPACK_IMPORTED_MODULE_10__.PRMTOP,\n    gro: _GRO__WEBPACK_IMPORTED_MODULE_11__.GRO,\n    GRO: _GRO__WEBPACK_IMPORTED_MODULE_11__.GRO,\n    lammpstrj: _LAMMPSTRJ__WEBPACK_IMPORTED_MODULE_12__.LAMMPSTRJ,\n    LAMMPSTRJ: _LAMMPSTRJ__WEBPACK_IMPORTED_MODULE_12__.LAMMPSTRJ,\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/index.ts?");

/***/ }),

/***/ "./src/parsers/utils/anumToSymbol.ts":
/*!*******************************************!*\
  !*** ./src/parsers/utils/anumToSymbol.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anumToSymbol: () => (/* binding */ anumToSymbol)\n/* harmony export */ });\nconst anumToSymbol = {\n    1: 'H', 2: 'He',\n    3: 'Li', 4: 'Be', 5: 'B', 6: 'C', 7: 'N', 8: 'O', 9: 'F', 10: 'Ne',\n    11: 'Na', 12: 'Mg', 13: 'Al', 14: 'Si', 15: 'P', 16: 'S', 17: 'Cl', 18: 'Ar',\n    19: 'K', 20: 'Ca', 21: 'Sc', 22: 'Ti', 23: 'V', 24: 'Cr', 25: 'Mn', 26: 'Fe', 27: 'Co', 28: 'Ni', 29: 'Cu', 30: 'Zn', 31: 'Ga', 32: 'Ge', 33: 'As', 34: 'Se', 35: 'Br', 36: 'Kr',\n    37: 'Rb', 38: 'Sr', 39: 'Y', 40: 'Zr', 41: 'Nb', 42: 'Mo', 43: 'Tc', 44: 'Ru', 45: 'Rh', 46: 'Pd', 47: 'Ag', 48: 'Cd', 49: 'In', 50: 'Sn', 51: 'Sb', 52: 'Te', 53: 'I', 54: 'Xe',\n    55: 'Cs', 56: 'Ba', 71: 'Lu', 72: 'Hf', 73: 'Ta', 74: 'W', 75: 'Re', 76: 'Os', 77: 'Ir', 78: 'Pt', 79: 'Au', 80: 'Hg', 81: 'Tl', 82: 'Pb', 83: 'Bi', 84: 'Po', 85: 'At', 86: 'Rn',\n    87: 'Fr', 88: 'Ra', 104: 'Rf', 105: 'Db', 106: 'Sg', 107: 'Bh', 108: 'Hs', 109: 'Mt', 110: 'Ds', 111: 'Rg', 112: 'Cn', 113: 'Nh', 114: 'Fl', 115: 'Mc', 116: 'Lv', 117: 'Ts', 118: 'Og',\n    57: 'La', 58: 'Ce', 59: 'Pr', 60: 'Nd', 61: 'Pm', 62: 'Sm', 63: 'Eu', 64: 'Gd', 65: 'Tb', 66: 'Dy', 67: 'Ho', 68: 'Er', 69: 'Tm', 70: 'Yb',\n    89: 'Ac', 90: 'Th', 91: 'Pa', 92: 'U', 93: 'Np', 94: 'Pu', 95: 'Am', 96: 'Cm', 97: 'Bk', 98: 'Cf', 99: 'Es', 100: 'Fm', 101: 'Md', 102: 'No',\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/anumToSymbol.ts?");

/***/ }),

/***/ "./src/parsers/utils/areConnected.ts":
/*!*******************************************!*\
  !*** ./src/parsers/utils/areConnected.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areConnected: () => (/* binding */ areConnected)\n/* harmony export */ });\n/* harmony import */ var _bondLength__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bondLength */ \"./src/parsers/utils/bondLength.ts\");\n\nconst cations = new Set([\"Na\", \"K\", \"Ca\", \"Mg\", \"Mn\", \"Sr\"]);\n/*\n * Return true if atom1 and atom2 are probably bonded to each other based on distance alone\n */\nfunction areConnected(atom1, atom2, options) {\n    if (options && options.unboundCations && (cations.has(atom1.elem) || cations.has(atom2.elem))) {\n        return false;\n    }\n    let maxsq = (0,_bondLength__WEBPACK_IMPORTED_MODULE_0__.bondLength)(atom1.elem) + (0,_bondLength__WEBPACK_IMPORTED_MODULE_0__.bondLength)(atom2.elem);\n    maxsq += 0.25; // fudge factor, especially important for md frames, also see 1i3d\n    maxsq *= maxsq;\n    let xdiff = atom1.x - atom2.x;\n    xdiff *= xdiff;\n    if (xdiff > maxsq)\n        return false;\n    let ydiff = atom1.y - atom2.y;\n    ydiff *= ydiff;\n    if (ydiff > maxsq)\n        return false;\n    let zdiff = atom1.z - atom2.z;\n    zdiff *= zdiff;\n    if (zdiff > maxsq)\n        return false;\n    const distSquared = xdiff + ydiff + zdiff;\n    if (isNaN(distSquared) ||\n        distSquared < 0.5 ||\n        distSquared > maxsq ||\n        (atom1.altLoc !== atom2.altLoc && atom1.altLoc !== \" \" && atom2.altLoc !== \" \"))\n        return false;\n    return true;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/areConnected.ts?");

/***/ }),

/***/ "./src/parsers/utils/assignBackboneHBonds.ts":
/*!***************************************************!*\
  !*** ./src/parsers/utils/assignBackboneHBonds.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignBackboneHBonds: () => (/* binding */ assignBackboneHBonds)\n/* harmony export */ });\n// This will identify all hydrogen bonds between backbone\n// atoms; assume atom names are correct, only identifies\n// single closest hbond\n// interface Atoms {index: number; atom: string; hbondDistanceSq: number; hbondOther: any; hetflag:any}\nfunction assignBackboneHBonds(atomsarray, hbondCutoff) {\n    const maxlength = hbondCutoff || 3.2;\n    const maxlengthSq = maxlength * maxlength;\n    const atoms = [];\n    for (let i = 0, n = atomsarray.length; i < n; i++) {\n        atomsarray[i].index = i;\n        // only consider 'N' and 'O'\n        const atom = atomsarray[i];\n        if (!atom.hetflag && (atom.atom === \"N\" || atom.atom === \"O\")) {\n            atoms.push(atom);\n            atom.hbondOther = null;\n            atom.hbondDistanceSq = Number.POSITIVE_INFINITY;\n        }\n    }\n    atoms.sort(function (a, b) {\n        return a.z - b.z;\n    });\n    for (let i = 0, n = atoms.length; i < n; i++) {\n        const ai = atoms[i];\n        for (let j = i + 1; j < n; j++) {\n            const aj = atoms[j];\n            const zdiff = aj.z - ai.z;\n            if (zdiff > maxlength)\n                // can't be connected\n                break;\n            if (aj.atom == ai.atom)\n                continue; // can't be connected, but later might be\n            const ydiff = Math.abs(aj.y - ai.y);\n            if (ydiff > maxlength)\n                continue;\n            const xdiff = Math.abs(aj.x - ai.x);\n            if (xdiff > maxlength)\n                continue;\n            const dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;\n            if (dist > maxlengthSq)\n                continue;\n            if (aj.chain == ai.chain && Math.abs(aj.resi - ai.resi) < 4)\n                continue; // ignore bonds between too close residues\n            // select closest hbond\n            if (dist < ai.hbondDistanceSq) {\n                ai.hbondOther = aj;\n                ai.hbondDistanceSq = dist;\n            }\n            if (dist < aj.hbondDistanceSq) {\n                aj.hbondOther = ai;\n                aj.hbondDistanceSq = dist;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/assignBackboneHBonds.ts?");

/***/ }),

/***/ "./src/parsers/utils/assignBonds.ts":
/*!******************************************!*\
  !*** ./src/parsers/utils/assignBonds.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignBonds: () => (/* binding */ assignBonds)\n/* harmony export */ });\n/* harmony import */ var _areConnected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./areConnected */ \"./src/parsers/utils/areConnected.ts\");\n\n/**\n * @param {AtomSpec[]} atoms\n */\nconst OFFSETS = [\n    { x: 0, y: 0, z: 1 },\n    { x: 0, y: 1, z: -1 },\n    { x: 0, y: 1, z: 0 },\n    { x: 0, y: 1, z: 1 },\n    { x: 1, y: -1, z: -1 },\n    { x: 1, y: -1, z: 0 },\n    { x: 1, y: -1, z: 1 },\n    { x: 1, y: 0, z: -1 },\n    { x: 1, y: 0, z: 0 },\n    { x: 1, y: 0, z: 1 },\n    { x: 1, y: 1, z: -1 },\n    { x: 1, y: 1, z: 0 },\n    { x: 1, y: 1, z: 1 },\n];\nconst MAX_BOND_LENGTH = 4.95; // (largest bond length, Cs) 2.25 * 2 * 1.1 (fudge factor)\nfunction assignBonds(atoms, options) {\n    // Assign bonds - yuck, can't count on connect records\n    for (let i = 0, n = atoms.length; i < n; i++) {\n        // Don't reindex if atoms are already indexed\n        if (!atoms[i].index)\n            atoms[i].index = i;\n    }\n    const grid = {\n        x: {\n            y: {\n                z: [],\n            },\n        },\n    };\n    for (let index = 0; index < atoms.length; index++) {\n        const atom = atoms[index];\n        const x = Math.floor(atom.x / MAX_BOND_LENGTH);\n        const y = Math.floor(atom.y / MAX_BOND_LENGTH);\n        const z = Math.floor(atom.z / MAX_BOND_LENGTH);\n        if (!grid[x]) {\n            grid[x] = {};\n        }\n        if (!grid[x][y]) {\n            grid[x][y] = {};\n        }\n        if (!grid[x][y][z]) {\n            grid[x][y][z] = [];\n        }\n        grid[x][y][z].push(atom);\n    }\n    function findConnections(points, otherPoints) {\n        for (let i = 0; i < points.length; i++) {\n            const atom1 = points[i];\n            for (let j = 0; j < otherPoints.length; j++) {\n                const atom2 = otherPoints[j];\n                if ((0,_areConnected__WEBPACK_IMPORTED_MODULE_0__.areConnected)(atom1, atom2, options)) {\n                    //gracefully handle one-sided bonds\n                    const a2i = atom1.bonds.indexOf(atom2.index);\n                    const a1i = atom2.bonds.indexOf(atom1.index);\n                    if (a2i === -1 && a1i === -1) {\n                        atom1.bonds.push(atom2.index);\n                        atom1.bondOrder.push(1);\n                        atom2.bonds.push(atom1.index);\n                        atom2.bondOrder.push(1);\n                    }\n                    else if (a2i === -1) {\n                        atom1.bonds.push(atom2.index);\n                        atom1.bondOrder.push(atom2.bondOrder[a1i]);\n                    }\n                    else if (a1i === -1) {\n                        atom2.bonds.push(atom1.index);\n                        atom2.bondOrder.push(atom1.bondOrder[a2i]);\n                    }\n                }\n            }\n        }\n    }\n    for (let xg in grid) {\n        const x = parseInt(xg);\n        for (let yg in grid[x]) {\n            const y = parseInt(yg);\n            for (let zg in grid[x][y]) {\n                const z = parseInt(zg);\n                const points = grid[x][y][z];\n                for (let i = 0; i < points.length; i++) {\n                    const atom1 = points[i];\n                    for (let j = i + 1; j < points.length; j++) {\n                        const atom2 = points[j];\n                        if ((0,_areConnected__WEBPACK_IMPORTED_MODULE_0__.areConnected)(atom1, atom2, options)) {\n                            if (atom1.bonds.indexOf(atom2.index) == -1) {\n                                atom1.bonds.push(atom2.index);\n                                atom1.bondOrder.push(1);\n                                atom2.bonds.push(atom1.index);\n                                atom2.bondOrder.push(1);\n                            }\n                        }\n                    }\n                }\n                for (let o = 0; o < OFFSETS.length; o++) {\n                    const offset = OFFSETS[o];\n                    if (!grid[x + offset.x] ||\n                        !grid[x + offset.x][y + offset.y] ||\n                        !grid[x + offset.x][y + offset.y][z + offset.z])\n                        continue;\n                    const otherPoints = grid[x + offset.x][y + offset.y][z + offset.z];\n                    findConnections(points, otherPoints);\n                }\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/assignBonds.ts?");

/***/ }),

/***/ "./src/parsers/utils/assignPDBBonds.ts":
/*!*********************************************!*\
  !*** ./src/parsers/utils/assignPDBBonds.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignPDBBonds: () => (/* binding */ assignPDBBonds)\n/* harmony export */ });\n/* harmony import */ var _areConnected__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./areConnected */ \"./src/parsers/utils/areConnected.ts\");\n/* harmony import */ var _assignBonds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assignBonds */ \"./src/parsers/utils/assignBonds.ts\");\n/* harmony import */ var _standardResidues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./standardResidues */ \"./src/parsers/utils/standardResidues.ts\");\n// This is optimized for proteins where it is assumed connected atoms are on the same or next residue\n\n\n\n/**\n * @param {AtomSpec[]}\n *            atomsarray\n */\nfunction assignPDBBonds(atomsarray, options) {\n    // assign bonds - yuck, can't count on connect records\n    const protatoms = [];\n    const hetatoms = [];\n    for (let i = 0, n = atomsarray.length; i < n; i++) {\n        const atom = atomsarray[i];\n        atom.index = i;\n        if (atom.hetflag || !_standardResidues__WEBPACK_IMPORTED_MODULE_2__.standardResidues.has(atom.resn))\n            hetatoms.push(atom);\n        else\n            protatoms.push(atom);\n    }\n    (0,_assignBonds__WEBPACK_IMPORTED_MODULE_1__.assignBonds)(hetatoms, options);\n    // sort by resid\n    protatoms.sort(function (a, b) {\n        if (a.chain !== b.chain)\n            return a.chain < b.chain ? -1 : 1;\n        return a.resi - b.resi;\n    });\n    // for identifying connected residues\n    let currentResi = -1;\n    let reschain = -1;\n    let lastResConnected;\n    for (let i = 0, n = protatoms.length; i < n; i++) {\n        const ai = protatoms[i];\n        if (ai.resi !== currentResi) {\n            currentResi = ai.resi;\n            if (!lastResConnected)\n                reschain++;\n            lastResConnected = false;\n        }\n        ai.reschain = reschain;\n        for (let j = i + 1; j < protatoms.length; j++) {\n            const aj = protatoms[j];\n            if (aj.chain !== ai.chain || aj.resi - ai.resi > 1)\n                break;\n            if ((0,_areConnected__WEBPACK_IMPORTED_MODULE_0__.areConnected)(ai, aj, options)) {\n                if (ai.bonds.indexOf(aj.index) === -1) {\n                    // only add if not already there\n                    ai.bonds.push(aj.index);\n                    ai.bondOrder.push(1);\n                    aj.bonds.push(ai.index);\n                    aj.bondOrder.push(1);\n                }\n                if (ai.resi !== aj.resi)\n                    lastResConnected = true;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/assignPDBBonds.ts?");

/***/ }),

/***/ "./src/parsers/utils/atomNameToElem.ts":
/*!*********************************************!*\
  !*** ./src/parsers/utils/atomNameToElem.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atomNameToElem: () => (/* binding */ atomNameToElem)\n/* harmony export */ });\n/* harmony import */ var _bondLength__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bondLength */ \"./src/parsers/utils/bondLength.ts\");\n\n// Attempts to infer atomic element from an atom name\nfunction atomNameToElem(name, nothetero) {\n    let elem = name.replace(/ /g, \"\");\n    if (elem.length > 0 &&\n        elem[0] === \"H\" &&\n        elem !== \"Hg\" &&\n        elem !== \"He\" &&\n        elem !== \"Hf\" &&\n        elem !== \"Hs\" &&\n        elem !== \"Ho\") {\n        elem = \"H\"; //workaround weird hydrogen names from MD, note mercury must use lowercase\n    }\n    if (elem.length > 1) {\n        elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n        if (_bondLength__WEBPACK_IMPORTED_MODULE_0__.bondTable[elem] === undefined) {\n            //not a known element, probably should just use first letter\n            elem = elem[0];\n        }\n        else if (nothetero) {\n            if (elem === \"Ca\") {\n                //alpha carbon, not calcium\n                elem = \"C\";\n            }\n            else if (elem === \"Cd\") {\n                elem = \"C\";\n            }\n        }\n    }\n    return elem;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/atomNameToElem.ts?");

/***/ }),

/***/ "./src/parsers/utils/bondLength.ts":
/*!*****************************************!*\
  !*** ./src/parsers/utils/bondLength.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bondLength: () => (/* binding */ bondLength),\n/* harmony export */   bondTable: () => (/* binding */ bondTable),\n/* harmony export */   setBondLength: () => (/* binding */ setBondLength)\n/* harmony export */ });\n// Covalent radii lookup table used to identify bonds in assignBonds\nlet bondTable = {\n    H: 0.37, He: 0.32,\n    Li: 1.34, Be: 0.90, B: 0.82, C: 0.77, N: 0.75, O: 0.73, F: 0.71, Ne: 0.69,\n    Na: 1.54, Mg: 1.30, Al: 1.18, Si: 1.11, P: 1.06, S: 1.02, Cl: 0.99, Ar: 0.97,\n    K: 1.96, Ca: 1.74, Sc: 1.44, Ti: 1.56, V: 1.25, /* Cr */ Mn: 1.39, Fe: 1.25, Co: 1.26, Ni: 1.21, Cu: 1.38, Zn: 1.31, Ga: 1.26, Ge: 1.22, /* As */ Se: 1.16, Br: 1.14, Kr: 1.10,\n    Rb: 2.11, Sr: 1.92, Y: 1.62, Zr: 1.48, Nb: 1.37, Mo: 1.45, Tc: 1.56, Ru: 1.26, Rh: 1.35, Pd: 1.31, Ag: 1.53, Cd: 1.48, In: 1.44, Sn: 1.41, Sb: 1.38, Te: 1.35, I: 1.33, Xe: 1.30,\n    Cs: 2.25, Ba: 1.98, Lu: 1.60, Hf: 1.50, Ta: 1.38, W: 1.46, Re: 1.59, Os: 1.44, Ir: 1.37, Pt: 1.28, Au: 1.44, Hg: 1.49, Tl: 1.48, Pb: 1.47, Bi: 1.46, /* Po */ /* At */ Rn: 1.45,\n    // None of the bottom row or any of the Lanthanides have bond lengths\n};\n// Get the length used for bond identification for the specified element.\nfunction bondLength(elem) {\n    return bondTable[elem] || 1.6;\n}\n// Set the length used for bond identification for the specified element.\nfunction setBondLength(elem, radius) {\n    if (radius < 0)\n        radius = 0;\n    bondTable[elem] = radius;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/bondLength.ts?");

/***/ }),

/***/ "./src/parsers/utils/computeSecondaryStructure.ts":
/*!********************************************************!*\
  !*** ./src/parsers/utils/computeSecondaryStructure.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeSecondaryStructure: () => (/* binding */ computeSecondaryStructure)\n/* harmony export */ });\n/* harmony import */ var _assignBackboneHBonds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assignBackboneHBonds */ \"./src/parsers/utils/assignBackboneHBonds.ts\");\n\nfunction computeSecondaryStructure(atomsarray, hbondCutoff) {\n    (0,_assignBackboneHBonds__WEBPACK_IMPORTED_MODULE_0__.assignBackboneHBonds)(atomsarray, hbondCutoff);\n    // compute, per residue, what the secondary structure is\n    const chres = {}; // lookup by chain and resid\n    let i, il, c, r; // i: used in for loop, il: length of atomsarray\n    let atom, val;\n    //identify helices first\n    for (i = 0, il = atomsarray.length; i < il; i++) {\n        atom = atomsarray[i];\n        if (chres[atom.chain] === undefined)\n            chres[atom.chain] = [];\n        if (isFinite(atom.hbondDistanceSq)) {\n            const other = atom.hbondOther;\n            if (chres[other.chain] === undefined)\n                chres[other.chain] = [];\n            if (Math.abs(other.resi - atom.resi) === 4) {\n                // helix\n                chres[atom.chain][atom.resi] = \"h\";\n            }\n        }\n    }\n    // plug gaps in helices\n    for (c in chres) {\n        for (r = 1; r < chres[c].length - 1; r++) {\n            const valbefore = chres[c][r - 1];\n            const valafter = chres[c][r + 1];\n            val = chres[c][r];\n            if (valbefore == \"h\" && valbefore == valafter && val != valbefore) {\n                chres[c][r] = valbefore;\n            }\n        }\n    }\n    //now potential sheets - but only if mate not part of helix\n    for (i = 0, il = atomsarray.length; i < il; i++) {\n        atom = atomsarray[i];\n        if (isFinite(atom.hbondDistanceSq) &&\n            chres[atom.chain][atom.resi] != \"h\" &&\n            atom.ss !== \"h\") {\n            chres[atom.chain][atom.resi] = \"maybesheet\";\n        }\n    }\n    //sheets must bond to other sheets\n    for (let i = 0, il = atomsarray.length; i < il; i++) {\n        atom = atomsarray[i];\n        if (isFinite(atom.hbondDistanceSq) &&\n            chres[atom.chain][atom.resi] == \"maybesheet\") {\n            let other = atom.hbondOther;\n            let otherval = chres[other.chain][other.resi];\n            if (otherval == \"maybesheet\" || otherval == \"s\") {\n                // true sheet\n                chres[atom.chain][atom.resi] = \"s\";\n                chres[other.chain][other.resi] = \"s\";\n            }\n        }\n    }\n    // plug gaps in sheets and remove singletons\n    for (let c in chres) {\n        for (let r = 1; r < chres[c].length - 1; r++) {\n            const valbefore = chres[c][r - 1];\n            const valafter = chres[c][r + 1];\n            val = chres[c][r];\n            if (valbefore == \"s\" && valbefore == valafter && val != valbefore) {\n                chres[c][r] = valbefore;\n            }\n        }\n        for (let r = 0; r < chres[c].length; r++) {\n            const val = chres[c][r];\n            if (val == \"h\" || val == \"s\") {\n                if (chres[c][r - 1] != val && chres[c][r + 1] != val)\n                    delete chres[c][r];\n            }\n        }\n    }\n    // assign to all atoms in residue, keep track of start\n    for (i = 0, il = atomsarray.length; i < il; i++) {\n        atom = atomsarray[i];\n        val = chres[atom.chain][atom.resi];\n        //clear hbondOther to eliminate circular references that prohibit serialization\n        delete atom.hbondOther;\n        delete atom.hbondDistanceSq;\n        if (val === undefined || val === \"maybesheet\")\n            continue;\n        atom.ss = val;\n        if (chres[atom.chain][atom.resi - 1] != val)\n            atom.ssbegin = true;\n        if (chres[atom.chain][atom.resi + 1] != val)\n            atom.ssend = true;\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/computeSecondaryStructure.ts?");

/***/ }),

/***/ "./src/parsers/utils/getSinglePDB.ts":
/*!*******************************************!*\
  !*** ./src/parsers/utils/getSinglePDB.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSinglePDB: () => (/* binding */ getSinglePDB)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../WebGL */ \"./src/WebGL/index.ts\");\n/* harmony import */ var _atomNameToElem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./atomNameToElem */ \"./src/parsers/utils/atomNameToElem.ts\");\n/* harmony import */ var _bondLength__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bondLength */ \"./src/parsers/utils/bondLength.ts\");\n/* harmony import */ var _computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./computeSecondaryStructure */ \"./src/parsers/utils/computeSecondaryStructure.ts\");\n/* harmony import */ var _isEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isEmpty */ \"./src/parsers/utils/isEmpty.ts\");\n/* harmony import */ var _processSymmetries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./processSymmetries */ \"./src/parsers/utils/processSymmetries.ts\");\n/* harmony import */ var _assignPDBBonds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./assignPDBBonds */ \"./src/parsers/utils/assignPDBBonds.ts\");\n/* harmony import */ var _validateBonds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./validateBonds */ \"./src/parsers/utils/validateBonds.ts\");\n\n\n\n\n\n\n\n\n// Return one model worth of pdb, returns atoms, modelData, and remaining lines\nfunction getSinglePDB(lines, options, sslookup) {\n    const atoms = [];\n    const assignbonds = options.assignBonds === undefined ? true : options.assignBonds;\n    const noH = !options.keepH; // suppress hydrogens by default\n    const ignoreStruct = !!options.noSecondaryStructure;\n    const computeStruct = !options.noComputeSecondaryStructure;\n    const noAssembly = !options.doAssembly; // don't assemble by default\n    const selAltLoc = options.altLoc ? options.altLoc : \"A\"; //default alternate location to select if present\n    const modelData = { symmetries: [], cryst: undefined };\n    //atom name\n    let atom;\n    let remainingLines = [];\n    const serialToIndex = []; // map from pdb serial to index in atoms\n    let line;\n    const seenbonds = {}; //sometimes connect records are duplicated as an unofficial means of relaying bond orders\n    for (let i = 0; i < lines.length; i++) {\n        line = lines[i].replace(/^\\s*/, \"\"); // remove indent\n        const recordName = line.substring(0, 6);\n        let startChain, startResi, endResi;\n        if (recordName.indexOf(\"END\") === 0) {\n            remainingLines = lines.slice(i + 1);\n            if (recordName === \"END\") {\n                //as opposed to ENDMDL\n                //reset secondary structure\n                for (const prop in sslookup) {\n                    if (sslookup.hasOwnProperty(prop)) {\n                        delete sslookup[prop];\n                    }\n                }\n            }\n            break;\n        }\n        else if (recordName === \"ATOM  \" || recordName === \"HETATM\") {\n            let resn, chain, resi, icode, x, y, z, hetflag, elem, serial, altLoc, b;\n            altLoc = line.substring(16, 17);\n            if (altLoc !== \" \" && altLoc !== selAltLoc && selAltLoc !== \"*\")\n                continue;\n            serial = parseInt(line.substring(6, 11));\n            atom = line.substring(12, 16).replace(/ /g, \"\");\n            resn = line.substring(17, 20).replace(/ /g, \"\");\n            chain = line.substring(21, 22);\n            resi = parseInt(line.substring(22, 26));\n            icode = line.substring(26, 27);\n            x = parseFloat(line.substring(30, 38));\n            y = parseFloat(line.substring(38, 46));\n            z = parseFloat(line.substring(46, 54));\n            b = parseFloat(line.substring(60, 68));\n            elem = line.substring(76, 78).replace(/ /g, \"\");\n            if (elem === \"\" || _bondLength__WEBPACK_IMPORTED_MODULE_2__.bondTable[elem] === undefined) {\n                // for some incorrect PDB files\n                elem = (0,_atomNameToElem__WEBPACK_IMPORTED_MODULE_1__.atomNameToElem)(line.substring(12, 14), line[0] == \"A\");\n            }\n            else {\n                elem = elem[0].toUpperCase() + elem.substring(1).toLowerCase();\n            }\n            if (elem === \"H\" && noH)\n                continue;\n            if (recordName[0] == \"H\")\n                hetflag = true;\n            else\n                hetflag = false;\n            serialToIndex[serial] = atoms.length;\n            atoms.push({\n                resn,\n                x,\n                y,\n                z,\n                elem,\n                hetflag,\n                altLoc,\n                chain,\n                resi,\n                icode: icode,\n                rescode: resi + (icode !== \" \" ? \"^\" + icode : \"\"),\n                // resi\n                // and\n                // icode\n                serial,\n                atom,\n                bonds: [],\n                ss: \"c\",\n                bondOrder: [],\n                properties: {},\n                b,\n                pdbline: line,\n            });\n        }\n        else if (recordName === \"SHEET \") {\n            startChain = line.substring(21, 22);\n            startResi = parseInt(line.substring(22, 26));\n            endResi = parseInt(line.substring(33, 37));\n            if (!(startChain in sslookup)) {\n                sslookup[startChain] = {};\n            }\n            //mark start and end with additional character\n            sslookup[startChain][startResi] = \"s1\";\n            for (let res = startResi + 1; res < endResi; res++) {\n                sslookup[startChain][res] = \"s\";\n            }\n            sslookup[startChain][endResi] = \"s2\";\n        }\n        else if (recordName === \"CONECT\") {\n            // MEMO: We don't have to parse SSBOND, LINK because both are\n            // also\n            // described in CONECT. But what about 2JYT???\n            const from = parseInt(line.substring(6, 11));\n            const fromindex = serialToIndex[from];\n            const fromAtom = atoms[fromindex];\n            const coffsets = [11, 16, 21, 26];\n            for (let j = 0; j < 4; j++) {\n                const to = parseInt(line.substring(coffsets[j], coffsets[j] + 5));\n                const toindex = serialToIndex[to];\n                let from_to = fromindex + \":\" + toindex;\n                const toAtom = atoms[toindex];\n                if (fromAtom !== undefined && toAtom !== undefined) {\n                    // duplicated conect records indicate bond order\n                    if (!seenbonds[from_to]) {\n                        seenbonds[from_to] = 1;\n                        if (fromAtom.bonds.length == 0 ||\n                            fromAtom.bonds[fromAtom.bonds.length - 1] !== toindex) {\n                            fromAtom.bonds.push(toindex);\n                            fromAtom.bondOrder.push(1);\n                        }\n                    }\n                    else {\n                        //update bond order\n                        seenbonds[from_to] += 1;\n                        for (let bi = 0; bi < fromAtom.bonds.length; bi++) {\n                            if (fromAtom.bonds[bi] == toindex) {\n                                const newbo = seenbonds[from_to];\n                                if (newbo >= 4) {\n                                    //aromatic\n                                    fromAtom.bondOrder[bi] = 1;\n                                }\n                                else {\n                                    fromAtom.bondOrder[bi] = newbo;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else if (recordName === \"HELIX \") {\n            startChain = line.substring(19, 20);\n            startResi = parseInt(line.substring(21, 25));\n            endResi = parseInt(line.substring(33, 37));\n            if (!(startChain in sslookup)) {\n                sslookup[startChain] = {};\n            }\n            sslookup[startChain][startResi] = \"h1\";\n            for (let res = startResi + 1; res < endResi; res++) {\n                sslookup[startChain][res] = \"h\";\n            }\n            sslookup[startChain][endResi] = \"h2\";\n        }\n        else if (!noAssembly &&\n            recordName === \"REMARK\" &&\n            line.substring(13, 18) === \"BIOMT\") {\n            let n;\n            let matrix = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n            for (n = 1; n <= 3; n++) {\n                line = lines[i].replace(/^\\s*/, \"\");\n                if (parseInt(line.substring(18, 19)) == n) {\n                    // check for all\n                    // three lines\n                    // by matching #\n                    // @ end of\n                    // \"BIOMT\" to n\n                    matrix.elements[n - 1] = parseFloat(line.substring(23, 33));\n                    matrix.elements[n - 1 + 4] = parseFloat(line.substring(33, 43));\n                    matrix.elements[n - 1 + 8] = parseFloat(line.substring(43, 53));\n                    matrix.elements[n - 1 + 12] = parseFloat(line.substring(53));\n                    i++;\n                }\n                else {\n                    while (line.substring(13, 18) === \"BIOMT\") {\n                        i++;\n                        line = lines[i].replace(/^\\s*/, \"\");\n                    }\n                }\n            }\n            matrix.elements[3] = 0;\n            matrix.elements[7] = 0;\n            matrix.elements[11] = 0;\n            matrix.elements[15] = 1;\n            modelData.symmetries.push(matrix);\n            i--; // set i back\n        }\n        else if (recordName === \"CRYST1\") {\n            let a, b, c, alpha, beta, gamma;\n            a = parseFloat(line.substring(7, 15));\n            b = parseFloat(line.substring(16, 24));\n            c = parseFloat(line.substring(25, 33));\n            alpha = parseFloat(line.substring(34, 40));\n            beta = parseFloat(line.substring(41, 47));\n            gamma = parseFloat(line.substring(48, 54));\n            modelData.cryst = {\n                a,\n                b,\n                c,\n                alpha,\n                beta,\n                gamma,\n            };\n        }\n        else if (recordName === \"ANISOU\") {\n            const serial = parseInt(line.substring(6, 11));\n            const anisouAtomIndex = serialToIndex[serial];\n            const anisouAtom = atoms[anisouAtomIndex];\n            if (anisouAtom) {\n                const vals = line.substring(30).trim().split(/\\s+/);\n                const uMat = {\n                    u11: parseInt(vals[0]),\n                    u22: parseInt(vals[1]),\n                    u33: parseInt(vals[2]),\n                    u12: parseInt(vals[3]),\n                    u13: parseInt(vals[4]),\n                    u23: parseInt(vals[5]),\n                };\n                anisouAtom.uMat = uMat;\n            }\n        }\n    }\n    //fix any \"one-way\" bonds in CONECT records\n    (0,_validateBonds__WEBPACK_IMPORTED_MODULE_7__.validateBonds)(atoms, serialToIndex);\n    // assign bonds - yuck, can't count on connect records\n    if (assignbonds)\n        (0,_assignPDBBonds__WEBPACK_IMPORTED_MODULE_6__.assignPDBBonds)(atoms, options);\n    if (!noAssembly)\n        (0,_processSymmetries__WEBPACK_IMPORTED_MODULE_5__.processSymmetries)(modelData.symmetries, atoms, options, modelData.cryst);\n    if (computeStruct && !ignoreStruct) {\n        (0,_computeSecondaryStructure__WEBPACK_IMPORTED_MODULE_3__.computeSecondaryStructure)(atoms, options.hbondCutoff);\n    }\n    // Assign secondary structures from pdb file\n    if (!(0,_isEmpty__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(sslookup)) {\n        for (let i = 0; i < atoms.length; i++) {\n            const atom = atoms[i];\n            if (atom === undefined)\n                continue;\n            if (atom.chain in sslookup && atom.resi in sslookup[atom.chain]) {\n                const code = sslookup[atom.chain][atom.resi];\n                atom.ss = code[0];\n                if (code.length > 1) {\n                    if (code[1] == \"1\")\n                        atom.ssbegin = true;\n                    else if (code[1] == \"2\")\n                        atom.ssend = true;\n                }\n            }\n        }\n    }\n    //console.log(\"assign structure \" + ((new Date()).getTime() - starttime));\n    return [atoms, modelData, remainingLines];\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/getSinglePDB.ts?");

/***/ }),

/***/ "./src/parsers/utils/isEmpty.ts":
/*!**************************************!*\
  !*** ./src/parsers/utils/isEmpty.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty)\n/* harmony export */ });\nfunction isEmpty(obj) {\n    for (const _ in obj) {\n        return false;\n    }\n    return true;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/isEmpty.ts?");

/***/ }),

/***/ "./src/parsers/utils/processSymmetries.ts":
/*!************************************************!*\
  !*** ./src/parsers/utils/processSymmetries.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processSymmetries: () => (/* binding */ processSymmetries)\n/* harmony export */ });\n/* harmony import */ var _WebGL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../WebGL */ \"./src/WebGL/index.ts\");\n\n// Adds symmetry info to either duplicate and rotate/translate biological unit later or add extra atoms now\n// matrices may be modified if normalization is requested\nfunction processSymmetries(copyMatrices, atoms, options, cryst) {\n    const dontDuplicate = !options.duplicateAssemblyAtoms;\n    const end = atoms.length;\n    let offset = end;\n    let modifiedIdentity = -1;\n    let conversionMatrix = null;\n    let toFrac = null;\n    if ((options.normalizeAssembly || options.wrapAtoms) && cryst) {\n        conversionMatrix = (0,_WebGL__WEBPACK_IMPORTED_MODULE_0__.conversionMatrix3)(cryst.a, cryst.b, cryst.c, cryst.alpha, cryst.beta, cryst.gamma);\n        toFrac = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Matrix3();\n        toFrac.getInverse3(conversionMatrix);\n    }\n    let getAdjustment = function (v) {\n        let c = v.clone().applyMatrix3(toFrac);\n        const coord = [c.x, c.y, c.z];\n        const adjustment = [0.0, 0.0, 0.0];\n        for (let i = 0; i < 3; i++) {\n            while (coord[i] < -0.001) {\n                coord[i] += 1.0;\n                adjustment[i] += 1.0;\n            }\n            while (coord[i] > 1.001) {\n                coord[i] -= 1.0;\n                adjustment[i] -= 1.0;\n            }\n        }\n        //convert adjustment to non-fractional\n        const adjustmentVec = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(adjustment[0], adjustment[1], adjustment[2]);\n        adjustmentVec.applyMatrix3(conversionMatrix);\n        return adjustmentVec;\n    };\n    if (options.normalizeAssembly && cryst) {\n        //to normalize, translate every symmetry so that the centroid is\n        //in the unit cell.  To do this, convert back to fractional coordinates,\n        //compute the centroid, calculate any adjustment needed to get it in [0,1],\n        //convert the adjustment to a cartesian translation, and then add it to\n        //the symmetry matrix\n        for (let t = 0; t < copyMatrices.length; t++) {\n            //transform with the symmetry, and then back to fractional coordinates\n            const center = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n            for (let n = 0; n < end; n++) {\n                const xyz = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3(atoms[n].x, atoms[n].y, atoms[n].z);\n                xyz.applyMatrix4(copyMatrices[t]);\n                //figure out\n                center.add(xyz);\n            }\n            center.divideScalar(end);\n            const adjustmentVec = getAdjustment(center);\n            //modify symmetry matrix to include translation\n            if (copyMatrices[t].isNearlyIdentity() &&\n                adjustmentVec.lengthSq() > 0.001) {\n                modifiedIdentity = t; //keep track of which matrix was identity\n            }\n            copyMatrices[t].translate(adjustmentVec);\n        }\n    }\n    if (!dontDuplicate) {\n        // do full assembly\n        for (let n = 0; n < end; n++) {\n            atoms[n].sym = -1; //if identity matrix is present, original labeled -1\n        }\n        for (let t = 0; t < copyMatrices.length; t++) {\n            if (!copyMatrices[t].isNearlyIdentity() && modifiedIdentity != t) {\n                let xyz = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                for (let n = 0; n < end; n++) {\n                    const bondsArr = [];\n                    for (let l = 0; l < atoms[n].bonds.length; l++) {\n                        bondsArr.push(atoms[n].bonds[l] + offset);\n                    }\n                    xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);\n                    xyz.applyMatrix4(copyMatrices[t]);\n                    if (options.wrapAtoms && cryst) {\n                        //wrap per-atom instead of per matrix using the centroid\n                        let adjustment = getAdjustment(xyz);\n                        xyz.add(adjustment);\n                    }\n                    const newAtom = {};\n                    for (const i in atoms[n]) {\n                        newAtom[i] = atoms[n][i];\n                    }\n                    newAtom.x = xyz.x;\n                    newAtom.y = xyz.y;\n                    newAtom.z = xyz.z;\n                    newAtom.bonds = bondsArr;\n                    newAtom.sym = t; //so symmetries can be selected\n                    newAtom.index = atoms.length;\n                    atoms.push(newAtom);\n                }\n                offset = atoms.length;\n            }\n            else {\n                for (let n = 0; n < end; n++) {\n                    atoms[n].sym = t;\n                }\n            }\n        }\n        if (options.wrapAtoms && cryst) {\n            //wrap reference coordinates, because the world isn't kind enough\n            //to ensure these are in the box\n            let xyz = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            for (let n = 0; n < end; n++) {\n                xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);\n                //wrap per-atom instead of per matrix using the centroid\n                let adjustment = getAdjustment(xyz);\n                xyz.add(adjustment);\n                atoms[n].x = xyz.x;\n                atoms[n].y = xyz.y;\n                atoms[n].z = xyz.z;\n            }\n        }\n        if (modifiedIdentity >= 0) {\n            //after applying the other transformations, apply this one in place\n            const xyz = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            for (let n = 0; n < end; n++) {\n                xyz.set(atoms[n].x, atoms[n].y, atoms[n].z);\n                xyz.applyMatrix4(copyMatrices[modifiedIdentity]);\n                atoms[n].x = xyz.x;\n                atoms[n].y = xyz.y;\n                atoms[n].z = xyz.z;\n            }\n        }\n        //we have explicitly duplicated the atoms, remove model symmetry information\n        copyMatrices.length = 0;\n    }\n    else if (copyMatrices.length > 1) {\n        for (let t = 0; t < atoms.length; t++) {\n            var symmetries = [];\n            for (let l = 0; l < copyMatrices.length; l++) {\n                if (!copyMatrices[l].isNearlyIdentity()) {\n                    var newXYZ = new _WebGL__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                    newXYZ.set(atoms[t].x, atoms[t].y, atoms[t].z);\n                    newXYZ.applyMatrix4(copyMatrices[l]);\n                    symmetries.push(newXYZ);\n                }\n            }\n            atoms[t].symmetries = symmetries;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/processSymmetries.ts?");

/***/ }),

/***/ "./src/parsers/utils/standardResidues.ts":
/*!***********************************************!*\
  !*** ./src/parsers/utils/standardResidues.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   standardResidues: () => (/* binding */ standardResidues)\n/* harmony export */ });\nconst standardResidues = new Set([\n    \"ABU\",\n    \"ACD\",\n    \"ALA\",\n    \"ALB\",\n    \"ALI\",\n    \"ARG\",\n    \"AR0\",\n    \"ASN\",\n    \"ASP\",\n    \"ASX\",\n    \"BAS\",\n    \"CYS\",\n    \"CYH\",\n    \"CYX\",\n    \"CSS\",\n    \"CSH\",\n    \"GLN\",\n    \"GLU\",\n    \"GLX\",\n    \"GLY\",\n    \"HIS\",\n    \"HIE\",\n    \"HID\",\n    \"HIP\",\n    \"HYP\",\n    \"ILE\",\n    \"ILU\",\n    \"LEU\",\n    \"LYS\",\n    \"MET\",\n    \"PCA\",\n    \"PGA\",\n    \"PHE\",\n    \"PR0\",\n    \"PRO\",\n    \"PRZ\",\n    \"SER\",\n    \"THR\",\n    \"TRP\",\n    \"TYR\",\n    \"VAL\",\n    \"A\",\n    \"1MA\",\n    \"C\",\n    \"5MC\",\n    \"OMC\",\n    \"G\",\n    \"1MG\",\n    \"2MG\",\n    \"M2G\",\n    \"7MG\",\n    \"OMG\",\n    \"YG\",\n    \"I\",\n    \"T\",\n    \"U\",\n    \"+U\",\n    \"H2U\",\n    \"5MU\",\n    \"PSU\",\n    \"ACE\",\n    \"F0R\",\n    \"H2O\",\n    \"HOH\",\n    \"WAT\",\n]);\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/standardResidues.ts?");

/***/ }),

/***/ "./src/parsers/utils/validateBonds.ts":
/*!********************************************!*\
  !*** ./src/parsers/utils/validateBonds.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBonds: () => (/* binding */ validateBonds)\n/* harmony export */ });\n// Make sure bonds are actually two way\nfunction validateBonds(atomsarray, serialToIndex) {\n    for (let i = 0, n = atomsarray.length; i < n; i++) {\n        const atom = atomsarray[i];\n        for (let b = 0; b < atom.bonds.length; b++) {\n            const a2i = atom.bonds[b];\n            const atom2 = atomsarray[a2i];\n            const atomi = serialToIndex[atom.serial];\n            if (atom2 && atomi) {\n                const a1i = atom2.bonds.indexOf(atomi);\n                if (a1i < 0) {\n                    atom2.bonds.push(atomi);\n                    atom2.bondOrder.push(atom.bondOrder[b]);\n                }\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/parsers/utils/validateBonds.ts?");

/***/ }),

/***/ "./src/utilities.ts":
/*!**************************!*\
  !*** ./src/utilities.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PausableTimer: () => (/* binding */ PausableTimer),\n/* harmony export */   adjustVolumeStyle: () => (/* binding */ adjustVolumeStyle),\n/* harmony export */   base64ToArray: () => (/* binding */ base64ToArray),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   download: () => (/* binding */ download),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAtomProperty: () => (/* binding */ getAtomProperty),\n/* harmony export */   getColorFromStyle: () => (/* binding */ getColorFromStyle),\n/* harmony export */   getElement: () => (/* binding */ getElement),\n/* harmony export */   getExtent: () => (/* binding */ getExtent),\n/* harmony export */   getPropertyRange: () => (/* binding */ getPropertyRange),\n/* harmony export */   getbin: () => (/* binding */ getbin),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   makeFunction: () => (/* binding */ makeFunction),\n/* harmony export */   mergeGeos: () => (/* binding */ mergeGeos),\n/* harmony export */   specStringToObject: () => (/* binding */ specStringToObject)\n/* harmony export */ });\n/* harmony import */ var _Gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Gradient */ \"./src/Gradient.ts\");\n/* harmony import */ var _VolumeData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VolumeData */ \"./src/VolumeData.ts\");\n/* harmony import */ var _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./colors */ \"./src/colors.ts\");\n//a collection of miscellaneous utility functions\n\n\n\n//simplified version of jquery extend\nfunction extend(obj1, src1) {\n    for (var key in src1) {\n        if (src1.hasOwnProperty(key) && src1[key] !== undefined) {\n            obj1[key] = src1[key];\n        }\n    }\n    return obj1;\n}\n;\n//deep copy, cannot deal with circular refs; undefined input becomes an empty object\n//https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089\nfunction deepCopy(inObject) {\n    let outObject, value, key;\n    if (inObject == undefined) {\n        return {};\n    }\n    if (typeof inObject !== \"object\" || inObject === null) {\n        return inObject; // Return the value if inObject is not an object\n    }\n    // Create an array or object to hold the values\n    outObject = Array.isArray(inObject) ? [] : {};\n    for (key in inObject) {\n        value = inObject[key];\n        // Recursively (deep) copy for nested objects, including arrays\n        outObject[key] = deepCopy(value);\n    }\n    return outObject;\n}\n;\nfunction isNumeric(obj) {\n    var type = typeof (obj);\n    return (type === \"number\" || type === \"string\") &&\n        !isNaN(obj - parseFloat(obj));\n}\n;\nfunction isEmptyObject(obj) {\n    var name;\n    for (name in obj) {\n        return false;\n    }\n    return true;\n}\n;\nfunction makeFunction(callback) {\n    //for py3dmol let users provide callback as string\n    if (callback && typeof callback === \"string\") {\n        /* jshint ignore:start */\n        callback = eval(\"(\" + callback + \")\");\n        /* jshint ignore:end */\n    }\n    // report to console if callback is not a valid function\n    if (callback && typeof callback != \"function\") {\n        return null;\n    }\n    return callback;\n}\n;\n//standardize voldata/volscheme in style\nfunction adjustVolumeStyle(style) {\n    if (style) {\n        if (style.volformat && !(style.voldata instanceof _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData)) {\n            style.voldata = new _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData(style.voldata, style.volformat);\n        }\n        if (style.volscheme) {\n            style.volscheme = _Gradient__WEBPACK_IMPORTED_MODULE_0__.Gradient.getGradient(style.volscheme);\n        }\n    }\n}\n;\n/*\n * computes the bounding box around the provided atoms\n * @param {AtomSpec[]} atomlist\n * @return {Array}\n */\nfunction getExtent(atomlist, ignoreSymmetries) {\n    var xmin, ymin, zmin, xmax, ymax, zmax, xsum, ysum, zsum, cnt;\n    var includeSym = !ignoreSymmetries;\n    xmin = ymin = zmin = 9999;\n    xmax = ymax = zmax = -9999;\n    xsum = ysum = zsum = cnt = 0;\n    if (atomlist.length === 0)\n        return [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n    for (var i = 0; i < atomlist.length; i++) {\n        var atom = atomlist[i];\n        if (typeof atom === 'undefined' || !isFinite(atom.x) ||\n            !isFinite(atom.y) || !isFinite(atom.z))\n            continue;\n        cnt++;\n        xsum += atom.x;\n        ysum += atom.y;\n        zsum += atom.z;\n        xmin = (xmin < atom.x) ? xmin : atom.x;\n        ymin = (ymin < atom.y) ? ymin : atom.y;\n        zmin = (zmin < atom.z) ? zmin : atom.z;\n        xmax = (xmax > atom.x) ? xmax : atom.x;\n        ymax = (ymax > atom.y) ? ymax : atom.y;\n        zmax = (zmax > atom.z) ? zmax : atom.z;\n        if (atom.symmetries && includeSym) {\n            for (var n = 0; n < atom.symmetries.length; n++) {\n                cnt++;\n                xsum += atom.symmetries[n].x;\n                ysum += atom.symmetries[n].y;\n                zsum += atom.symmetries[n].z;\n                xmin = (xmin < atom.symmetries[n].x) ? xmin : atom.symmetries[n].x;\n                ymin = (ymin < atom.symmetries[n].y) ? ymin : atom.symmetries[n].y;\n                zmin = (zmin < atom.symmetries[n].z) ? zmin : atom.symmetries[n].z;\n                xmax = (xmax > atom.symmetries[n].x) ? xmax : atom.symmetries[n].x;\n                ymax = (ymax > atom.symmetries[n].y) ? ymax : atom.symmetries[n].y;\n                zmax = (zmax > atom.symmetries[n].z) ? zmax : atom.symmetries[n].z;\n            }\n        }\n    }\n    return [[xmin, ymin, zmin], [xmax, ymax, zmax],\n        [xsum / cnt, ysum / cnt, zsum / cnt]];\n}\n;\n/* get the min and max values of the specified property in the provided\n* @function $3Dmol.getPropertyRange\n* @param {AtomSpec[]} atomlist - list of atoms to evaluate\n* @param {string} prop - name of property\n* @return {Array} - [min, max] values\n*/\nfunction getPropertyRange(atomlist, prop) {\n    var min = Number.POSITIVE_INFINITY;\n    var max = Number.NEGATIVE_INFINITY;\n    for (var i = 0, n = atomlist.length; i < n; i++) {\n        var atom = atomlist[i];\n        var val = getAtomProperty(atom, prop);\n        if (val != null) {\n            if (val < min)\n                min = val;\n            if (val > max)\n                max = val;\n        }\n    }\n    if (!isFinite(min) && !isFinite(max))\n        min = max = 0;\n    else if (!isFinite(min))\n        min = max;\n    else if (!isFinite(max))\n        max = min;\n    return [min, max];\n}\n;\n//adapted from https://stackoverflow.com/questions/3969475/javascript-pause-settimeout\nclass PausableTimer {\n    constructor(fn, countdown, arg) {\n        this.total_time_run = 0;\n        this.fn = fn;\n        this.arg = arg;\n        this.countdown = countdown;\n        this.start_time = new Date().getTime();\n        this.ident = setTimeout(fn, countdown, arg);\n    }\n    cancel() {\n        clearTimeout(this.ident);\n    }\n    pause() {\n        clearTimeout(this.ident);\n        this.total_time_run = new Date().getTime() - this.start_time;\n    }\n    resume() {\n        this.ident = setTimeout(this.fn, Math.max(0, this.countdown - this.total_time_run), this.arg);\n    }\n}\n;\n/*\n * Convert a base64 encoded string to a Uint8Array\n * @param {string} base64 encoded string\n */\nfunction base64ToArray(base64) {\n    var binary_string = window.atob(base64);\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n    for (var i = 0; i < len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes;\n}\n;\n//return the value of an atom property prop, or null if non existent\n// looks first in properties, then in the atom itself\nfunction getAtomProperty(atom, prop) {\n    var val = null;\n    if (atom.properties &&\n        typeof (atom.properties[prop]) != \"undefined\") {\n        val = atom.properties[prop];\n    }\n    else if (typeof (atom[prop]) != 'undefined') {\n        val = atom[prop];\n    }\n    return val;\n}\n;\n//Miscellaneous functions and classes - to be incorporated into $3Dmol proper\n/*\n *\n * @param {$3Dmol.Geometry} geometry\n * @param {$3Dmol.Mesh} mesh\n * @returns {undefined}\n */\nfunction mergeGeos(geometry, mesh) {\n    var meshGeo = mesh.geometry;\n    if (meshGeo === undefined)\n        return;\n    geometry.geometryGroups.push(meshGeo.geometryGroups[0]);\n}\n;\n/*\n * Parse a string that represents a style or atom selection and convert it\n * into an object.  The goal is to make it easier to write out these specifications\n * without resorting to json. Objects cannot be defined recursively.\n * ; - delineates fields of the object\n * : - if the field has a value other than an empty object, it comes after a colon\n * , - delineates key/value pairs of a value object\n *     If the value object consists of ONLY keys (no = present) the keys are\n *     converted to a list.  Otherwise a object of key/value pairs is created with\n *     any missing values set to null\n * = OR ~ - separates key/value pairs of a value object, if not provided value is null\n *     twiddle is supported since = has special meaning in URLs\n * @param (String) str\n * @returns {Object}\n */\nfunction specStringToObject(str) {\n    if (typeof (str) === \"object\") {\n        return str; //not string, assume was converted already\n    }\n    else if (typeof (str) === \"undefined\" || str == null) {\n        return str;\n    }\n    //if this is a json string, parse it directly\n    try {\n        let parsed = JSON.parse(str);\n        return parsed;\n    }\n    catch (error) {\n    }\n    str = str.replace(/%7E/g, '~'); //copy/pasting urls sometimes does this\n    //convert things that look like numbers into numbers\n    var massage = function (val) {\n        if (isNumeric(val)) {\n            //hexadecimal does not parse as float\n            if (Math.floor(parseFloat(val)) == parseInt(val)) {\n                return parseFloat(val);\n            }\n            else if (val.indexOf('.') >= 0) {\n                return parseFloat(val); // \".7\" for example, does not parseInt\n            }\n            else {\n                return parseInt(val);\n            }\n        }\n        //boolean conversions\n        else if (val === 'true') {\n            return true;\n        }\n        else if (val === 'false') {\n            return false;\n        }\n        return val;\n    };\n    var ret = {};\n    if (str === 'all')\n        return ret;\n    var fields = str.split(';');\n    for (var i = 0; i < fields.length; i++) {\n        var fv = fields[i].split(':');\n        var f = fv[0];\n        var val = {};\n        var vstr = fv[1];\n        if (vstr) {\n            vstr = vstr.replace(/~/g, \"=\");\n            if (vstr.indexOf('=') !== -1) {\n                //has key=value pairs, must be object\n                var kvs = vstr.split(',');\n                for (var j = 0; j < kvs.length; j++) {\n                    var kv = kvs[j].split('=', 2);\n                    val[kv[0]] = massage(kv[1]);\n                }\n            }\n            else if (vstr.indexOf(',') !== -1) {\n                //has multiple values, must list\n                val = vstr.split(',');\n            }\n            else {\n                val = massage(vstr); //value itself\n            }\n        }\n        ret[f] = val;\n    }\n    return ret;\n}\n;\nfunction checkStatus(response) {\n    if (!response.ok) {\n        throw new Error(`HTTP ${response.status} - ${response.statusText}`);\n    }\n    return response;\n}\n/**\n * Fetch data from URL\n *\n * @param uri URL\n * @param callback Function to call with data\n */\nfunction get(uri, callback) {\n    var promise = fetch(uri).then(checkStatus).then((response) => response.text());\n    if (callback)\n        return promise.then(callback);\n    else\n        return promise;\n}\n/**\n * Download binary data (e.g. a gzipped file) into an array buffer and provide\n * arraybuffer to callback.\n * @param {string} uri - location of data\n * @param {Function} [callback] - Function to call with arraybuffer as argument.\n * @param {string} [request] - type of request\n * @param {string} [postdata] - data for POST request\n * @return {Promise}\n */\nfunction getbin(uri, callback, request, postdata) {\n    var promise;\n    if (request == \"POST\") {\n        promise = fetch(uri, { method: 'POST', body: postdata })\n            .then((response) => checkStatus(response))\n            .then((response) => response.arrayBuffer());\n    }\n    else {\n        promise = fetch(uri).then((response) => checkStatus(response))\n            .then((response) => response.arrayBuffer());\n    }\n    if (callback)\n        return promise.then(callback);\n    else\n        return promise;\n}\n;\n/**\n * Load a PDB/PubChem structure into existing viewer. Automatically calls 'zoomTo' and 'render' on viewer after loading model\n * @param {string} query - String specifying pdb or pubchem id; must be prefaced with \"pdb: \" or \"cid: \", respectively\n * @param {GLViewer} viewer - Add new model to existing viewer\n * @param {Object} options - Specify additional options\n *                           format: file format to download, if multiple are available, default format is pdb\n *                           pdbUri: URI to retrieve PDB files, default URI is http://www.rcsb.org/pdb/files/\n * @param {Function} [callback] - Function to call with model as argument after data is loaded.\n  \n * @return {GLModel} GLModel, Promise if callback is not provided\n * @example\n viewer.setBackgroundColor(0xffffffff);\n       $3Dmol.download('pdb:2nbd',viewer,{onemol: true,multimodel: true},function(m) {\n        m.setStyle({'cartoon':{colorscheme:{prop:'ss',map:$3Dmol.ssColors.Jmol}}});\n       viewer.zoomTo();\n       viewer.render(callback);\n    });\n */\nfunction download(query, viewer, options, callback) {\n    var type = \"\";\n    var pdbUri = \"\";\n    var mmtfUri = \"\";\n    var uri = \"\";\n    var promise = null;\n    var m = viewer.addModel();\n    if (query.indexOf(':') < 0) {\n        //no type specifier, guess\n        if (query.length == 4) {\n            query = 'pdb:' + query;\n        }\n        else if (!isNaN(query)) {\n            query = 'cid:' + query;\n        }\n        else {\n            query = 'url:' + query;\n        }\n    }\n    if (query.substring(0, 5) === 'mmtf:') {\n        pdbUri = options && options.pdbUri ? options.pdbUri : \"https://mmtf.rcsb.org/v1.0/full/\";\n        query = query.substring(5).toUpperCase();\n        uri = pdbUri + query;\n        if (options && typeof options.noComputeSecondaryStructure === 'undefined') {\n            //when fetch directly from pdb, trust structure annotations\n            options.noComputeSecondaryStructure = true;\n        }\n        promise = new Promise(function (resolve) {\n            getbin(uri)\n                .then(function (ret) {\n                m.addMolData(ret, 'mmtf', options);\n                viewer.zoomTo();\n                viewer.render();\n                resolve(m);\n            }, function () { console.log(\"fetch of \" + uri + \" failed.\"); });\n        });\n    }\n    else {\n        if (query.substring(0, 4) === 'pdb:') {\n            type = 'mmtf';\n            if (options && options.format) {\n                type = options.format; //can override and require pdb\n            }\n            if (options && typeof options.noComputeSecondaryStructure === 'undefined') {\n                //when fetch directly from pdb, trust structure annotations\n                options.noComputeSecondaryStructure = true;\n            }\n            query = query.substring(4).toUpperCase();\n            if (!query.match(/^[1-9][A-Za-z0-9]{3}$/)) {\n                alert(\"Wrong PDB ID\");\n                return;\n            }\n            if (type == 'mmtf') {\n                mmtfUri = options && options.mmtfUri ? options.mmtfUri : 'https://mmtf.rcsb.org/v1.0/full/';\n                uri = mmtfUri + query.toUpperCase();\n            }\n            else {\n                pdbUri = options && options.pdbUri ? options.pdbUri : \"https://files.rcsb.org/view/\";\n                uri = pdbUri + query + \".\" + type;\n            }\n        }\n        else if (query.substring(0, 4) == 'cid:') {\n            type = \"sdf\";\n            query = query.substring(4);\n            if (!query.match(/^[0-9]+$/)) {\n                alert(\"Wrong Compound ID\");\n                return;\n            }\n            uri = \"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/\" + query +\n                \"/SDF?record_type=3d\";\n        }\n        else if (query.substring(0, 4) == 'url:') {\n            uri = query.substring(4);\n            type = uri;\n        }\n        var handler = function (ret) {\n            m.addMolData(ret, type, options);\n            viewer.zoomTo();\n            viewer.render();\n        };\n        promise = new Promise(function (resolve) {\n            if (type == 'mmtf') { //binary data\n                getbin(uri)\n                    .then(function (ret) {\n                    handler(ret);\n                    resolve(m);\n                }).catch(function () {\n                    //if mmtf server is being annoying, fallback to text\n                    pdbUri = options && options.pdbUri ? options.pdbUri : \"https://files.rcsb.org/view/\";\n                    uri = pdbUri + query + \".pdb\";\n                    type = \"pdb\";\n                    console.log(\"falling back to pdb format\");\n                    get(uri).then(function (data) {\n                        handler(data);\n                        resolve(m);\n                    }).catch(function (e) {\n                        handler(\"\");\n                        resolve(m);\n                        console.log(\"fetch of \" + uri + \" failed: \" + e.statusText);\n                    });\n                }); //an error msg has already been printed\n            }\n            else {\n                get(uri).then(function (data) {\n                    handler(data);\n                    resolve(m);\n                }).catch(function (e) {\n                    handler(\"\");\n                    resolve(m);\n                    console.log(\"fetch of \" + uri + \" failed: \" + e.statusText);\n                });\n            }\n        });\n    }\n    if (callback) {\n        promise.then(function (m) {\n            callback(m);\n        });\n        return m;\n    }\n    else\n        return promise;\n}\n;\n/* Return proper color for atom given style\n * @param {AtomSpec} atom\n * @param {AtomStyle} style\n * @return {Color}\n */\nfunction getColorFromStyle(atom, style) {\n    let scheme = style.colorscheme;\n    if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[scheme] != \"undefined\") {\n        scheme = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[scheme];\n    }\n    else if (typeof scheme == \"string\" && scheme.endsWith(\"Carbon\")) {\n        //any color you want of carbon\n        let ccolor = scheme\n            .substring(0, scheme.lastIndexOf(\"Carbon\"))\n            .toLowerCase();\n        if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[ccolor] != \"undefined\") {\n            let newscheme = Object.assign({}, _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors.defaultColors);\n            newscheme.C = _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[ccolor];\n            _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[scheme] = { prop: \"elem\", map: newscheme };\n            scheme = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[scheme];\n        }\n    }\n    let color = atom.color;\n    if (typeof style.color != \"undefined\" && style.color != \"spectrum\")\n        color = style.color;\n    if (typeof scheme != \"undefined\") {\n        let prop, val;\n        if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[scheme] != \"undefined\") {\n            //name of builtin colorscheme\n            scheme = _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[scheme];\n            if (typeof scheme[atom[scheme.prop]] != \"undefined\") {\n                color = scheme.map[atom[scheme.prop]];\n            }\n        }\n        else if (typeof scheme[atom[scheme.prop]] != \"undefined\") {\n            //actual color scheme provided\n            color = scheme.map[atom[scheme.prop]];\n        }\n        else if (typeof scheme.prop != \"undefined\" &&\n            typeof scheme.gradient != \"undefined\") {\n            //apply a property mapping\n            prop = scheme.prop;\n            var grad = scheme.gradient; //redefining scheme\n            if (!(grad instanceof _Gradient__WEBPACK_IMPORTED_MODULE_0__.GradientType)) {\n                grad = (0,_Gradient__WEBPACK_IMPORTED_MODULE_0__.getGradient)(scheme);\n            }\n            let range = grad.range() || [-1, 1]; //sensible default\n            val = getAtomProperty(atom, prop);\n            if (val != null) {\n                color = grad.valueToHex(val, range);\n            }\n        }\n        else if (typeof scheme.prop != \"undefined\" &&\n            typeof scheme.map != \"undefined\") {\n            //apply a discrete property mapping\n            prop = scheme.prop;\n            val = getAtomProperty(atom, prop);\n            if (typeof scheme.map[val] != \"undefined\") {\n                color = scheme.map[val];\n            }\n        }\n        else if (typeof style.colorscheme[atom.elem] != \"undefined\") {\n            //actual color scheme provided\n            color = style.colorscheme[atom.elem];\n        }\n        else {\n            console.log(\"Could not interpret colorscheme \" + scheme);\n        }\n    }\n    else if (typeof style.colorfunc != \"undefined\") {\n        //this is a user provided function for turning an atom into a color\n        color = style.colorfunc(atom);\n    }\n    let C = _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(color);\n    return C;\n}\n;\n//given a string selector, element, or jquery object, return the HTMLElement\nfunction getElement(element) {\n    let ret = element;\n    if (typeof (element) === \"string\") {\n        ret = document.querySelector(\"#\" + element);\n    }\n    else if (typeof element === 'object' && element.get) { //jquery\n        ret = element.get(0);\n    }\n    return ret;\n}\n\n\n//# sourceURL=webpack://ThreeDmol/./src/utilities.ts?");

/***/ }),

/***/ "./node_modules/upng-js/UPNG.js":
/*!**************************************!*\
  !*** ./node_modules/upng-js/UPNG.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n;(function(){\nvar UPNG = {};\n\n// Make available for import by `require()`\nvar pako;\nif (true) {module.exports = UPNG;}  else {}\nif (true) {pako = __webpack_require__(/*! pako */ \"./node_modules/upng-js/node_modules/pako/index.js\");}  else {}\nfunction log() { if (typeof process==\"undefined\" || \"development\"==\"development\") console.log.apply(console, arguments);  }\n(function(UPNG, pako){\n\n\t\n\n\t\n\nUPNG.toRGBA8 = function(out)\n{\n\tvar w = out.width, h = out.height;\n\tif(out.tabs.acTL==null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\n\t\n\tvar frms = [];\n\tif(out.frames[0].data==null) out.frames[0].data = out.data;\n\t\n\tvar img, empty = new Uint8Array(w*h*4);\n\tfor(var i=0; i<out.frames.length; i++)\n\t{\n\t\tvar frm = out.frames[i];\n\t\tvar fx=frm.rect.x, fy=frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;\n\t\tvar fdata = UPNG.toRGBA8.decodeImage(frm.data, fw,fh, out);\n\t\t\n\t\tif(i==0) img = fdata;\n\t\telse if(frm.blend  ==0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\n\t\telse if(frm.blend  ==1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n\t\t\n\t\tfrms.push(img.buffer);  img = img.slice(0);\n\t\t\n\t\tif     (frm.dispose==0) {}\n\t\telse if(frm.dispose==1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\n\t\telse if(frm.dispose==2) {\n\t\t\tvar pi = i-1;\n\t\t\twhile(out.frames[pi].dispose==2) pi--;\n\t\t\timg = new Uint8Array(frms[pi]).slice(0);\n\t\t}\n\t}\n\treturn frms;\n}\nUPNG.toRGBA8.decodeImage = function(data, w, h, out)\n{\n\tvar area = w*h, bpp = UPNG.decode._getBPP(out);\n\tvar bpl = Math.ceil(w*bpp/8);\t// bytes per line\n\n\tvar bf = new Uint8Array(area*4), bf32 = new Uint32Array(bf.buffer);\n\tvar ctype = out.ctype, depth = out.depth;\n\tvar rs = UPNG._bin.readUshort;\n\t\n\t//console.log(ctype, depth);\n\n\tif     (ctype==6) { // RGB + alpha\n\t\tvar qarea = area<<2;\n\t\tif(depth== 8) for(var i=0; i<qarea;i++) {  bf[i] = data[i];  /*if((i&3)==3 && data[i]!=0) bf[i]=255;*/ }\n\t\tif(depth==16) for(var i=0; i<qarea;i++) {  bf[i] = data[i<<1];  }\n\t}\n\telse if(ctype==2) {\t// RGB\n\t\tvar ts=out.tabs[\"tRNS\"], tr=-1, tg=-1, tb=-1;\n\t\tif(ts) {  tr=ts[0];  tg=ts[1];  tb=ts[2];  }\n\t\tif(depth== 8) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  bf[qi] = data[ti];  bf[qi+1] = data[ti+1];  bf[qi+2] = data[ti+2];  bf[qi+3] = 255;\n\t\t\tif(tr!=-1 && data[ti]   ==tr && data[ti+1]   ==tg && data[ti+2]   ==tb) bf[qi+3] = 0;  }\n\t\tif(depth==16) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6;  bf[qi] = data[ti];  bf[qi+1] = data[ti+2];  bf[qi+2] = data[ti+4];  bf[qi+3] = 255;\n\t\t\tif(tr!=-1 && rs(data,ti)==tr && rs(data,ti+2)==tg && rs(data,ti+4)==tb) bf[qi+3] = 0;  }\n\t}\n\telse if(ctype==3) {\t// palette\n\t\tvar p=out.tabs[\"PLTE\"], ap=out.tabs[\"tRNS\"], tl=ap?ap.length:0;\n\t\t//console.log(p, ap);\n\t\tif(depth==1) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>3)]>>(7-((i&7)<<0)))& 1), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==2) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>2)]>>(6-((i&3)<<1)))& 3), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==4) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>1)]>>(4-((i&1)<<2)))&15), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==8) for(var i=0; i<area; i++ ) {  var qi=i<<2, j=data[i]                      , cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t}\n\telse if(ctype==4) {\t// gray + alpha\n\t\tif(depth== 8)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<1, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+1];  }\n\t\tif(depth==16)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<2, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+2];  }\n\t}\n\telse if(ctype==0) {\t// gray\n\t\tvar tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\n\t\tif(depth== 1) for(var i=0; i<area; i++) {  var gr=255*((data[i>>3]>>(7 -((i&7)   )))& 1), al=(gr==tr*255)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\tif(depth== 2) for(var i=0; i<area; i++) {  var gr= 85*((data[i>>2]>>(6 -((i&3)<<1)))& 3), al=(gr==tr* 85)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\tif(depth== 4) for(var i=0; i<area; i++) {  var gr= 17*((data[i>>1]>>(4 -((i&1)<<2)))&15), al=(gr==tr* 17)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\tif(depth== 8) for(var i=0; i<area; i++) {  var gr=data[i  ] , al=(gr           ==tr)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\tif(depth==16) for(var i=0; i<area; i++) {  var gr=data[i<<1], al=(rs(data,i<<1)==tr)?0:255;  bf32[i]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t}\n\treturn bf;\n}\n\n\n\nUPNG.decode = function(buff)\n{\n\tvar data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;\n\tvar out = {tabs:{}, frames:[]};\n\tvar dd = new Uint8Array(data.length), doff = 0;\t // put all IDAT data into it\n\tvar fd, foff = 0;\t// frames\n\t\n\tvar mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\tfor(var i=0; i<8; i++) if(data[i]!=mgck[i]) throw \"The input is not a PNG file!\";\n\n\twhile(offset<data.length)\n\t{\n\t\tvar len  = bin.readUint(data, offset);  offset += 4;\n\t\tvar type = bin.readASCII(data, offset, 4);  offset += 4;\n\t\t//log(type,len);\n\t\t\n\t\tif     (type==\"IHDR\")  {  UPNG.decode._IHDR(data, offset, out);  }\n\t\telse if(type==\"IDAT\") {\n\t\t\tfor(var i=0; i<len; i++) dd[doff+i] = data[offset+i];\n\t\t\tdoff += len;\n\t\t}\n\t\telse if(type==\"acTL\")  {\n\t\t\tout.tabs[type] = {  num_frames:rUi(data, offset), num_plays:rUi(data, offset+4)  };\n\t\t\tfd = new Uint8Array(data.length);\n\t\t}\n\t\telse if(type==\"fcTL\")  {\n\t\t\tif(foff!=0) {  var fr = out.frames[out.frames.length-1];\n\t\t\t\tfr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\n\t\t\t}\n\t\t\tvar rct = {x:rUi(data, offset+12),y:rUi(data, offset+16),width:rUi(data, offset+4),height:rUi(data, offset+8)};\n\t\t\tvar del = rUs(data, offset+22);  del = rUs(data, offset+20) / (del==0?100:del);\n\t\t\tvar frm = {rect:rct, delay:Math.round(del*1000), dispose:data[offset+24], blend:data[offset+25]};\n\t\t\t//console.log(frm);\n\t\t\tout.frames.push(frm);\n\t\t}\n\t\telse if(type==\"fdAT\") {\n\t\t\tfor(var i=0; i<len-4; i++) fd[foff+i] = data[offset+i+4];\n\t\t\tfoff += len-4;\n\t\t}\n\t\telse if(type==\"pHYs\") {\n\t\t\tout.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset+4), data[offset+8]];\n\t\t}\n\t\telse if(type==\"cHRM\") {\n\t\t\tout.tabs[type] = [];\n\t\t\tfor(var i=0; i<8; i++) out.tabs[type].push(bin.readUint(data, offset+i*4));\n\t\t}\n\t\telse if(type==\"tEXt\") {\n\t\t\tif(out.tabs[type]==null) out.tabs[type] = {};\n\t\t\tvar nz = bin.nextZero(data, offset);\n\t\t\tvar keyw = bin.readASCII(data, offset, nz-offset);\n\t\t\tvar text = bin.readASCII(data, nz+1, offset+len-nz-1);\n\t\t\tout.tabs[type][keyw] = text;\n\t\t}\n\t\telse if(type==\"iTXt\") {\n\t\t\tif(out.tabs[type]==null) out.tabs[type] = {};\n\t\t\tvar nz = 0, off = offset;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar keyw = bin.readASCII(data, off, nz-off);  off = nz + 1;\n\t\t\tvar cflag = data[off], cmeth = data[off+1];  off+=2;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar ltag = bin.readASCII(data, off, nz-off);  off = nz + 1;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar tkeyw = bin.readUTF8(data, off, nz-off);  off = nz + 1;\n\t\t\tvar text  = bin.readUTF8(data, off, len-(off-offset));\n\t\t\tout.tabs[type][keyw] = text;\n\t\t}\n\t\telse if(type==\"PLTE\") {\n\t\t\tout.tabs[type] = bin.readBytes(data, offset, len);\n\t\t}\n\t\telse if(type==\"hIST\") {\n\t\t\tvar pl = out.tabs[\"PLTE\"].length/3;\n\t\t\tout.tabs[type] = [];  for(var i=0; i<pl; i++) out.tabs[type].push(rUs(data, offset+i*2));\n\t\t}\n\t\telse if(type==\"tRNS\") {\n\t\t\tif     (out.ctype==3) out.tabs[type] = bin.readBytes(data, offset, len);\n\t\t\telse if(out.ctype==0) out.tabs[type] = rUs(data, offset);\n\t\t\telse if(out.ctype==2) out.tabs[type] = [ rUs(data,offset),rUs(data,offset+2),rUs(data,offset+4) ];\n\t\t\t//else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n\t\t}\n\t\telse if(type==\"gAMA\") out.tabs[type] = bin.readUint(data, offset)/100000;\n\t\telse if(type==\"sRGB\") out.tabs[type] = data[offset];\n\t\telse if(type==\"bKGD\")\n\t\t{\n\t\t\tif     (out.ctype==0 || out.ctype==4) out.tabs[type] = [rUs(data, offset)];\n\t\t\telse if(out.ctype==2 || out.ctype==6) out.tabs[type] = [rUs(data, offset), rUs(data, offset+2), rUs(data, offset+4)];\n\t\t\telse if(out.ctype==3) out.tabs[type] = data[offset];\n\t\t}\n\t\telse if(type==\"IEND\") {\n\t\t\tif(foff!=0) {  var fr = out.frames[out.frames.length-1];\n\t\t\t\tfr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\n\t\t\t}\t\n\t\t\tout.data = UPNG.decode._decompress(out, dd, out.width, out.height);  break;\n\t\t}\n\t\t//else {  log(\"unknown chunk type\", type, len);  }\n\t\toffset += len;\n\t\tvar crc = bin.readUint(data, offset);  offset += 4;\n\t}\n\tdelete out.compress;  delete out.interlace;  delete out.filter;\n\treturn out;\n}\n\nUPNG.decode._decompress = function(out, dd, w, h) {\n\tif(out.compress ==0) dd = UPNG.decode._inflate(dd);\n\n\tif     (out.interlace==0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);\n\telse if(out.interlace==1) dd = UPNG.decode._readInterlace(dd, out);\n\treturn dd;\n}\n\nUPNG.decode._inflate = function(data) {  return pako[\"inflate\"](data);  }\n\nUPNG.decode._readInterlace = function(data, out)\n{\n\tvar w = out.width, h = out.height;\n\tvar bpp = UPNG.decode._getBPP(out), cbpp = bpp>>3, bpl = Math.ceil(w*bpp/8);\n\tvar img = new Uint8Array( h * bpl );\n\tvar di = 0;\n\n\tvar starting_row  = [ 0, 0, 4, 0, 2, 0, 1 ];\n\tvar starting_col  = [ 0, 4, 0, 2, 0, 1, 0 ];\n\tvar row_increment = [ 8, 8, 8, 4, 4, 2, 2 ];\n\tvar col_increment = [ 8, 8, 4, 4, 2, 2, 1 ];\n\n\tvar pass=0;\n\twhile(pass<7)\n\t{\n\t\tvar ri = row_increment[pass], ci = col_increment[pass];\n\t\tvar sw = 0, sh = 0;\n\t\tvar cr = starting_row[pass];  while(cr<h) {  cr+=ri;  sh++;  }\n\t\tvar cc = starting_col[pass];  while(cc<w) {  cc+=ci;  sw++;  }\n\t\tvar bpll = Math.ceil(sw*bpp/8);\n\t\tUPNG.decode._filterZero(data, out, di, sw, sh);\n\n\t\tvar y=0, row = starting_row[pass];\n\t\twhile(row<h)\n\t\t{\n\t\t\tvar col = starting_col[pass];\n\t\t\tvar cdi = (di+y*bpll)<<3;\n\n\t\t\twhile(col<w)\n\t\t\t{\n\t\t\t\tif(bpp==1) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(7-(cdi&7)))&1;\n\t\t\t\t\timg[row*bpl + (col>>3)] |= (val << (7-((col&3)<<0)));\n\t\t\t\t}\n\t\t\t\tif(bpp==2) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(6-(cdi&7)))&3;\n\t\t\t\t\timg[row*bpl + (col>>2)] |= (val << (6-((col&3)<<1)));\n\t\t\t\t}\n\t\t\t\tif(bpp==4) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(4-(cdi&7)))&15;\n\t\t\t\t\timg[row*bpl + (col>>1)] |= (val << (4-((col&1)<<2)));\n\t\t\t\t}\n\t\t\t\tif(bpp>=8) {\n\t\t\t\t\tvar ii = row*bpl+col*cbpp;\n\t\t\t\t\tfor(var j=0; j<cbpp; j++) img[ii+j] = data[(cdi>>3)+j];\n\t\t\t\t}\n\t\t\t\tcdi+=bpp;  col+=ci;\n\t\t\t}\n\t\t\ty++;  row += ri;\n\t\t}\n\t\tif(sw*sh!=0) di += sh * (1 + bpll);\n\t\tpass = pass + 1;\n\t}\n\treturn img;\n}\n\nUPNG.decode._getBPP = function(out) {\n\tvar noc = [1,null,3,1,2,null,4][out.ctype];\n\treturn noc * out.depth;\n}\n\nUPNG.decode._filterZero = function(data, out, off, w, h)\n{\n\tvar bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), paeth = UPNG.decode._paeth;\n\tbpp = Math.ceil(bpp/8);\n\n\tfor(var y=0; y<h; y++)  {\n\t\tvar i = off+y*bpl, di = i+y+1;\n\t\tvar type = data[di-1];\n\n\t\tif     (type==0) for(var x=  0; x<bpl; x++) data[i+x] = data[di+x];\n\t\telse if(type==1) {\n\t\t\tfor(var x=  0; x<bpp; x++) data[i+x] = data[di+x];\n\t\t\tfor(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpp])&255;\n\t\t}\n\t\telse if(y==0) {\n\t\t\tfor(var x=  0; x<bpp; x++) data[i+x] = data[di+x];\n\t\t\tif(type==2) for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x])&255;\n\t\t\tif(type==3) for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + (data[i+x-bpp]>>1) )&255;\n\t\t\tif(type==4) for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], 0, 0) )&255;\n\t\t}\n\t\telse {\n\t\t\tif(type==2) { for(var x=  0; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpl])&255;  }\n\n\t\t\tif(type==3) { for(var x=  0; x<bpp; x++) data[i+x] = (data[di+x] + (data[i+x-bpl]>>1))&255;\n\t\t\t              for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + ((data[i+x-bpl]+data[i+x-bpp])>>1) )&255;  }\n\n\t\t\tif(type==4) { for(var x=  0; x<bpp; x++) data[i+x] = (data[di+x] + paeth(0, data[i+x-bpl], 0))&255;\n\t\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], data[i+x-bpl], data[i+x-bpp-bpl]) )&255;  }\n\t\t}\n\t}\n\treturn data;\n}\n\nUPNG.decode._paeth = function(a,b,c)\n{\n\tvar p = a+b-c, pa = Math.abs(p-a), pb = Math.abs(p-b), pc = Math.abs(p-c);\n\tif (pa <= pb && pa <= pc)  return a;\n\telse if (pb <= pc)  return b;\n\treturn c;\n}\n\nUPNG.decode._IHDR = function(data, offset, out)\n{\n\tvar bin = UPNG._bin;\n\tout.width  = bin.readUint(data, offset);  offset += 4;\n\tout.height = bin.readUint(data, offset);  offset += 4;\n\tout.depth     = data[offset];  offset++;\n\tout.ctype     = data[offset];  offset++;\n\tout.compress  = data[offset];  offset++;\n\tout.filter    = data[offset];  offset++;\n\tout.interlace = data[offset];  offset++;\n}\n\nUPNG._bin = {\n\tnextZero   : function(data,p)  {  while(data[p]!=0) p++;  return p;  },\n\treadUshort : function(buff,p)  {  return (buff[p]<< 8) | buff[p+1];  },\n\twriteUshort: function(buff,p,n){  buff[p] = (n>>8)&255;  buff[p+1] = n&255;  },\n\treadUint   : function(buff,p)  {  return (buff[p]*(256*256*256)) + ((buff[p+1]<<16) | (buff[p+2]<< 8) | buff[p+3]);  },\n\twriteUint  : function(buff,p,n){  buff[p]=(n>>24)&255;  buff[p+1]=(n>>16)&255;  buff[p+2]=(n>>8)&255;  buff[p+3]=n&255;  },\n\treadASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\n\twriteASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\n\treadBytes  : function(buff,p,l){  var arr = [];   for(var i=0; i<l; i++) arr.push(buff[p+i]);   return arr;  },\n\tpad : function(n) { return n.length < 2 ? \"0\" + n : n; },\n\treadUTF8 : function(buff, p, l) {\n\t\tvar s = \"\", ns;\n\t\tfor(var i=0; i<l; i++) s += \"%\" + UPNG._bin.pad(buff[p+i].toString(16));\n\t\ttry {  ns = decodeURIComponent(s); }\n\t\tcatch(e) {  return UPNG._bin.readASCII(buff, p, l);  }\n\t\treturn  ns;\n\t}\n}\nUPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode)\n{\n\tvar w = Math.min(sw,tw), h = Math.min(sh,th);\n\tvar si=0, ti=0;\n\tfor(var y=0; y<h; y++)\n\t\tfor(var x=0; x<w; x++)\n\t\t{\n\t\t\tif(xoff>=0 && yoff>=0) {  si = (y*sw+x)<<2;  ti = (( yoff+y)*tw+xoff+x)<<2;  }\n\t\t\telse                   {  si = ((-yoff+y)*sw-xoff+x)<<2;  ti = (y*tw+x)<<2;  }\n\t\t\t\n\t\t\tif     (mode==0) {  tb[ti] = sb[si];  tb[ti+1] = sb[si+1];  tb[ti+2] = sb[si+2];  tb[ti+3] = sb[si+3];  }\n\t\t\telse if(mode==1) {\n\t\t\t\tvar fa = sb[si+3]*(1/255), fr=sb[si]*fa, fg=sb[si+1]*fa, fb=sb[si+2]*fa; \n\t\t\t\tvar ba = tb[ti+3]*(1/255), br=tb[ti]*ba, bg=tb[ti+1]*ba, bb=tb[ti+2]*ba; \n\t\t\t\t\n\t\t\t\tvar ifa=1-fa, oa = fa+ba*ifa, ioa = (oa==0?0:1/oa);\n\t\t\t\ttb[ti+3] = 255*oa;  \n\t\t\t\ttb[ti+0] = (fr+br*ifa)*ioa;  \n\t\t\t\ttb[ti+1] = (fg+bg*ifa)*ioa;   \n\t\t\t\ttb[ti+2] = (fb+bb*ifa)*ioa;  \n\t\t\t}\n\t\t\telse if(mode==2){\t// copy only differences, otherwise zero\n\t\t\t\tvar fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; \n\t\t\t\tvar ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; \n\t\t\t\tif(fa==ba && fr==br && fg==bg && fb==bb) {  tb[ti]=0;  tb[ti+1]=0;  tb[ti+2]=0;  tb[ti+3]=0;  }\n\t\t\t\telse {  tb[ti]=fr;  tb[ti+1]=fg;  tb[ti+2]=fb;  tb[ti+3]=fa;  }\n\t\t\t}\n\t\t\telse if(mode==3){\t// check if can be blended\n\t\t\t\tvar fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; \n\t\t\t\tvar ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; \n\t\t\t\tif(fa==ba && fr==br && fg==bg && fb==bb) continue;\n\t\t\t\t//if(fa!=255 && ba!=0) return false;\n\t\t\t\tif(fa<220 && ba>20) return false;\n\t\t\t}\n\t\t}\n\treturn true;\n}\n\n\n\nUPNG.encode = function(bufs, w, h, ps, dels, forbidPlte)\n{\n\tif(ps==null) ps=0;\n\tif(forbidPlte==null) forbidPlte = false;\n\tvar data = new Uint8Array(bufs[0].byteLength*bufs.length+100);\n\tvar wr=[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\tfor(var i=0; i<8; i++) data[i]=wr[i];\n\tvar offset = 8,  bin = UPNG._bin, crc = UPNG.crc.crc, wUi = bin.writeUint, wUs = bin.writeUshort, wAs = bin.writeASCII;\n\n\tvar nimg = UPNG.encode.compressPNG(bufs, w, h, ps, forbidPlte);\n\n\twUi(data,offset, 13);     offset+=4;\n\twAs(data,offset,\"IHDR\");  offset+=4;\n\twUi(data,offset,w);  offset+=4;\n\twUi(data,offset,h);  offset+=4;\n\tdata[offset] = nimg.depth;  offset++;  // depth\n\tdata[offset] = nimg.ctype;  offset++;  // ctype\n\tdata[offset] = 0;  offset++;  // compress\n\tdata[offset] = 0;  offset++;  // filter\n\tdata[offset] = 0;  offset++;  // interlace\n\twUi(data,offset,crc(data,offset-17,17));  offset+=4; // crc\n\n\t// 9 bytes to say, that it is sRGB\n\twUi(data,offset, 1);      offset+=4;\n\twAs(data,offset,\"sRGB\");  offset+=4;\n\tdata[offset] = 1;  offset++;\n\twUi(data,offset,crc(data,offset-5,5));  offset+=4; // crc\n\n\tvar anim = bufs.length>1;\n\tif(anim) {\n\t\twUi(data,offset, 8);      offset+=4;\n\t\twAs(data,offset,\"acTL\");  offset+=4;\n\t\twUi(data,offset, bufs.length);      offset+=4;\n\t\twUi(data,offset, 0);      offset+=4;\n\t\twUi(data,offset,crc(data,offset-12,12));  offset+=4; // crc\n\t}\n\n\tif(nimg.ctype==3) {\n\t\tvar dl = nimg.plte.length;\n\t\twUi(data,offset, dl*3);  offset+=4;\n\t\twAs(data,offset,\"PLTE\");  offset+=4;\n\t\tfor(var i=0; i<dl; i++){\n\t\t\tvar ti=i*3, c=nimg.plte[i], r=(c)&255, g=(c>>8)&255, b=(c>>16)&255;\n\t\t\tdata[offset+ti+0]=r;  data[offset+ti+1]=g;  data[offset+ti+2]=b;\n\t\t}\n\t\toffset+=dl*3;\n\t\twUi(data,offset,crc(data,offset-dl*3-4,dl*3+4));  offset+=4; // crc\n\n\t\tif(nimg.gotAlpha) {\n\t\t\twUi(data,offset, dl);  offset+=4;\n\t\t\twAs(data,offset,\"tRNS\");  offset+=4;\n\t\t\tfor(var i=0; i<dl; i++)  data[offset+i]=(nimg.plte[i]>>24)&255;\n\t\t\toffset+=dl;\n\t\t\twUi(data,offset,crc(data,offset-dl-4,dl+4));  offset+=4; // crc\n\t\t}\n\t}\n\t\n\tvar fi = 0;\n\tfor(var j=0; j<nimg.frames.length; j++)\n\t{\n\t\tvar fr = nimg.frames[j];\n\t\tif(anim) {\n\t\t\twUi(data,offset, 26);     offset+=4;\n\t\t\twAs(data,offset,\"fcTL\");  offset+=4;\n\t\t\twUi(data, offset, fi++);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.width );   offset+=4;\n\t\t\twUi(data, offset, fr.rect.height);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.x);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.y);   offset+=4;\n\t\t\twUs(data, offset, dels[j]);   offset+=2;\n\t\t\twUs(data, offset,  1000);   offset+=2;\n\t\t\tdata[offset] = fr.dispose;  offset++;\t// dispose\n\t\t\tdata[offset] = fr.blend  ;  offset++;\t// blend\n\t\t\twUi(data,offset,crc(data,offset-30,30));  offset+=4; // crc\n\t\t}\n\t\t\t\t\n\t\tvar imgd = fr.cimg, dl = imgd.length;\n\t\twUi(data,offset, dl+(j==0?0:4));     offset+=4;\n\t\tvar ioff = offset;\n\t\twAs(data,offset,(j==0)?\"IDAT\":\"fdAT\");  offset+=4;\n\t\tif(j!=0) {  wUi(data, offset, fi++);  offset+=4;  }\n\t\tfor(var i=0; i<dl; i++) data[offset+i] = imgd[i];\n\t\toffset += dl;\n\t\twUi(data,offset,crc(data,ioff,offset-ioff));  offset+=4; // crc\n\t}\n\n\twUi(data,offset, 0);     offset+=4;\n\twAs(data,offset,\"IEND\");  offset+=4;\n\twUi(data,offset,crc(data,offset-4,4));  offset+=4; // crc\n\n\treturn data.buffer.slice(0,offset);\n}\n\nUPNG.encode.compressPNG = function(bufs, w, h, ps, forbidPlte)\n{\n\tvar out = UPNG.encode.compress(bufs, w, h, ps, false, forbidPlte);\n\tfor(var i=0; i<bufs.length; i++) {\n\t\tvar frm = out.frames[i], nw=frm.rect.width, nh=frm.rect.height, bpl=frm.bpl, bpp=frm.bpp;\n\t\tvar fdata = new Uint8Array(nh*bpl+nh);\n\t\tfrm.cimg = UPNG.encode._filterZero(frm.img,nh,bpp,bpl,fdata);\n\t}\t\n\treturn out;\n}\n\nUPNG.encode.compress = function(bufs, w, h, ps, forGIF, forbidPlte)\n{\n\tif(forbidPlte==null) forbidPlte = false;\n\t\n\tvar ctype = 6, depth = 8, bpp = 4, alphaAnd=255\n\t\n\tfor(var j=0; j<bufs.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\n\t\tvar img = new Uint8Array(bufs[j]), ilen = img.length;\n\t\tfor(var i=0; i<ilen; i+=4) alphaAnd &= img[i+3];\n\t}\n\tvar gotAlpha = (alphaAnd)!=255;\n\t\n\tvar cmap={}, plte=[];  if(bufs.length!=0) {  cmap[0]=0;  plte.push(0);  if(ps!=0) ps--;  } \n\t\n\t\n\tif(ps!=0) {\n\t\tvar qres = UPNG.quantize(bufs, ps, forGIF);  bufs = qres.bufs;\n\t\tfor(var i=0; i<qres.plte.length; i++) {  var c=qres.plte[i].est.rgba;  if(cmap[c]==null) {  cmap[c]=plte.length;  plte.push(c);  }     }\n\t}\n\telse {\n\t\t// what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n\t\tfor(var j=0; j<bufs.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\n\t\t\tvar img32 = new Uint32Array(bufs[j]), ilen = img32.length;\n\t\t\tfor(var i=0; i<ilen; i++) {\n\t\t\t\tvar c = img32[i];\n\t\t\t\tif((i<w || (c!=img32[i-1] && c!=img32[i-w])) && cmap[c]==null) {  cmap[c]=plte.length;  plte.push(c);  if(plte.length>=300) break;  }\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvar brute = gotAlpha ? forGIF : false;\t\t// brute : frames can only be copied, not \"blended\"\n\tvar cc=plte.length;  //console.log(cc);\n\tif(cc<=256 && forbidPlte==false) {\n\t\tif(cc<= 2) depth=1;  else if(cc<= 4) depth=2;  else if(cc<=16) depth=4;  else depth=8;\n\t\tif(forGIF) depth=8;\n\t\tgotAlpha = true;\n\t}\n\t\n\t\n\tvar frms = [];\n\tfor(var j=0; j<bufs.length; j++)\n\t{\n\t\tvar cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);\n\t\t\n\t\tvar nx=0, ny=0, nw=w, nh=h, blend=0;\n\t\tif(j!=0 && !brute) {\n\t\t\tvar tlim = (forGIF || j==1 || frms[frms.length-2].dispose==2)?1:2, tstp = 0, tarea = 1e9;\n\t\t\tfor(var it=0; it<tlim; it++)\n\t\t\t{\n\t\t\t\tvar pimg = new Uint8Array(bufs[j-1-it]), p32 = new Uint32Array(bufs[j-1-it]);\n\t\t\t\tvar mix=w,miy=h,max=-1,may=-1;\n\t\t\t\tfor(var y=0; y<h; y++) for(var x=0; x<w; x++) {\n\t\t\t\t\tvar i = y*w+x;\n\t\t\t\t\tif(cimg32[i]!=p32[i]) {\n\t\t\t\t\t\tif(x<mix) mix=x;  if(x>max) max=x;\n\t\t\t\t\t\tif(y<miy) miy=y;  if(y>may) may=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar sarea = (max==-1) ? 1 : (max-mix+1)*(may-miy+1);\n\t\t\t\tif(sarea<tarea) {\n\t\t\t\t\ttarea = sarea;  tstp = it;  \n\t\t\t\t\tif(max==-1) {  nx=ny=0;  nw=nh=1;  }\n\t\t\t\t\telse {  nx = mix; ny = miy; nw = max-mix+1; nh = may-miy+1;  }\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar pimg = new Uint8Array(bufs[j-1-tstp]);\n\t\t\tif(tstp==1) frms[frms.length-1].dispose = 2;\n\t\t\t\n\t\t\tvar nimg = new Uint8Array(nw*nh*4), nimg32 = new Uint32Array(nimg.buffer);\n\t\t\tUPNG.   _copyTile(pimg,w,h, nimg,nw,nh, -nx,-ny, 0);\n\t\t\tif(UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 3)) {\n\t\t\t\tUPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 2);  blend = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 0);  blend = 0;\n\t\t\t}\n\t\t\tcimg = nimg;  cimg32 = new Uint32Array(cimg.buffer);\n\t\t}\n\t\tvar bpl = 4*nw;\n\t\tif(cc<=256 && forbidPlte==false) {\n\t\t\tbpl = Math.ceil(depth*nw/8);\n\t\t\tvar nimg = new Uint8Array(bpl*nh);\n\t\t\tfor(var y=0; y<nh; y++) {  var i=y*bpl, ii=y*nw;\n\t\t\t\tif     (depth==8) for(var x=0; x<nw; x++) nimg[i+(x)   ]   =  (cmap[cimg32[ii+x]]             );\n\t\t\t\telse if(depth==4) for(var x=0; x<nw; x++) nimg[i+(x>>1)]  |=  (cmap[cimg32[ii+x]]<<(4-(x&1)*4));\n\t\t\t\telse if(depth==2) for(var x=0; x<nw; x++) nimg[i+(x>>2)]  |=  (cmap[cimg32[ii+x]]<<(6-(x&3)*2));\n\t\t\t\telse if(depth==1) for(var x=0; x<nw; x++) nimg[i+(x>>3)]  |=  (cmap[cimg32[ii+x]]<<(7-(x&7)*1));\n\t\t\t}\n\t\t\tcimg=nimg;  ctype=3;  bpp=1;\n\t\t}\n\t\telse if(gotAlpha==false && bufs.length==1) {\t// some next \"reduced\" frames may contain alpha for blending\n\t\t\tvar nimg = new Uint8Array(nw*nh*3), area=nw*nh;\n\t\t\tfor(var i=0; i<area; i++) { var ti=i*3, qi=i*4;  nimg[ti]=cimg[qi];  nimg[ti+1]=cimg[qi+1];  nimg[ti+2]=cimg[qi+2];  }\n\t\t\tcimg=nimg;  ctype=2;  bpp=3;  bpl=3*nw;\n\t\t}\n\t\tfrms.push({rect:{x:nx,y:ny,width:nw,height:nh}, img:cimg, bpl:bpl, bpp:bpp, blend:blend, dispose:brute?1:0});\n\t}\n\treturn {ctype:ctype, depth:depth, plte:plte, gotAlpha:gotAlpha, frames:frms  };\n}\n\nUPNG.encode._filterZero = function(img,h,bpp,bpl,data)\n{\n\tvar fls = [];\n\tfor(var t=0; t<5; t++) {  if(h*bpl>500000 && (t==2 || t==3 || t==4)) continue;\n\t\tfor(var y=0; y<h; y++) UPNG.encode._filterLine(data, img, y, bpl, bpp, t);\n\t\tfls.push(pako[\"deflate\"](data));  if(bpp==1) break;\n\t}\n\tvar ti, tsize=1e9;\n\tfor(var i=0; i<fls.length; i++) if(fls[i].length<tsize) {  ti=i;  tsize=fls[i].length;  }\n\treturn fls[ti];\n}\nUPNG.encode._filterLine = function(data, img, y, bpl, bpp, type)\n{\n\tvar i = y*bpl, di = i+y, paeth = UPNG.decode._paeth\n\tdata[di]=type;  di++;\n\n\tif(type==0) for(var x=0; x<bpl; x++) data[di+x] = img[i+x];\n\telse if(type==1) {\n\t\tfor(var x=  0; x<bpp; x++) data[di+x] =  img[i+x];\n\t\tfor(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]-img[i+x-bpp]+256)&255;\n\t}\n\telse if(y==0) {\n\t\tfor(var x=  0; x<bpp; x++) data[di+x] = img[i+x];\n\n\t\tif(type==2) for(var x=bpp; x<bpl; x++) data[di+x] = img[i+x];\n\t\tif(type==3) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - (img[i+x-bpp]>>1) +256)&255;\n\t\tif(type==4) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - paeth(img[i+x-bpp], 0, 0) +256)&255;\n\t}\n\telse {\n\t\tif(type==2) { for(var x=  0; x<bpl; x++) data[di+x] = (img[i+x]+256 - img[i+x-bpl])&255;  }\n\t\tif(type==3) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - (img[i+x-bpl]>>1))&255;\n\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - ((img[i+x-bpl]+img[i+x-bpp])>>1))&255;  }\n\t\tif(type==4) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - paeth(0, img[i+x-bpl], 0))&255;\n\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - paeth(img[i+x-bpp], img[i+x-bpl], img[i+x-bpp-bpl]))&255;  }\n\t}\n}\n\nUPNG.crc = {\n\ttable : ( function() {\n\t   var tab = new Uint32Array(256);\n\t   for (var n=0; n<256; n++) {\n\t\t\tvar c = n;\n\t\t\tfor (var k=0; k<8; k++) {\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\n\t\t\t\telse        c = c >>> 1;\n\t\t\t}\n\t\t\ttab[n] = c;  }\n\t\treturn tab;  })(),\n\tupdate : function(c, buf, off, len) {\n\t\tfor (var i=0; i<len; i++)  c = UPNG.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\n\t\treturn c;\n\t},\n\tcrc : function(b,o,l)  {  return UPNG.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\n}\n\n\nUPNG.quantize = function(bufs, ps, roundAlpha)\n{\t\n\tvar imgs = [], totl = 0;\n\tfor(var i=0; i<bufs.length; i++) {  imgs.push(UPNG.encode.alphaMul(new Uint8Array(bufs[i]), roundAlpha));  totl+=bufs[i].byteLength;  }\n\t\n\tvar nimg = new Uint8Array(totl), nimg32 = new Uint32Array(nimg.buffer), noff=0;\n\tfor(var i=0; i<imgs.length; i++) {\n\t\tvar img = imgs[i], il = img.length;\n\t\tfor(var j=0; j<il; j++) nimg[noff+j] = img[j];\n\t\tnoff += il;\n\t}\n\t\n\tvar root = {i0:0, i1:nimg.length, bst:null, est:null, tdst:0, left:null, right:null };  // basic statistic, extra statistic\n\troot.bst = UPNG.quantize.stats(  nimg,root.i0, root.i1  );  root.est = UPNG.quantize.estats( root.bst );\n\tvar leafs = [root];\n\t\n\twhile(leafs.length<ps)\n\t{\n\t\tvar maxL = 0, mi=0;\n\t\tfor(var i=0; i<leafs.length; i++) if(leafs[i].est.L > maxL) {  maxL=leafs[i].est.L;  mi=i;  }\n\t\tif(maxL<1e-3) break;\n\t\tvar node = leafs[mi];\n\t\t\n\t\tvar s0 = UPNG.quantize.splitPixels(nimg,nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n\t\t\n\t\tvar ln = {i0:node.i0, i1:s0, bst:null, est:null, tdst:0, left:null, right:null };  ln.bst = UPNG.quantize.stats( nimg, ln.i0, ln.i1 );  \n\t\tln.est = UPNG.quantize.estats( ln.bst );\n\t\tvar rn = {i0:s0, i1:node.i1, bst:null, est:null, tdst:0, left:null, right:null };  rn.bst = {R:[], m:[], N:node.bst.N-ln.bst.N};\n\t\tfor(var i=0; i<16; i++) rn.bst.R[i] = node.bst.R[i]-ln.bst.R[i];\n\t\tfor(var i=0; i< 4; i++) rn.bst.m[i] = node.bst.m[i]-ln.bst.m[i];\n\t\trn.est = UPNG.quantize.estats( rn.bst );\n\t\t\n\t\tnode.left = ln;  node.right = rn;\n\t\tleafs[mi]=ln;  leafs.push(rn);\n\t}\n\tleafs.sort(function(a,b) {  return b.bst.N-a.bst.N;  });\n\t\n\tfor(var ii=0; ii<imgs.length; ii++) {\n\t\tvar planeDst = UPNG.quantize.planeDst;\n\t\tvar sb = new Uint8Array(imgs[ii].buffer), tb = new Uint32Array(imgs[ii].buffer), len = sb.length;\n\t\t\n\t\tvar stack = [], si=0;\n\t\tfor(var i=0; i<len; i+=4) {\n\t\t\tvar r=sb[i]*(1/255), g=sb[i+1]*(1/255), b=sb[i+2]*(1/255), a=sb[i+3]*(1/255);\n\t\t\t\n\t\t\t//  exact, but too slow :(\n\t\t\t//var nd = UPNG.quantize.getNearest(root, r, g, b, a);\n\t\t\tvar nd = root;\n\t\t\twhile(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\n\t\t\t\n\t\t\ttb[i>>2] = nd.est.rgba;\n\t\t}\n\t\timgs[ii]=tb.buffer;\n\t}\n\treturn {  bufs:imgs, plte:leafs  };\n}\nUPNG.quantize.getNearest = function(nd, r,g,b,a)\n{\n\tif(nd.left==null) {  nd.tdst = UPNG.quantize.dist(nd.est.q,r,g,b,a);  return nd;  }\n\tvar planeDst = UPNG.quantize.planeDst(nd.est,r,g,b,a);\n\t\n\tvar node0 = nd.left, node1 = nd.right;\n\tif(planeDst>0) {  node0=nd.right;  node1=nd.left;  }\n\t\n\tvar ln = UPNG.quantize.getNearest(node0, r,g,b,a);\n\tif(ln.tdst<=planeDst*planeDst) return ln;\n\tvar rn = UPNG.quantize.getNearest(node1, r,g,b,a);\n\treturn rn.tdst<ln.tdst ? rn : ln;\n}\nUPNG.quantize.planeDst = function(est, r,g,b,a) {  var e = est.e;  return e[0]*r + e[1]*g + e[2]*b + e[3]*a - est.eMq;  }\nUPNG.quantize.dist     = function(q,   r,g,b,a) {  var d0=r-q[0], d1=g-q[1], d2=b-q[2], d3=a-q[3];  return d0*d0+d1*d1+d2*d2+d3*d3;  }\n\nUPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq)\n{\n\tvar vecDot = UPNG.quantize.vecDot;\n\ti1-=4;\n\tvar shfs = 0;\n\twhile(i0<i1)\n\t{\n\t\twhile(vecDot(nimg, i0, e)<=eMq) i0+=4;\n\t\twhile(vecDot(nimg, i1, e)> eMq) i1-=4;\n\t\tif(i0>=i1) break;\n\t\t\n\t\tvar t = nimg32[i0>>2];  nimg32[i0>>2] = nimg32[i1>>2];  nimg32[i1>>2]=t;\n\t\t\n\t\ti0+=4;  i1-=4;\n\t}\n\twhile(vecDot(nimg, i0, e)>eMq) i0-=4;\n\treturn i0+4;\n}\nUPNG.quantize.vecDot = function(nimg, i, e)\n{\n\treturn nimg[i]*e[0] + nimg[i+1]*e[1] + nimg[i+2]*e[2] + nimg[i+3]*e[3];\n}\nUPNG.quantize.stats = function(nimg, i0, i1){\n\tvar R = [0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0];\n\tvar m = [0,0,0,0];\n\tvar N = (i1-i0)>>2;\n\tfor(var i=i0; i<i1; i+=4)\n\t{\n\t\tvar r = nimg[i]*(1/255), g = nimg[i+1]*(1/255), b = nimg[i+2]*(1/255), a = nimg[i+3]*(1/255);\n\t\t//var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n\t\tm[0]+=r;  m[1]+=g;  m[2]+=b;  m[3]+=a;\n\t\t\n\t\tR[ 0] += r*r;  R[ 1] += r*g;  R[ 2] += r*b;  R[ 3] += r*a;  \n\t\t               R[ 5] += g*g;  R[ 6] += g*b;  R[ 7] += g*a; \n\t\t                              R[10] += b*b;  R[11] += b*a;  \n\t\t                                             R[15] += a*a;  \n\t}\n\tR[4]=R[1];  R[8]=R[2];  R[12]=R[3];  R[9]=R[6];  R[13]=R[7];  R[14]=R[11];\n\t\n\treturn {R:R, m:m, N:N};\n}\nUPNG.quantize.estats = function(stats){\n\tvar R = stats.R, m = stats.m, N = stats.N;\n\t\n\tvar m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = (N==0 ? 0 : 1/N);\n\tvar Rj = [\n\t\tR[ 0] - m0*m0*iN,  R[ 1] - m0*m1*iN,  R[ 2] - m0*m2*iN,  R[ 3] - m0*m3*iN,  \n\t\tR[ 4] - m1*m0*iN,  R[ 5] - m1*m1*iN,  R[ 6] - m1*m2*iN,  R[ 7] - m1*m3*iN,\n\t\tR[ 8] - m2*m0*iN,  R[ 9] - m2*m1*iN,  R[10] - m2*m2*iN,  R[11] - m2*m3*iN,  \n\t\tR[12] - m3*m0*iN,  R[13] - m3*m1*iN,  R[14] - m3*m2*iN,  R[15] - m3*m3*iN \n\t];\n\t\n\tvar A = Rj, M = UPNG.M4;\n\tvar b = [0.5,0.5,0.5,0.5], mi = 0, tmi = 0;\n\t\n\tif(N!=0)\n\tfor(var i=0; i<10; i++) {\n\t\tb = M.multVec(A, b);  tmi = Math.sqrt(M.dot(b,b));  b = M.sml(1/tmi,  b);\n\t\tif(Math.abs(tmi-mi)<1e-9) break;  mi = tmi;\n\t}\t\n\t//b = [0,0,1,0];  mi=N;\n\tvar q = [m0*iN, m1*iN, m2*iN, m3*iN];\n\tvar eMq255 = M.dot(M.sml(255,q),b);\n\t\n\tvar ia = (q[3]<0.001) ? 0 : 1/q[3];\n\t\n\treturn {  Cov:Rj, q:q, e:b, L:mi,  eMq255:eMq255, eMq : M.dot(b,q),\n\t\t\t\trgba: (((Math.round(255*q[3])<<24) | (Math.round(255*q[2]*ia)<<16) |  (Math.round(255*q[1]*ia)<<8) | (Math.round(255*q[0]*ia)<<0))>>>0)  };\n}\nUPNG.M4 = {\n\tmultVec : function(m,v) {\n\t\t\treturn [\n\t\t\t\tm[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3],\n\t\t\t\tm[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3],\n\t\t\t\tm[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3],\n\t\t\t\tm[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3]\n\t\t\t];\n\t},\n\tdot : function(x,y) {  return  x[0]*y[0]+x[1]*y[1]+x[2]*y[2]+x[3]*y[3];  },\n\tsml : function(a,y) {  return [a*y[0],a*y[1],a*y[2],a*y[3]];  }\n}\n\nUPNG.encode.alphaMul = function(img, roundA) {\n\tvar nimg = new Uint8Array(img.length), area = img.length>>2; \n\tfor(var i=0; i<area; i++) {\n\t\tvar qi=i<<2, ia=img[qi+3];   \n\t\tif(roundA) ia = ((ia<128))?0:255;\n\t\tvar a = ia*(1/255);\n\t\tnimg[qi+0] = img[qi+0]*a;  nimg[qi+1] = img[qi+1]*a;  nimg[qi+2] = img[qi+2]*a;  nimg[qi+3] = ia;\n\t}\n\treturn nimg;\n}\n\n\t\n\t\n\t\n\t\n\t\n\n\n})(UPNG, pako);\n})();\n\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/UPNG.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = (__webpack_require__(/*! ./lib/utils/common */ \"./node_modules/upng-js/node_modules/pako/lib/utils/common.js\").assign);\n\nvar deflate   = __webpack_require__(/*! ./lib/deflate */ \"./node_modules/upng-js/node_modules/pako/lib/deflate.js\");\nvar inflate   = __webpack_require__(/*! ./lib/inflate */ \"./node_modules/upng-js/node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js\");\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/index.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/deflate.js":
/*!***************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/deflate.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/upng-js/node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/upng-js/node_modules/pako/lib/utils/strings.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js\");\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/deflate.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/inflate.js":
/*!***************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/inflate.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/upng-js/node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/upng-js/node_modules/pako/lib/utils/strings.js\");\nvar c            = __webpack_require__(/*! ./zlib/constants */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader     = __webpack_require__(/*! ./zlib/gzheader */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js\");\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/inflate.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/utils/common.js":
/*!********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/utils/common.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/utils/common.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js":
/*!*********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/utils/strings.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(/*! ./common */ \"./node_modules/upng-js/node_modules/pako/lib/utils/common.js\");\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/utils/strings.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js":
/*!********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js":
/*!**********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js":
/*!******************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js":
/*!********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = __webpack_require__(/*! ../utils/common */ \"./node_modules/upng-js/node_modules/pako/lib/utils/common.js\");\nvar trees   = __webpack_require__(/*! ./trees */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32   = __webpack_require__(/*! ./crc32 */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js\");\nvar msg     = __webpack_require__(/*! ./messages */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js":
/*!********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js":
/*!********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = __webpack_require__(/*! ../utils/common */ \"./node_modules/upng-js/node_modules/pako/lib/utils/common.js\");\nvar adler32       = __webpack_require__(/*! ./adler32 */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32         = __webpack_require__(/*! ./crc32 */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast  = __webpack_require__(/*! ./inffast */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js\");\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js":
/*!*********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/upng-js/node_modules/pako/lib/utils/common.js\");\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js":
/*!*********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js":
/*!******************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/upng-js/node_modules/pako/lib/utils/common.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js?");

/***/ }),

/***/ "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js":
/*!********************************************************************!*\
  !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/basic/basic.frag":
/*!************************************************!*\
  !*** ./src/WebGL/shaders/lib/basic/basic.frag ***!
  \************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform mat4 viewMatrix;\\n| uniform float opacity;\\n| uniform vec3 fogColor;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/basic/basic.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/basic/basic.vert":
/*!************************************************!*\
  !*** ./src/WebGL/shaders/lib/basic/basic.vert ***!
  \************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform mat4 viewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/basic/basic.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/instanced/instanced.frag":
/*!********************************************************!*\
  !*** ./src/WebGL/shaders/lib/instanced/instanced.frag ***!
  \********************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform mat4 viewMatrix;\\n| uniform float opacity;\\n| \");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/instanced/instanced.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/instanced/instanced.vert":
/*!********************************************************!*\
  !*** ./src/WebGL/shaders/lib/instanced/instanced.vert ***!
  \********************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform mat4 viewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/instanced/instanced.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/lambert/lambert.frag":
/*!****************************************************!*\
  !*** ./src/WebGL/shaders/lib/lambert/lambert.frag ***!
  \****************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform mat4 viewMatrix;\\n| uniform float opacity;\\n| \");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/lambert/lambert.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/lambert/lambert.vert":
/*!****************************************************!*\
  !*** ./src/WebGL/shaders/lib/lambert/lambert.vert ***!
  \****************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (2:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform mat4 viewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/lambert/lambert.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag":
/*!****************************************************************!*\
  !*** ./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag ***!
  \****************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform mat4 viewMatrix;\\n| uniform float opacity;\\n| \");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert":
/*!****************************************************************!*\
  !*** ./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert ***!
  \****************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform mat4 viewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/outline/outline.frag":
/*!****************************************************!*\
  !*** ./src/WebGL/shaders/lib/outline/outline.frag ***!
  \****************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform float opacity;\\n| uniform vec3 outlineColor;\\n| uniform vec3 fogColor;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/outline/outline.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/outline/outline.vert":
/*!****************************************************!*\
  !*** ./src/WebGL/shaders/lib/outline/outline.vert ***!
  \****************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform float outlineWidth;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/outline/outline.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/screen/screen.frag":
/*!**************************************************!*\
  !*** ./src/WebGL/shaders/lib/screen/screen.frag ***!
  \**************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform sampler2D colormap;\\n| varying highp vec2 vTexCoords;\\n| uniform vec2 dimensions;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/screen/screen.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/screen/screen.vert":
/*!**************************************************!*\
  !*** ./src/WebGL/shaders/lib/screen/screen.vert ***!
  \**************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:10)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> attribute vec2 vertexPosition;\\n| varying highp vec2 vTexCoords;\\n| const vec2 scale = vec2(0.5, 0.5);\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/screen/screen.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/screenaa/screenaa.frag":
/*!******************************************************!*\
  !*** ./src/WebGL/shaders/lib/screenaa/screenaa.frag ***!
  \******************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform sampler2D colormap;\\n| varying highp vec2 vTexCoords;\\n| uniform vec2 dimensions;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/screenaa/screenaa.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/screenaa/screenaa.vert":
/*!******************************************************!*\
  !*** ./src/WebGL/shaders/lib/screenaa/screenaa.vert ***!
  \******************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:10)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> attribute vec2 vertexPosition;\\n| varying highp vec2 vTexCoords;\\n| const vec2 scale = vec2(0.5, 0.5);\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/screenaa/screenaa.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag":
/*!******************************************************************!*\
  !*** ./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag ***!
  \******************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (2:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n> uniform mat4 viewMatrix;\\n| uniform float opacity;\\n| uniform mat4 projectionMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert":
/*!******************************************************************!*\
  !*** ./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert ***!
  \******************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform mat4 viewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag":
/*!********************************************************************************!*\
  !*** ./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag ***!
  \********************************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform float opacity;\\n| uniform vec3 outlineColor;\\n| uniform vec3 fogColor;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert":
/*!********************************************************************************!*\
  !*** ./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert ***!
  \********************************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform float outlineWidth;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sprite/sprite.frag":
/*!**************************************************!*\
  !*** ./src/WebGL/shaders/lib/sprite/sprite.frag ***!
  \**************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform vec3 color;\\n| uniform sampler2D map;\\n| uniform float opacity;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sprite/sprite.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/sprite/sprite.vert":
/*!**************************************************!*\
  !*** ./src/WebGL/shaders/lib/sprite/sprite.vert ***!
  \**************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform int useScreenCoordinates;\\n| uniform vec3 screenPosition;\\n| uniform mat4 modelViewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/sprite/sprite.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag":
/*!************************************************************************!*\
  !*** ./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag ***!
  \************************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:10)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n>     float dotProduct = dot( norm, vLight );\\n|     vec3 light = vec3( max( dotProduct, 0.0 ) );\\n|     gl_FragColor = vec4(light*color, opacity*opacity );\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert":
/*!****************************************************************!*\
  !*** ./src/WebGL/shaders/lib/stickimposter/stickimposter.vert ***!
  \****************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform mat4 viewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/stickimposter/stickimposter.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert":
/*!******************************************************************************!*\
  !*** ./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert ***!
  \******************************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (3:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n| \\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform mat4 viewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/volumetric/volumetric.frag":
/*!**********************************************************!*\
  !*** ./src/WebGL/shaders/lib/volumetric/volumetric.frag ***!
  \**********************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (2:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n| \\n> uniform highp sampler3D data;\\n| uniform highp sampler2D colormap;\\n| uniform highp sampler2D depthmap;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/volumetric/volumetric.frag?");

/***/ }),

/***/ "./src/WebGL/shaders/lib/volumetric/volumetric.vert":
/*!**********************************************************!*\
  !*** ./src/WebGL/shaders/lib/volumetric/volumetric.vert ***!
  \**********************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform mat4 modelViewMatrix;\\n| uniform mat4 projectionMatrix;\\n| uniform mat4 viewMatrix;\");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/lib/volumetric/volumetric.vert?");

/***/ }),

/***/ "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag":
/*!**************************************************************************!*\
  !*** ./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag ***!
  \**************************************************************************/
/***/ (() => {

eval("throw new Error(\"Module parse failed: Unexpected token (1:8)\\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\\n> uniform float opacity;\\n| uniform mat4 projectionMatrix;\\n| \");\n\n//# sourceURL=webpack://ThreeDmol/./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag?");

/***/ }),

/***/ "./node_modules/pako/dist/pako.esm.mjs":
/*!*********************************************!*\
  !*** ./node_modules/pako/dist/pako.esm.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deflate: () => (/* binding */ Deflate_1),\n/* harmony export */   Inflate: () => (/* binding */ Inflate_1),\n/* harmony export */   constants: () => (/* binding */ constants_1),\n/* harmony export */   \"default\": () => (/* binding */ pako),\n/* harmony export */   deflate: () => (/* binding */ deflate_1),\n/* harmony export */   deflateRaw: () => (/* binding */ deflateRaw_1),\n/* harmony export */   gzip: () => (/* binding */ gzip_1),\n/* harmony export */   inflate: () => (/* binding */ inflate_1),\n/* harmony export */   inflateRaw: () => (/* binding */ inflateRaw_1),\n/* harmony export */   ungzip: () => (/* binding */ ungzip_1)\n/* harmony export */ });\n\n/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED$1               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN$1             = 2;\n\n/*============================================================================*/\n\n\nfunction zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH$1    = 3;\nconst MAX_MATCH$1    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES$1  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS$1      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES$1       = 30;\n/* number of distance codes */\n\nconst BL_CODES$1      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n/* maximum heap size */\n\nconst MAX_BITS$1      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES$1 + 2) * 2);\nzero$1(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES$1 * 2);\nzero$1(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero$1(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\nzero$1(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES$1);\nzero$1(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES$1);\nzero$1(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Tracev((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) => {\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n\n  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n    code = (code + bl_count[bits - 1]) << 1;\n    next_code[bits] = code;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS$1 + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES$1; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES$1; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.sym_next = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) => {\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) => {\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let sx = 0;         /* running index in sym_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.sym_next !== 0) {\n    do {\n      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;\n      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;\n      lc = s.pending_buf[s.sym_buf + sx++];\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and sym_buf is ok: */\n      //Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n\n    } while (sx < s.sym_next);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE$1;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) => {\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"block list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* block_mask is the bit mask of block-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let block_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"block-listed\") bytes. */\n  for (n = 0; n <= 31; n++, block_mask >>>= 1) {\n    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"allow-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS$1; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"block-listed\" or \"allow-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init$1 = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  bi_windup(s);        /* align on byte boundary */\n  put_short(s, stored_len);\n  put_short(s, ~stored_len);\n  if (stored_len) {\n    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);\n  }\n  s.pending += stored_len;\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align$1 = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n */\nconst _tr_flush_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN$1) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->sym_next / 3));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block$1(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally$1 = (s, dist, lc) => {\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist;\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;\n  s.pending_buf[s.sym_buf + s.sym_next++] = lc;\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n  return (s.sym_next === s.sym_end);\n};\n\nvar _tr_init_1  = _tr_init$1;\nvar _tr_stored_block_1 = _tr_stored_block$1;\nvar _tr_flush_block_1  = _tr_flush_block$1;\nvar _tr_tally_1 = _tr_tally$1;\nvar _tr_align_1 = _tr_align$1;\n\nvar trees = {\n\t_tr_init: _tr_init_1,\n\t_tr_stored_block: _tr_stored_block_1,\n\t_tr_flush_block: _tr_flush_block_1,\n\t_tr_tally: _tr_tally_1,\n\t_tr_align: _tr_align_1\n};\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32 = (adler, buf, len, pos) => {\n  let s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n};\n\n\nvar adler32_1 = adler32;\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nconst makeTable = () => {\n  let c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n};\n\n// Create table on load. Just 255 signed longs. Not a problem.\nconst crcTable = new Uint32Array(makeTable());\n\n\nconst crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n\n  crc ^= -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n};\n\n\nvar crc32_1 = crc32;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar messages = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar constants$2 = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  Z_MEM_ERROR:       -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,\n  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,\n  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n  Z_UNKNOWN,\n  Z_DEFLATED: Z_DEFLATED$2\n} = constants$2;\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS$1 = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */\n//#ifdef GZIP\nconst GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n//#endif\nconst EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */\nconst NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */\nconst COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */\nconst HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */\nconst BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */\nconst FINISH_STATE  = 666;    /* stream complete */\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = messages[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) * 2) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */\nconst slide_hash = (s) => {\n  let n, m;\n  let p;\n  let wsize = s.w_size;\n\n  n = s.hash_size;\n  p = n;\n  do {\n    m = s.head[--p];\n    s.head[p] = (m >= wsize ? m - wsize : 0);\n  } while (--n);\n  n = wsize;\n//#ifndef FASTEST\n  p = n;\n  do {\n    m = s.prev[--p];\n    s.prev[p] = (m >= wsize ? m - wsize : 0);\n    /* If n is not on any hash chain, prev[n] is garbage but\n     * its value will never be used.\n     */\n  } while (--n);\n//#endif\n};\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out  += len;\n  s.pending_out  += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending      -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let n, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n      if (s.insert > s.strstart) {\n        s.insert = s.strstart;\n      }\n      slide_hash(s);\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunites to have a single copy from next_in to next_out.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Smallest worthy block size when not flushing or finishing. By default\n   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n   * large input and output buffers, the stored block size will be larger.\n   */\n  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;\n\n  /* Copy as many min_block or larger stored blocks directly to next_out as\n   * possible. If flushing, copy the remaining available input to next_out as\n   * stored blocks, if there is enough space.\n   */\n  let len, left, have, last = 0;\n  let used = s.strm.avail_in;\n  do {\n    /* Set len to the maximum size block that we can copy directly with the\n     * available input data and output space. Set left to how much of that\n     * would be copied from what's left in the window.\n     */\n    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */\n    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    if (s.strm.avail_out < have) {         /* need room for header */\n      break;\n    }\n      /* maximum stored block length that will fit in avail_out: */\n    have = s.strm.avail_out - have;\n    left = s.strstart - s.block_start;  /* bytes left in window */\n    if (len > left + s.strm.avail_in) {\n      len = left + s.strm.avail_in;   /* limit len to the input */\n    }\n    if (len > have) {\n      len = have;             /* limit len to the output */\n    }\n\n    /* If the stored block would be less than min_block in length, or if\n     * unable to copy all of the available input when flushing, then try\n     * copying to the window and the pending buffer instead. Also don't\n     * write an empty block when flushing -- deflate() does that.\n     */\n    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||\n                        flush === Z_NO_FLUSH$2 ||\n                        len !== left + s.strm.avail_in)) {\n      break;\n    }\n\n    /* Make a dummy stored block in pending to get the header bytes,\n     * including any pending bits. This also updates the debugging counts.\n     */\n    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;\n    _tr_stored_block(s, 0, 0, last);\n\n    /* Replace the lengths in the dummy stored block with len. */\n    s.pending_buf[s.pending - 4] = len;\n    s.pending_buf[s.pending - 3] = len >> 8;\n    s.pending_buf[s.pending - 2] = ~len;\n    s.pending_buf[s.pending - 1] = ~len >> 8;\n\n    /* Write the stored block header bytes. */\n    flush_pending(s.strm);\n\n//#ifdef ZLIB_DEBUG\n//    /* Update debugging counts for the data about to be copied. */\n//    s->compressed_len += len << 3;\n//    s->bits_sent += len << 3;\n//#endif\n\n    /* Copy uncompressed bytes from the window to next_out. */\n    if (left) {\n      if (left > len) {\n        left = len;\n      }\n      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);\n      s.strm.next_out += left;\n      s.strm.avail_out -= left;\n      s.strm.total_out += left;\n      s.block_start += left;\n      len -= left;\n    }\n\n    /* Copy uncompressed bytes directly from next_in to next_out, updating\n     * the check value.\n     */\n    if (len) {\n      read_buf(s.strm, s.strm.output, s.strm.next_out, len);\n      s.strm.next_out += len;\n      s.strm.avail_out -= len;\n      s.strm.total_out += len;\n    }\n  } while (last === 0);\n\n  /* Update the sliding window with the last s->w_size bytes of the copied\n   * data, or append all of the copied data to the existing window if less\n   * than s->w_size bytes were copied. Also update the number of bytes to\n   * insert in the hash tables, in the event that deflateParams() switches to\n   * a non-zero compression level.\n   */\n  used -= s.strm.avail_in;    /* number of input bytes directly copied */\n  if (used) {\n    /* If any input was used, then no unused input remains in the window,\n     * therefore s->block_start == s->strstart.\n     */\n    if (used >= s.w_size) {  /* supplant the previous history */\n      s.matches = 2;     /* clear hash */\n      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);\n      s.strstart = s.w_size;\n      s.insert = s.strstart;\n    }\n    else {\n      if (s.window_size - s.strstart <= used) {\n        /* Slide the window down. */\n        s.strstart -= s.w_size;\n        //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n        if (s.matches < 2) {\n          s.matches++;   /* add a pending slide_hash() */\n        }\n        if (s.insert > s.strstart) {\n          s.insert = s.strstart;\n        }\n      }\n      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);\n      s.strstart += used;\n      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;\n    }\n    s.block_start = s.strstart;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* If the last block was written to next_out, then done. */\n  if (last) {\n    return BS_FINISH_DONE;\n  }\n\n  /* If flushing and all input has been consumed, then done. */\n  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&\n    s.strm.avail_in === 0 && s.strstart === s.block_start) {\n    return BS_BLOCK_DONE;\n  }\n\n  /* Fill the window with any remaining input. */\n  have = s.window_size - s.strstart;\n  if (s.strm.avail_in > have && s.block_start >= s.w_size) {\n    /* Slide the window down. */\n    s.block_start -= s.w_size;\n    s.strstart -= s.w_size;\n    //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n    if (s.matches < 2) {\n      s.matches++;       /* add a pending slide_hash() */\n    }\n    have += s.w_size;      /* more space now */\n    if (s.insert > s.strstart) {\n      s.insert = s.strstart;\n    }\n  }\n  if (have > s.strm.avail_in) {\n    have = s.strm.avail_in;\n  }\n  if (have) {\n    read_buf(s.strm, s.window, s.strstart, have);\n    s.strstart += have;\n    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* There was not enough avail_out to write a complete worthy or flushed\n   * stored block to next_out. Write a stored block to pending instead, if we\n   * have enough input for a worthy block, or if flushing and there is enough\n   * room for the remaining input as a stored block in the pending buffer.\n   */\n  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    /* maximum stored block length that will fit in pending: */\n  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;\n  min_block = have > s.w_size ? s.w_size : have;\n  left = s.strstart - s.block_start;\n  if (left >= min_block ||\n     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&\n     s.strm.avail_in === 0 && left <= have)) {\n    len = left > have ? have : left;\n    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&\n         len === left ? 1 : 0;\n    _tr_stored_block(s, s.block_start, len, last);\n    s.block_start += len;\n    flush_pending(s.strm);\n  }\n\n  /* We've done all we can with the available input and output. */\n  return last ? BS_FINISH_STARTED : BS_NEED_MORE;\n};\n\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH$2) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.sym_buf = 0;        /* buffer for distances and literals/lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.sym_next = 0;      /* running index in sym_buf */\n  this.sym_end = 0;       /* symbol table full when sym_next reaches this */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nconst deflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const s = strm.state;\n  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&\n//#ifdef GZIP\n                                s.status !== GZIP_STATE &&\n//#endif\n                                s.status !== EXTRA_STATE &&\n                                s.status !== NAME_STATE &&\n                                s.status !== COMMENT_STATE &&\n                                s.status !== HCRC_STATE &&\n                                s.status !== BUSY_STATE &&\n                                s.status !== FINISH_STATE)) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status =\n//#ifdef GZIP\n    s.wrap === 2 ? GZIP_STATE :\n//#endif\n    s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = -2;\n  _tr_init(s);\n  return Z_OK$3;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK$3) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR$2;\n  }\n  strm.state.gzhead = head;\n  return Z_OK$3;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR$2;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION$1) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n  s.status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  /* We overlay pending_buf and sym_buf. This works since the average size\n   * for length/distance pairs over any compressed block is assured to be 31\n   * bits or less.\n   *\n   * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n   * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n   * possible fixed-codes length/distance pair is then 31 bits total.\n   *\n   * sym_buf starts one-fourth of the way into pending_buf. So there are\n   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n   * in sym_buf is three bytes -- two for the distance and one for the\n   * literal/length. As each symbol is consumed, the pointer to the next\n   * sym_buf value to read moves forward three bytes. From that symbol, up to\n   * 31 bits are written to pending_buf. The closest the written pending_buf\n   * bits gets to the next sym_buf symbol to read is just before the last\n   * code is written. At that time, 31*(n-2) bits have been written, just\n   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n   * symbols are written.) The closest the writing gets to what is unread is\n   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n   * can range from 128 to 32768.\n   *\n   * Therefore, at a minimum, there are 142 bits of space between what is\n   * written and what is read in the overlain buffers, so the symbols cannot\n   * be overwritten by the compressed data. That space is actually 139 bits,\n   * due to the three-bit fixed-code block header.\n   *\n   * That covers the case where either Z_FIXED is specified, forcing fixed\n   * codes, or when the use of fixed codes is chosen, because that choice\n   * results in a smaller compressed block than dynamic codes. That latter\n   * condition then assures that the above analysis also covers all dynamic\n   * blocks. A dynamic-code block will only be chosen to be emitted if it has\n   * fewer bits than a fixed-code block would for the same set of symbols.\n   * Therefore its average symbol length is assured to be less than 31. So\n   * the compressed data for a dynamic block also cannot overwrite the\n   * symbols from which it is being constructed.\n   */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->sym_buf = s->pending_buf + s->lit_bufsize;\n  s.sym_buf = s.lit_bufsize;\n\n  //s->sym_end = (s->lit_bufsize - 1) * 3;\n  s.sym_end = (s.lit_bufsize - 1) * 3;\n  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n};\n\n\n/* ========================================================================= */\nconst deflate$2 = (strm, flush) => {\n\n  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (strm.avail_in !== 0 && !strm.input) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n  }\n\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH$3) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* Write the header */\n  if (s.status === INIT_STATE && s.wrap === 0) {\n    s.status = BUSY_STATE;\n  }\n  if (s.status === INIT_STATE) {\n    /* zlib header */\n    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n    let level_flags = -1;\n\n    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n      level_flags = 0;\n    } else if (s.level < 6) {\n      level_flags = 1;\n    } else if (s.level === 6) {\n      level_flags = 2;\n    } else {\n      level_flags = 3;\n    }\n    header |= (level_flags << 6);\n    if (s.strstart !== 0) { header |= PRESET_DICT; }\n    header += 31 - (header % 31);\n\n    putShortMSB(s, header);\n\n    /* Save the adler32 of the preset dictionary: */\n    if (s.strstart !== 0) {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n    strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#ifdef GZIP\n  if (s.status === GZIP_STATE) {\n    /* gzip header */\n    strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n    put_byte(s, 31);\n    put_byte(s, 139);\n    put_byte(s, 8);\n    if (!s.gzhead) { // s->gzhead == Z_NULL\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, OS_CODE);\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK$3;\n      }\n    }\n    else {\n      put_byte(s, (s.gzhead.text ? 1 : 0) +\n                  (s.gzhead.hcrc ? 2 : 0) +\n                  (!s.gzhead.extra ? 0 : 4) +\n                  (!s.gzhead.name ? 0 : 8) +\n                  (!s.gzhead.comment ? 0 : 16)\n      );\n      put_byte(s, s.gzhead.time & 0xff);\n      put_byte(s, (s.gzhead.time >> 8) & 0xff);\n      put_byte(s, (s.gzhead.time >> 16) & 0xff);\n      put_byte(s, (s.gzhead.time >> 24) & 0xff);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, s.gzhead.os & 0xff);\n      if (s.gzhead.extra && s.gzhead.extra.length) {\n        put_byte(s, s.gzhead.extra.length & 0xff);\n        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n      }\n      if (s.gzhead.hcrc) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n      }\n      s.gzindex = 0;\n      s.status = EXTRA_STATE;\n    }\n  }\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;\n      while (s.pending + left > s.pending_buf_size) {\n        let copy = s.pending_buf_size - s.pending;\n        // zmemcpy(s.pending_buf + s.pending,\n        //    s.gzhead.extra + s.gzindex, copy);\n        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);\n        s.pending = s.pending_buf_size;\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex += copy;\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n        beg = 0;\n        left -= copy;\n      }\n      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility\n      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11\n      let gzhead_extra = new Uint8Array(s.gzhead.extra);\n      // zmemcpy(s->pending_buf + s->pending,\n      //     s->gzhead->extra + s->gzindex, left);\n      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);\n      s.pending += left;\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = NAME_STATE;\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = COMMENT_STATE;\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n    }\n    s.status = HCRC_STATE;\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n      }\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n    }\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#endif\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {\n    let bstate = s.level === 0 ? deflate_stored(s, flush) :\n                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s.strategy === Z_RLE ? deflate_rle(s, flush) :\n                 configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK$3;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH$1) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK$3;\n      }\n    }\n  }\n\n  if (flush !== Z_FINISH$3) { return Z_OK$3; }\n  if (s.wrap <= 0) { return Z_STREAM_END$3; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const status = strm.state.status;\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK$3;\n};\n\n\nvar deflateInit_1 = deflateInit;\nvar deflateInit2_1 = deflateInit2;\nvar deflateReset_1 = deflateReset;\nvar deflateResetKeep_1 = deflateResetKeep;\nvar deflateSetHeader_1 = deflateSetHeader;\nvar deflate_2$1 = deflate$2;\nvar deflateEnd_1 = deflateEnd;\nvar deflateSetDictionary_1 = deflateSetDictionary;\nvar deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateGetDictionary = deflateGetDictionary;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n\nvar deflate_1$2 = {\n\tdeflateInit: deflateInit_1,\n\tdeflateInit2: deflateInit2_1,\n\tdeflateReset: deflateReset_1,\n\tdeflateResetKeep: deflateResetKeep_1,\n\tdeflateSetHeader: deflateSetHeader_1,\n\tdeflate: deflate_2$1,\n\tdeflateEnd: deflateEnd_1,\n\tdeflateSetDictionary: deflateSetDictionary_1,\n\tdeflateInfo: deflateInfo\n};\n\nconst _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar assign = function (obj /*from1, from2, from3, ...*/) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// Join array of chunks to single array.\nvar flattenChunks = (chunks) => {\n  // calculate data length\n  let len = 0;\n\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n\n  // join chunks\n  const result = new Uint8Array(len);\n\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n\n  return result;\n};\n\nvar common = {\n\tassign: assign,\n\tflattenChunks: flattenChunks\n};\n\n// String encode/decode helpers\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nlet STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nconst _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nvar string2buf = (str) => {\n  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str);\n  }\n\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper\nconst buf2binstring = (buf, len) => {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\n\n\n// convert array to string\nvar buf2string = (buf, max) => {\n  const len = max || buf.length;\n\n  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n    return new TextDecoder().decode(buf.subarray(0, max));\n  }\n\n  let i, out;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  const utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    let c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    let c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = (buf, max) => {\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\nvar strings = {\n\tstring2buf: string2buf,\n\tbuf2string: buf2string,\n\tutf8border: utf8border\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nvar zstream = ZStream;\n\nconst toString$1 = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,\n  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED: Z_DEFLATED$1\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate$1(options) {\n  this.options = common.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY\n  }, options || {});\n\n  let opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n\n  let status = deflate_1$2.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK$2) {\n    throw new Error(messages[status]);\n  }\n\n  if (opt.header) {\n    deflate_1$2.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    let dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = deflate_1$2.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK$2) {\n      throw new Error(messages[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n\n  if (this.ended) { return false; }\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString$1.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    // Make sure avail_out > 6 to avoid repeating markers\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    status = deflate_1$2.deflate(strm, _flush_mode);\n\n    // Ended => flush and finish\n    if (status === Z_STREAM_END$2) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = deflate_1$2.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK$2;\n    }\n\n    // Flush if out buffer full\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n\n    // Flush if requested and has data\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$2) {\n    this.result = common.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate$1(input, options) {\n  const deflator = new Deflate$1(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate$1(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip$1(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate$1(input, options);\n}\n\n\nvar Deflate_1$1 = Deflate$1;\nvar deflate_2 = deflate$1;\nvar deflateRaw_1$1 = deflateRaw$1;\nvar gzip_1$1 = gzip$1;\nvar constants$1 = constants$2;\n\nvar deflate_1$1 = {\n\tDeflate: Deflate_1$1,\n\tdeflate: deflate_2,\n\tdeflateRaw: deflateRaw_1$1,\n\tgzip: gzip_1$1,\n\tconstants: constants$1\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nconst BAD$1 = 16209;       /* got a data error -- remain here until reset */\nconst TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvar inffast = function inflate_fast(strm, start) {\n  let _in;                    /* local strm.input */\n  let last;                   /* have enough input while in < last */\n  let _out;                   /* local strm.output */\n  let beg;                    /* inflate()'s initial strm.output */\n  let end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  let dmax;                   /* maximum distance from zlib header */\n//#endif\n  let wsize;                  /* window size or zero if not using window */\n  let whave;                  /* valid bytes in the window */\n  let wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  let s_window;               /* allocated sliding window, if wsize != 0 */\n  let hold;                   /* local strm.hold */\n  let bits;                   /* local strm.bits */\n  let lcode;                  /* local strm.lencode */\n  let dcode;                  /* local strm.distcode */\n  let lmask;                  /* mask for first level of length codes */\n  let dmask;                  /* mask for first level of distance codes */\n  let here;                   /* retrieved table entry */\n  let op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  let len;                    /* match length, unused bytes */\n  let dist;                   /* match distance */\n  let from;                   /* where to copy match from */\n  let from_source;\n\n\n  let input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  const state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD$1;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD$1;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD$1;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE$1;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD$1;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst MAXBITS = 15;\nconst ENOUGH_LENS$1 = 852;\nconst ENOUGH_DISTS$1 = 592;\n//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst CODES$1 = 0;\nconst LENS$1 = 1;\nconst DISTS$1 = 2;\n\nconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n]);\n\nconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n]);\n\nconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n]);\n\nconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n]);\n\nconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n{\n  const bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  let len = 0;               /* a code's length in bits */\n  let sym = 0;               /* index of code symbols */\n  let min = 0, max = 0;          /* minimum and maximum code lengths */\n  let root = 0;              /* number of index bits for root table */\n  let curr = 0;              /* number of index bits for current table */\n  let drop = 0;              /* code bits to drop for sub-table */\n  let left = 0;                   /* number of prefix codes available */\n  let used = 0;              /* code entries in table used */\n  let huff = 0;              /* Huffman code */\n  let incr;              /* for incrementing code, index */\n  let fill;              /* index for replicating entries */\n  let low;               /* low bits for current root entry */\n  let mask;              /* mask for low root bits */\n  let next;             /* next available space in table */\n  let base = null;     /* base value table to use */\n//  let shoextra;    /* extra bits table to use */\n  let match;                  /* use base and extra for symbol >= match */\n  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  let extra = null;\n\n  let here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES$1 || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES$1) {\n    base = extra = work;    /* dummy value--not used */\n    match = 20;\n\n  } else if (type === LENS$1) {\n    base = lbase;\n    extra = lext;\n    match = 257;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    match = 0;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] + 1 < match) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] >= match) {\n      here_op = extra[work[sym] - match];\n      here_val = base[work[sym] - match];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\nvar inftrees = inflate_table;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n\n\n\n\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,\n  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,\n  Z_DEFLATED\n} = constants$2;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nconst    HEAD = 16180;       /* i: waiting for magic header */\nconst    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */\nconst    TIME = 16182;       /* i: waiting for modification time (gzip) */\nconst    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */\nconst    EXLEN = 16184;      /* i: waiting for extra length (gzip) */\nconst    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */\nconst    NAME = 16186;       /* i: waiting for end of file name (gzip) */\nconst    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */\nconst    HCRC = 16188;       /* i: waiting for header crc (gzip) */\nconst    DICTID = 16189;    /* i: waiting for dictionary check value */\nconst    DICT = 16190;      /* waiting for inflateSetDictionary() call */\nconst        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */\nconst        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */\nconst        STORED = 16193;    /* i: waiting for stored size (length and complement) */\nconst        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */\nconst        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */\nconst        TABLE = 16196;     /* i: waiting for dynamic block table lengths */\nconst        LENLENS = 16197;   /* i: waiting for code length code lengths */\nconst        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */\nconst            LEN_ = 16199;      /* i: same as LEN below, but only first time in */\nconst            LEN = 16200;       /* i: waiting for length/lit/eob code */\nconst            LENEXT = 16201;    /* i: waiting for length extra bits */\nconst            DIST = 16202;      /* i: waiting for distance code */\nconst            DISTEXT = 16203;   /* i: waiting for distance extra bits */\nconst            MATCH = 16204;     /* o: waiting for output space to copy string */\nconst            LIT = 16205;       /* o: waiting for output space to write literal */\nconst    CHECK = 16206;     /* i: waiting for 32-bit check value */\nconst    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */\nconst    DONE = 16208;      /* finished check, done -- remain here until reset */\nconst    BAD = 16209;       /* got a data error -- remain here until reset */\nconst    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */\nconst    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_WBITS = MAX_WBITS;\n\n\nconst zswap32 = (q) => {\n\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n};\n\n\nfunction InflateState() {\n  this.strm = null;           /* pointer back to this zlib stream */\n  this.mode = 0;              /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,\n                                 bit 2 true to validate check value */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib), or\n                                 -1 if raw or no header yet */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n  this.work = new Uint16Array(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\n\nconst inflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const state = strm.state;\n  if (!state || state.strm !== strm ||\n    state.mode < HEAD || state.mode > SYNC) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst inflateResetKeep = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.flags = -1;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK$1;\n};\n\n\nconst inflateReset = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n};\n\n\nconst inflateReset2 = (strm, windowBits) => {\n  let wrap;\n\n  /* get the state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 5;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\n\n\nconst inflateInit2 = (strm, windowBits) => {\n\n  if (!strm) { return Z_STREAM_ERROR$1; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  const state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.strm = strm;\n  state.window = null/*Z_NULL*/;\n  state.mode = HEAD;     /* to pass state test in inflateReset2() */\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$1) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n};\n\n\nconst inflateInit = (strm) => {\n\n  return inflateInit2(strm, DEF_WBITS);\n};\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nlet virgin = true;\n\nlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\n\nconst fixedtables = (state) => {\n\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n\n    /* literal/length table */\n    let sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nconst updatewindow = (strm, src, end, copy) => {\n\n  let dist;\n  const state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Uint8Array(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n};\n\n\nconst inflate$2 = (strm, flush) => {\n\n  let state;\n  let input, output;          // input/output buffers\n  let next;                   /* next input INDEX */\n  let put;                    /* next output INDEX */\n  let have, left;             /* available input and output */\n  let hold;                   /* bit buffer */\n  let bits;                   /* bits in bit buffer */\n  let _in, _out;              /* save starting available input and output */\n  let copy;                   /* number of stored or match bytes to copy */\n  let from;                   /* where to copy match bytes from */\n  let from_source;\n  let here = 0;               /* current decoding table entry */\n  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //let last;                   /* parent table entry */\n  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  let len;                    /* length to copy for repeats, bits to drop */\n  let ret;                    /* return code */\n  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n  let opts;\n\n  let n; // temporary variable for NEED_BITS\n\n  const order = /* permutation of code lengths */\n    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n\n\n  if (inflateStateCheck(strm) || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK$1;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          if (state.wbits === 0) {\n            state.wbits = 15;\n          }\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        if (len > 15 || len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n\n        // !!! pako patch. Force use `options.windowBits` if passed.\n        // Required to always use max window size by default.\n        state.dmax = 1 << state.wbits;\n        //state.dmax = 1 << len;\n\n        state.flags = 0;               /* indicate zlib header */\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Uint8Array(state.head.extra_len);\n              }\n              state.head.extra.set(\n                input.subarray(\n                  next,\n                  // extra field is limited to 65536 bytes\n                  // - no need for additional size check\n                  next + copy\n                ),\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if ((state.flags & 0x0200) && (state.wrap & 4)) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT$1;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          output.set(input.subarray(next, next + copy), put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inffast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if ((state.wrap & 4) && _out) {\n            strm.adler = state.check =\n                /*UPDATE_CHECK(state.check, put - _out, _out);*/\n                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END$1;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR$1;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR$1;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR$1;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH$1))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if ((state.wrap & 4) && _out) {\n    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n};\n\n\nconst inflateEnd = (strm) => {\n\n  if (inflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$1;\n};\n\n\nconst inflateGetHeader = (strm, head) => {\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK$1;\n};\n\n\nconst inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n\n  let state;\n  let dictid;\n  let ret;\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32_1(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR$1;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR$1;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK$1;\n};\n\n\nvar inflateReset_1 = inflateReset;\nvar inflateReset2_1 = inflateReset2;\nvar inflateResetKeep_1 = inflateResetKeep;\nvar inflateInit_1 = inflateInit;\nvar inflateInit2_1 = inflateInit2;\nvar inflate_2$1 = inflate$2;\nvar inflateEnd_1 = inflateEnd;\nvar inflateGetHeader_1 = inflateGetHeader;\nvar inflateSetDictionary_1 = inflateSetDictionary;\nvar inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.inflateCodesUsed = inflateCodesUsed;\nmodule.exports.inflateCopy = inflateCopy;\nmodule.exports.inflateGetDictionary = inflateGetDictionary;\nmodule.exports.inflateMark = inflateMark;\nmodule.exports.inflatePrime = inflatePrime;\nmodule.exports.inflateSync = inflateSync;\nmodule.exports.inflateSyncPoint = inflateSyncPoint;\nmodule.exports.inflateUndermine = inflateUndermine;\nmodule.exports.inflateValidate = inflateValidate;\n*/\n\nvar inflate_1$2 = {\n\tinflateReset: inflateReset_1,\n\tinflateReset2: inflateReset2_1,\n\tinflateResetKeep: inflateResetKeep_1,\n\tinflateInit: inflateInit_1,\n\tinflateInit2: inflateInit2_1,\n\tinflate: inflate_2$1,\n\tinflateEnd: inflateEnd_1,\n\tinflateGetHeader: inflateGetHeader_1,\n\tinflateSetDictionary: inflateSetDictionary_1,\n\tinflateInfo: inflateInfo\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nvar gzheader = GZheader;\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_FINISH,\n  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate$1(options) {\n  this.options = common.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: ''\n  }, options || {});\n\n  const opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new zstream();\n  this.strm.avail_out = 0;\n\n  let status  = inflate_1$2.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(messages[status]);\n  }\n\n  this.header = new gzheader();\n\n  inflate_1$2.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer): input data\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n *   `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. If end of stream detected,\n * [[Inflate#onEnd]] will be called.\n *\n * `flush_mode` is not needed for normal operation, because end of stream\n * detected automatically. You may try to use it for advanced things, but\n * this functionality was not tested.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n\n  if (this.ended) return false;\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n  // Convert data if needed\n  if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = inflate_1$2.inflate(strm, _flush_mode);\n\n    if (status === Z_NEED_DICT && dictionary) {\n      status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n\n      if (status === Z_OK) {\n        status = inflate_1$2.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR) {\n        // Replace code with more verbose\n        status = Z_NEED_DICT;\n      }\n    }\n\n    // Skip snyc markers if more data follows and not raw mode\n    while (strm.avail_in > 0 &&\n           status === Z_STREAM_END &&\n           strm.state.wrap > 0 &&\n           data[strm.next_in] !== 0)\n    {\n      inflate_1$2.inflateReset(strm);\n      status = inflate_1$2.inflate(strm, _flush_mode);\n    }\n\n    switch (status) {\n      case Z_STREAM_ERROR:\n      case Z_DATA_ERROR:\n      case Z_NEED_DICT:\n      case Z_MEM_ERROR:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n\n    // Remember real `avail_out` value, because we may patch out buffer content\n    // to align utf8 strings boundaries.\n    last_avail_out = strm.avail_out;\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END) {\n\n        if (this.options.to === 'string') {\n\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail & realign counters\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n\n    // Must repeat iteration if out buffer is full\n    if (status === Z_OK && last_avail_out === 0) continue;\n\n    // Finalize if end of stream reached.\n    if (status === Z_STREAM_END) {\n      status = inflate_1$2.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|String): output data. When string output requested,\n *   each chunk will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = common.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako');\n * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n * let output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err) {\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate$1(input, options) {\n  const inflator = new Inflate$1(options);\n\n  inflator.push(input);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) throw inflator.msg || messages[inflator.err];\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate$1(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nvar Inflate_1$1 = Inflate$1;\nvar inflate_2 = inflate$1;\nvar inflateRaw_1$1 = inflateRaw$1;\nvar ungzip$1 = inflate$1;\nvar constants = constants$2;\n\nvar inflate_1$1 = {\n\tInflate: Inflate_1$1,\n\tinflate: inflate_2,\n\tinflateRaw: inflateRaw_1$1,\n\tungzip: ungzip$1,\n\tconstants: constants\n};\n\nconst { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;\n\nconst { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\n\n\n\nvar Deflate_1 = Deflate;\nvar deflate_1 = deflate;\nvar deflateRaw_1 = deflateRaw;\nvar gzip_1 = gzip;\nvar Inflate_1 = Inflate;\nvar inflate_1 = inflate;\nvar inflateRaw_1 = inflateRaw;\nvar ungzip_1 = ungzip;\nvar constants_1 = constants$2;\n\nvar pako = {\n\tDeflate: Deflate_1,\n\tdeflate: deflate_1,\n\tdeflateRaw: deflateRaw_1,\n\tgzip: gzip_1,\n\tInflate: Inflate_1,\n\tinflate: inflate_1,\n\tinflateRaw: inflateRaw_1,\n\tungzip: ungzip_1,\n\tconstants: constants_1\n};\n\n\n\n\n//# sourceURL=webpack://ThreeDmol/./node_modules/pako/dist/pako.esm.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});